{"meta":{"title":"guardwhy","subtitle":"just do it","description":"专注于技术,热爱生活,分享知识","author":"guardwhy","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2020-04-29T02:21:58.000Z","updated":"2020-04-29T02:22:22.024Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"books","date":"2020-05-07T08:39:23.000Z","updated":"2020-05-07T08:43:00.176Z","comments":true,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-04-29T02:22:38.000Z","updated":"2020-04-29T02:22:59.473Z","comments":true,"path":"contact/index.html","permalink":"http://yoursite.com/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2020-04-29T02:25:06.000Z","updated":"2020-04-29T02:25:34.464Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-04-29T02:19:56.000Z","updated":"2020-04-29T02:20:48.288Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-04-29T02:21:09.000Z","updated":"2020-04-29T02:21:41.505Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"MySQL安装","slug":"MySQL/MySQL安装","date":"2020-09-24T23:45:33.000Z","updated":"2020-09-24T23:52:12.270Z","comments":true,"path":"2020/09/25/mysql/mysql-an-zhuang/","link":"","permalink":"http://yoursite.com/2020/09/25/mysql/mysql-an-zhuang/","excerpt":"","text":"MySQL安装1.1-Windows 上安装 MySQL1、进入官方下载地址下载安装MySQL5.7版本:：https://dev.mysql.com/downloads/mysql/ 2.选择直接下载 3.解压安装3.1、将下载完的 zip 包解压到相应的目录,这里我将解压后的文件夹放在E:\\Develop\\MySQL-5.7.30下,解压文件如图所示 3.2、在该文件夹下创建 my.ini 配置文件，编辑 my.ini 配置以下基本信息： [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] # 设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=E:\\\\Develop\\\\MySQL-5.7.30 # 设置 mysql数据库的数据的存放目录（MySQL8.0+ 不需要以下配置，系统自己生成即可，否则有可能报错） datadir=E:\\\\Develop\\\\WorkPlace\\\\SqlData # 允许最大连接数 max_connections=20 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 3.3、以管理员身份打开 cmd 命令行工具，进入目录： E: cd E:E:\\Develop\\MySQL-5.7.30 初始化数据库: mysqld --initialize --console 3.4、运行mysqld install，若提示 “Service successfully installed.” 表示安装成功。 4.修改密码4.1、执行net start mysql启动MySQL 4.2、运行mysql -u root -p后根据提示输入初始密码，回车后即可登录进MySQL。 4.3、修改密码命令的格式为 修改格式:set password for userName@localhost = password('newPassword'); 密码设置为:set password for userName@localhost = password('root'); 输入exit后回车，再运行mysql -u root -p后就可以用新密码登录了。 5.配置环境变量5.1、右键此电脑 &gt;&gt; 高级系统设置 &gt;&gt; 环境变量 ，新建系统变量 MYSQL_HOME，变量值是安装MySQL的根目录： 5.2、编辑系统变量 Path &gt;&gt; 新建 &gt;&gt; 将 %MYSQL_HOME%\\bin 添加到尾行 &gt;&gt; 确定。 5.3、配置好后，不用进入MySQL安装目录，以管理员身份打开命令行后，就可以直接登录MySQL了 2.1-Linux上安装MySQL1-linux安装dockerLinux环境中的Centos7.x以上版本,安装docker虚拟化容器. （1）yum 包更新到最新：yum update （2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 > yum install -y yum-utils device-mapper-persistent-data lvm2 （3）设置yum源为阿里云 > yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo （4）安装docker > yum install docker-ce -y （5）安装后查看docker版本 > docker -v 2-设置mirror镜像源sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF' { \"registry-mirrors\": [\"https://0wrdwnn6.mirror.aliyuncs.com\"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 3-Docker的启动与停止# 启动docker： systemctl start docker # 停止docker： systemctl stop docker # 重启docker： systemctl restart docker # 查看docker状态： systemctl status docker # 开机启动： systemctl enable docker systemctl unenable docker # 查看docker概要信息 docker info # 查看docker帮助文档 docker --help 4-Docker镜像相关的命令4.1、查看镜像 docker images 4.2、搜素镜像 docker search 镜像名称 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 4.3 拉取镜像 拉取镜像就是从中央仓库中下载镜像到本地docker pull 镜像名称 docker pull centos:7 4.4、删除镜像按镜像ID删除镜像 docker rmi 镜像ID docker rmi 镜像名称 docker rmi 镜像名称:tag docker rmi `docker images -q` 删除所有镜像（谨慎操作） 5-容器创建与启动容器5-1:查看容器 查看最后一次运行的容器:docker ps -l 查看运行容器:docker ps 查看所有容器:docker ps -a 进入容器其中字符串为容器ID:docker exec -it d27bd3008ad9 /bin/bash 停用全部运行中的容器:docker stop $(docker ps -q) 删除全部容器：docker rm $(docker ps -aq) 5-2:创建容器 交互式方式创建容器(==创建以后就进入到容器内部了==) docker run -it --name 容器名称 镜像名称:标签 /bin/bash 退出当前容器:exit 守护式方式创建容器：（默认自动启动你的容器）: docker run -di --name 容器名称 镜像名称:标签 登录守护式容器方式： docker exec -it 容器名称 (或者容器ID) /bin/bash 6-启动与停止容器#停止容器： docker stop 容器名称（或者容器ID） docker stop 容器名称（或者容器ID） ，容器名称（或者容器ID） #重启容器： docker restart 容器名称（或者容器ID） docker restart 容器名称（或者容器ID） ，容器名称（或者容器ID） # 启动容器： docker start 容器名称（或者容器ID） docker start 容器名称（或者容器ID）容器名称（或者容器ID） # 删除容器 docker rm 容器名称（或者容器ID） docker rm 容器名称（或者容器ID） 容器名称（或者容器ID） # 查询启动日志 docker log -f 容器id(容器名字) 7-使用Docker安装mysql容器7.1-拉取mysql镜像 docker pull mysql docker pull mysql:5.7 7.2-创建容器(安装MySQL) docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 7.3、进入容器，修改root用户允许远程访问。 进入容器：docker exec -it 7681b85e73a1 /bin/sh 修改远程权限：alter user 'root'@'%' identified with mysql_native_password by 'root'; 7.4、 打开3306、22端口允许远程连接 开端口命令：firewall-cmd --zone=public --add-port=3306/tcp --permanent 开端口命令：firewall-cmd --zone=public --add-port=22/tcp --permanent 重启防火墙：systemctl restart firewalld.service 7.5、创建挂载目录 [root@guardwhy docker]# mkdir -p mysql/data #挂载数据文件 [root@guardwhy docker]# mkdir -p mysql/logs #挂载日志文件 [root@guardwhy docker]# mkdir -p mysql/conf #挂载配置文件 7.6、拷贝配置文件并且修改配置文件 1.docker cp mysql:/etc/mysql/mysql.conf.d/mysqld.cnf /usr/local/docker/mysql/conf 2. 编辑mysqld.conf vi /my/mysql/conf/mysqld.conf 3-设置字符集 character-set-server=utf8 7.7-删除容器，重新整合安装. docker run \\ --name mysql \\ -p 3306:3306 \\ -v /usr/local/docker/mysql/conf:/etc/mysql/mysql.conf.d/ \\ -v /usr/local/docker/mysql/data:/var/lib/mysql \\ -v /usr/local/docker/mysql/logs:/logs \\ -e MYSQL_ROOT_PASSWORD=root \\ -d mysql:5.7 \\ --character-set-server=utf8mb4 \\ --collation-server=utf8mb4_unicode_ci document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}],"keywords":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}]},{"title":"linux之用户管理","slug":"linux/linux之用户管理","date":"2020-04-18T02:05:49.000Z","updated":"2020-04-18T07:01:29.980Z","comments":true,"path":"2020/04/18/linux/linux-zhi-yong-hu-guan-li/","link":"","permalink":"http://yoursite.com/2020/04/18/linux/linux-zhi-yong-hu-guan-li/","excerpt":"","text":"1-添加用户 useradd [选项] 用户名。 也可以通过useradd -d指定目录, 新的用户名，给新创建的用户指定家目录 图示： 给用户修改密码语法： passwd 用户名 图示： 2-删除用户语法userdel 用户名 删除用户 kobe，但是要保留家目录 删除用户 Jmaes 以及用户主目录 图示: 3-切换用户在操作 Linux 中，如果当前用户的权限不够，可以通过 su - 指令，切换到高权限用户，比如 root 语法：su –切换用户名 图示： 4-用户组语法： 添加组: groupadd 组名 删除组：groupdel 组名 增加用户组语法： useradd -g 用户组 用户名 图示： 修改用户组语法： usermod -g 用户组 用户名 图示 配置信息 1./etc/passwd 文件。 用户（user）的配置文件，记录用户的各种信息。 2 . /etc/shadow 文件 口令的配置文件 每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志。 3./etc/group 文件 组(group)的配置文件，记录 Linux 包含的组的信息每行含义：组名:口令:组标识号:组内用户列表 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}]},{"title":"javaScript之数组","slug":"前端/JavaScript/javaScript之数组","date":"2020-02-29T08:54:26.000Z","updated":"2020-03-08T12:08:57.665Z","comments":true,"path":"2020/02/29/qian-duan/javascript/javascript-zhi-shu-zu/","link":"","permalink":"http://yoursite.com/2020/02/29/qian-duan/javascript/javascript-zhi-shu-zu/","excerpt":"","text":"数组的概念 数组可以把一组相关的数据一起存放，并提供方便的访问(获取）方式。 数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式。 创建数组javaScript中创建数组有两种方式： 利用 new 创建数组 var 数组名 = new Array() ； // 创建一个新的空数组 var arr = new Array(); 注意 Array () ，A 要大写 利用数组字面量创建数组 //1. 使用数组字面量方式创建空的数组 var 数组名 = []； //2. 使用数组字面量方式创建带初始值的数组 var 数组名 = ['kebe','jmaes',10,'11']; 数组的字面量是方括号 [ ] 声明数组并赋值称为数组的初始化 这种字面量方式也是我们以后最多使用的方式 数组元素的类型 数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。 var arrStus = ['隆多',12,true,28.9]; 获取数组中的元素索引 (下标) ：用来访问数组元素的序号（数组下标从0 开始）。 var arr = ['kobe', '22',33,'GuardCode'] 索引号： 0 1 2 3 注意：如果访问时数组没有和索引值对应的元素，则得到的值是undefined。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>数组的使用&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> // 利用new 创建数组 var arr = new Array(); // 创建了一个空的数组 // 利用数组字面量创建数组 [] var arr = []; // 创建了一个空的数组 var arr1 = [1, 2, 'pink', true]; // 获取数组元素 格式 数组名[索引号] 索引号从 0开始 console.log(arr1); console.log(arr1[2]); // pink console.log(arr1[3]); // true // 定义一个新数组 var arr2 = ['11', '吉安特', 'string']; console.log(arr2[0]); console.log(arr2[1]); console.log(arr2[2]); console.log(arr2[3]); // 因为没有这个数组元素 所以输出的结果是 undefined &lt;/script> &lt;/body> &lt;/html> 遍历数组数组遍历：把数组中的每个元素从头到尾都访问一次，可以通过 for 循环索引遍历数组中的每一项。 数组长度: 默认情况下表示数组中元素的个数,使用“数组名.length”可以访问数组元素的数量（数组长度）。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>数组遍历&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> // 遍历数组：就是把数组的元素从头到尾访问一次 var arr = ['red', 'green', 'blue']; for (var i = 0; i &lt; arr.length; i++) { console.log(arr[i]); } // 输出数组的长度 console.log(arr.length); &lt;/script> &lt;/body> &lt;/html> 数组的平均值代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>计算平均值&lt;/title> &lt;/head> &lt;body> &lt;script> // 定义数组 var arr = [2, 6, 1, 7, 4]; // 声明一个求和变量 sum。 var sum = 0; // 声明一个平均值变量averge var average = 0; for (var i = 0; i &lt; arr.length; i++) { // 遍历这个数组，把里面每个数组元素加到 sum 里面。 sum += arr[i]; } // 用求和变量 sum 除以数组的长度就可以得到数组的平均值。 average = sum / arr.length; console.log(sum, average); &lt;/script> &lt;/body> &lt;/html> 数组中新增元素数组中可以通过以下方式在数组的末尾插入新元素： 数组[ 数组.length ] = 新数据; 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>新增数组元素&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> // 1. 新增数组元素 修改length长度 var arr = ['red', 'green', 'blue']; console.log(arr.length); arr.length = 5; // 把我们数组的长度修改为了5里面应该有5个元素 console.log(arr); console.log(arr[3]); // undefined console.log(arr[4]); // undefined // 2. 新增数组元素 修改索引号 追加数组元素 var arr1 = ['red', 'green', 'blue']; arr1[3] = 'pink'; console.log(arr1); arr1[4] = 'hotpink'; console.log(arr1); arr1[0] = 'yellow'; // 这里是替换原来的数组元素 console.log(arr1); arr1 = '有点意思'; console.log(arr1); // 不要直接给 数组名赋值 否则里面的数组元素都没有了 &lt;/script> &lt;/body> &lt;/html> 筛选数组&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>筛选数组&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> /* 将数组 [2, 0, 6, 1, 77, 0, 52, 0, 25, 7] 中大于等于 10 的元素选出来，放入新数组。 声明一个新的数组用于存放新数据newArr。遍历原来的旧数组， 找出大于等于 10 的元素。依次追加给新数组 newArr。 */ // 方法1 var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]; var newArr = []; var j = 0; for (var i = 0; i &lt; arr.length; i++) { if (arr[i] >= 10) { // 新数组索引号应该从0开始 依次递增 newArr[j] = arr[i]; j++; } } console.log(newArr); // 方法2 var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]; var newArr = []; // 刚开始 newArr.length 就是 0 for (var i = 0; i &lt; arr.length; i++) { if (arr[i] >= 10) { // 新数组索引号应该从0开始 依次递增 newArr[newArr.length] = arr[i]; } } console.log(newArr); &lt;/script> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}]},{"title":"JavaScript之其他属性","slug":"前端/JavaScript/JavaScript之其他属性","date":"2020-02-23T03:17:38.000Z","updated":"2020-02-26T12:37:47.354Z","comments":true,"path":"2020/02/23/qian-duan/javascript/javascript-zhi-qi-ta-shu-xing/","link":"","permalink":"http://yoursite.com/2020/02/23/qian-duan/javascript/javascript-zhi-qi-ta-shu-xing/","excerpt":"","text":"offsetLeftoffsetTop/left返回当前元素距离父级元素的偏移的像素值。 代码示例&lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>&lt;/title> &lt;style type=\"text/css\"> *{margin: 0;padding: 0;} #div1{width: 400px;height: 400px;background: #ccc;position: absolute;left: 150px;top: 180px;margin: 30px;} #div2{width: 100px;height: 100px;margin: 90px;position: absolute;left: 20px;top: 30px;background: red;} &lt;/style> &lt;/head> &lt;body> &lt;div id='div1'> &lt;div id='div2'>&lt;/div> &lt;/div> &lt;script type=\"text/javascript\"> console.log(div2.offsetLeft,div2.offsetTop) &lt;/script> &lt;/body> &lt;/html> offsetWidth返回当前元素的宽度 / 高度(包含边框的填充,但是没有边框)。 代码示例&lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>&lt;/title> &lt;style type=\"text/css\"> *{margin: 0;padding: 0;} #div1{width: 100px;height: 100px;background: #ccc;padding-left: 20px;margin-left: 30px;border:30px solid red; position: relative; } #div2{width: 500px;background:green;height: 10px;position: absolute;left: 0} &lt;/style> &lt;/head> &lt;body> &lt;div id='div1'>21u3iou123oiu1oi &lt;div id='div2'>&lt;/div> &lt;/div> &lt;script type=\"text/javascript\"> console.log(div1.offsetWidth); &lt;/script> &lt;/body> &lt;/html> 元素拖拽代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>元素拖拽&lt;/title> &lt;style type=\"text/css\"> *{margin: 0;padding: 0;list-style: none;} #div1{width: 100px;height: 100px;background: red;position: absolute;left: 0;top: 0;} &lt;/style> &lt;/head> &lt;body> &lt;div id='div1'>&lt;/div> &lt;script > div1.onmousedown = function(){ var l = event.clientX - div1.offsetLeft; var t = event.clientY - div1.offsetTop; document.onmousemove = function(){ //event.clientX,event.clientY; // 左边的距离 var needX = event.clientX - l; // 底部的距离 var needY = event.clientY - t; if(needX&lt;0)needX = 0; if(needY&lt;0)needY = 0; // 屏幕的高度 if(needY>innerHeight - div1.offsetHeight)needY = innerHeight - div1.offsetHeight; if(needX>innerWidth - div1.offsetWidth)needX = innerWidth - div1.offsetWidth; div1.style.left = needX + 'px'; div1.style.top = needY + 'px'; }; document.onmouseup = function(){ // 清空 document.onmousemove = null; document.onmouseup = null; }; return false; } &lt;/script> &lt;/body> &lt;/body> &lt;/html> 递归函数定义:自己调用自己 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>递归函数&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> function fn1(num){ if(num==1){ return 1; }else{ return num+fn1(num-1); } } document.write(fn1(5)); document.write(\" \"); function fn(num){ if(num==1){ return 1; }else{ return num*fn(num-1); } } document.write(fn(6)); &lt;/script> &lt;/body> &lt;/html> 闭包子函数使用父函数变量的行为叫做闭包，子函数可以延长父函数变量的生命周期，可以拓展父函数的空间。 注意在js中函数内部的局部变量只允许其子函数使用。 父函数没法使用子函数的局部变量。 子函数可以使用父函数的局部变量。 缺点： 变量会驻留在内存中，导致存储变量不会立刻销毁。 &lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>闭包&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> function show(){ var a = 10; function show2(){ alert(a); } show2(); }; show(); &lt;/script> &lt;/body> &lt;/html> 阻止事件冒泡父级的事件子级都继承，取消冒泡防止父级的事件贯穿到子级。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>阻止事件冒泡&lt;/title> &lt;style type=\"text/css\"> #div1{ width: 100px; height: 100px; background: black; position: absolute;left: 30px;top: 50px; } #div2{ width: 100px; height: 100%;background: green;position: absolute;left: 200px;top: 200px; } &lt;/style> &lt;/head> &lt;body> &lt;div id=\"div1\"> &lt;div id=\"div2\">&lt;/div> &lt;/div> &lt;/body> &lt;script type=\"text/javascript\"> div1.onclick = function (e) { alert(1) } div2.onclick = function (e) { // 定义变量,兼容IE浏览器和chrome. var ev = e || event; // 方法一：阻止事件冒泡 ev.cancelBubble = true; // 方法二:阻止事件冒泡,但是他是高级浏览器ie8+才会支持移动端 ev.stopPropagation(); } &lt;/script> &lt;/html> JS运动框架原理: 就是让 web上DOM元素动起来。说白了就是让元素的style发生改变。重要的前提是，运动的物体必须是绝对定位。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>运动框架&lt;/title> &lt;style type=\"text/css\"> *{margin: 0;padding: 0;list-style: none;} #div1{width: 100px;height: 100px; background: red;position: absolute;left: 0;top: 0; } &lt;/style> &lt;/head> &lt;body> &lt;div id=\"div1\">&lt;/div> &lt;script type=\"text/javascript\"> // 定义变量 var w = 100; var t = null; function move() { if(w == 199){ // 关闭定时器 clearInterval(t); } w++; div1.style.width = w + \"px\"; } move(); // 开启定时器 t = setInterval(move,3); &lt;/script> &lt;/body> &lt;/html> 事件委托就是父级把事件给子级了。应该注意srcElement 属性火狐不支持，target属性IE浏览器不支持。 this特性Bom操作 实例化之前 this 就指向实例化对象。没实例化之前 this 永远就指向window。 Dom操作this 永远指向 发生事件源。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>事件委托&lt;/title> &lt;style type=\"text/css\"> *{margin: 0; padding: 0} #a{ width: 100px; height: 100px; background: red; } #b{ width: 100px;height: 100px;background: black; } &lt;/style> &lt;/head> &lt;body> &lt;div id='a'>&lt;/div> &lt;/body> &lt;script type=\"text/javascript\"> function a (){ alert(this); } // a(); // 实例化之前 new a(); // 实例化之后 // 获得点击事件 document.onclick = function (e) { // 兼容 var ev = e || event; var iTarget = ev.srcElement || ev.target; // 条件判断 if(iTarget.id == 'a'){ // alert(this); } } &lt;/script> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}]},{"title":"JavaScript之数据类型","slug":"前端/JavaScript/JavaScript之数据类型","date":"2020-01-03T02:17:32.000Z","updated":"2020-02-20T13:59:19.601Z","comments":true,"path":"2020/01/03/qian-duan/javascript/javascript-zhi-shu-ju-lei-xing/","link":"","permalink":"http://yoursite.com/2020/01/03/qian-duan/javascript/javascript-zhi-shu-ju-lei-xing/","excerpt":"","text":"JavaScript语言组成 组成部分 作用 DOM Document Object Model 文档对象模型，用于操作网页中各种元素和标签 BOM Browser Object Model 浏览器对象模型，用于操作浏览器中各种对象。如：window ECMA Script 脚本语言规则，制定JS脚本的核心基础 联系html 超文本标记语言 css 层叠样式表 js 脚本语言 结构表现和行为 html 结构层 css 表现层 js 行为层 script标签的说明&lt;script type=\"text/javascript\" src=\"引入外部的JS文件\">&lt;/script> 标签个数：每个网页可以导入多个外部脚本，而且都会依次。 位置：在网页的任何位置都可以执行，甚至在HTML标签的外面。 语句后分号不是必须的，建议加上。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>第一个JS代码&lt;/title> &lt;/head> &lt;body> &lt;!-- 输出5个Hello World 所有的JS代码写在script标签中 --> &lt;script type=\"text/javascript\"> for (var i = 0; i &lt; 5; i++) { //在文档上写 document.write(\"&lt;h2>Hello World&lt;/h2>\"); } &lt;/script> &lt;/body> &lt;/html> 输出语句alert 、document.write 、console.log的区别。 alert() == 系统弹出框 document.write() == 文档输入内容 console.log() === 控制台中的console显示内容 JavaScript与Java的区别 特点 Java JavaScript 面向对象 面向对象 基于对象，不完全面向对象。面向对象的某些特性是没有的 运行方式 编译型语言，生成字节码文件 解释型语言，不会生成中间文件。运行一部分解析一部分。 跨平台 通过虚拟机运行在不同的操作系统上 运行在浏览器，只要系统有浏览器就可以运行 数据类型 强类型，不同数据类型严格区分如：String str = 123; //错 弱类型，不同数据类型之间可以赋值 大小写 区分大小写 区分大小写 JavaScript的注释// 单行注释 /* 多行注释*/ 标识符1.标识符：变量、函数、属性的名字，或者函数的参数。 2.标识符的命名规则： 由字母、数字、下划线（_）或美元符号（$）组 成。 不能以数字开头 不能使用关键字、保留字等作为标识符。 变量的定义 数据类型 Java中定义变量 JS中定义变量 整数 int i = 5; var 浮点数 float f = 3.14; 或 double d=3.14; var 布尔 boolean b = true; var 字符 char c = ‘a’; var 字符串 String str = “abc”; var 注意事项 关于弱类型？ 同一个变量可以赋值为不同的数据类型。 在JS中的字符和字符串引号？ 在JS中没有字符和字符串区分，只有字符串，字符串既可以使用单引号，也可以使用双引号。 var定义变量的特点 var不是必须的，但建议加上。 在JS同一个变量可以定义多次。 方法外面的大括号不能限制变量的作用范围。 代码示例 变量定义 //定义变量 i=8; document.write(\"整数：\" + i + \"\"); var f=3.14; document.write(\"浮点数：\" + f + \"\"); var b=true; document.write(\"布尔：\" + b + \"\"); //在JS中没有字符和字符串区分，只有字符串，字符串既可以使用单引号，也可以使用双引号。 var str =\"abc\"; document.write(\"字符串：\" + str + \"\"); { var str = 'xyz123'; } document.write(\"字符串：\" + str + \"\"); //弱类型 b = 100; document.write(\"整数类型：\" + b + \"\"); 五种数据类型 关键字 说明 number 数值型，包含：整数和浮点数 boolean 布尔型，包含：true或false string 字符串类型，包含字符和字符串 object 对象类型，包含自定义的对象，系统内置对象 undefined 未定义的数据类型，没有初始化的变量。 typeof操作符作用：判断一个变量的数据类型，系统自带函数 作用 判断一个变量的数据类型，系统自带函数 语法 typeof 变量名或者typeof(变量名) 返回值 string类型，有可能是:string、number、boolean、object、undefined、function 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>变量定义&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> //定义变量 var i=8; document.write(\"整数：\" + i + \"&lt;br/>\"); document.write(\"类型：\" + typeof(i) + \"&lt;hr/>\"); var f=3.14; document.write(\"浮点数：\" + f + \"&lt;br/>\"); document.write(\"类型：\" + typeof(f) + \"&lt;hr/>\"); var b=true; document.write(\"布尔：\" + b + \"&lt;br/>\"); document.write(\"类型：\" + typeof(b) + \"&lt;hr/>\"); var str =\"abc\"; document.write(\"字符串：\" + str + \"&lt;br/>\"); document.write(\"类型：\" + typeof(str) + \"&lt;hr/>\"); document.write(\"类型：\" + typeof('a') + \"&lt;hr/>\"); var obj = new Date(); //内置的日期对象 document.write(obj + \"&lt;br/>\"); document.write(\"类型：\" + typeof(obj) + \"&lt;hr/>\"); var u; //不知道什么类型 document.write(\"类型：\" + typeof(u) + \"&lt;hr/>\"); var n = null; //是一个对象类型，但对象没有值。 document.write(\"类型：\" + typeof(n) + \"&lt;hr/>\"); &lt;/script> &lt;/body> &lt;/html> 未定义的数据类型null与undefined的区别 null与undefined的区别 说明 null 对象类型，但是对象没有值 undefined 未定义的类型，不知道的类型 数值型数据类型Number：表示整数和浮点数。NaN：即非数值（Not a Number）是一个特殊的数值。 注意： 任何涉及NaN的操作（例如NaN/10）都会返回NaN。 NaN与任何值都不相等，包括NaN本身。 isNaN()语法:isNaN(n) 功能：检测n是否是“非数值” 返回值：boolean。 参数：参数n可以是任何类型 注意:isNaN()在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> var name_01=\"kobe\",age=18,email=\"hxy1625309592@aliyun.com\"; var distance=12.67; var id=\"16\"; // 在控制台中打印 console.log(typeof(distance)) console.log(typeof(age-\"abc\")); console.log(isNaN(email)); console.log(isNaN(id)); id=Number(id); name_01=Number(name_01); console.log(typeof id); // NaN console.log(name_01); &lt;/script> &lt;/body> &lt;/html> parseInt()parseInt() ：会忽略字符串前面的空格，直至找到第一个非空格字符。 注意： parseInt()：转换空字符串返回NaN。 parseInt()这个函数提供第二个参数：转换时使用的基数（即多少进制） parseFloat()parseFloat：从第一个字符开始解析每个字符，直至遇见一个无效的浮点数字符为止。 注意 除了第一个小数点有效外，parseFloat()与parseInt()的第二个区别在于它始终都会忽略前导的零。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> var topval=parseInt(\"28px\"); var c=\"abc58\" // 28 console.log(topval); // NAN console.log(parseInt(c)); // 15 console.log(parseInt(\"0xf\",16)); var d=parseFloat(\"12.34.56px\"); // 12.34 console.log(d); var e=parseFloat(\"0.123abc\"); // 0.123 console.log(e); &lt;/script> &lt;/body> &lt;/html> String数据类型String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（“ ”）或单引号（’ ‘）表示。 转换方法语法：str.toString()功能：将str转换为字符串返回值：str的一个副本参数：str是要转换的内容，可以是数值、布尔值、对象和字符串。 注意在不知道要转换的值是不是null或undefined的。情况下，还可以使用String()函数，它能够将任何类型的值转换为字符串。 Boolean数据类型 用于表示真假的类型，即true表示真，false表示假。 类型转换 除0之外的所有数字，转换为布尔型都为true。 除””之外的所有字符，转换为布尔型都为true。 null和undefined转换为布尔型为false 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> var ids=78965; var idstr=ids.toString(); console.log(typeof idstr); var m; console.log(String(m)); var isChild=false; console.log(isChild.toString()); var x=0; console.log(Boolean(x)); var strings=\" \"; console.log(Boolean(strings)); var y; console.log(Boolean(y)); var timer=null; console.log(Boolean(timer)); &lt;/script> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}]},{"title":"JavaScript之内置对象02","slug":"前端/JavaScript/JavaScript之内置对象02","date":"2020-01-03T02:17:11.000Z","updated":"2020-01-03T06:28:47.694Z","comments":true,"path":"2020/01/03/qian-duan/javascript/javascript-zhi-nei-zhi-dui-xiang-02/","link":"","permalink":"http://yoursite.com/2020/01/03/qian-duan/javascript/javascript-zhi-nei-zhi-dui-xiang-02/","excerpt":"","text":"内置对象：StringcharAt()与charCodeAt()区别 方法名 语法 功能 charCodeAt() stringObject.charCodeAt(index) 返回stringObject中index位置字符的字符编码。 charAt() stringObject.charAt(index) 返回stringObject中index位置的字符。 注意ECMAScript5中可使用“方括号加字符索引”来访问字符串中特定的字符，但是IE7及更早的浏览器会返回undefined。 indexOf()与lastIndexOf()区别 方法名 indexOf() lastIndexOf() 语法 stringObject.indexOf (“o”) stringObject.lastIndexOf (“o”) 功能 从一个字符串中搜索给定的子字符串，返回子字符串的位置。 从一个字符串中搜索给定的子字符串，返回子字符串的位置。 返回值 数值 数值 注意 如果没有找到该子字符串，则返回-1。 如果没有找到该子字符串，则返回-1。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;script> // 声明一个字符串 var str1=\"hello world\"; // 获取index位置字符的字符编码 console.log(str1.charCodeAt(4)); // 获取index位置的字符 console.log(str1.charAt(4)); // 声明一个邮箱字符串 var email=\"hxy1625309592@aliyun.com\"; // 检测@在email中出现的位置 console.log(email.indexOf(\"o\")); console.log(email.lastIndexOf(\".\")); &lt;/script> &lt;/body> &lt;/html> 字符串截取方法 方法 slice() substring() substr () 语法 stringValue.slice(start,end) stringValue.substring(start,end) stringValue.substr(start,len) 功能 截取子字符串 截取子字符串 截取子字符串。 注意 1、start：必需，指定子字符串的开始位置。2、end：可选，表示子字符串到哪里结束，end本身不在截取范围之内，省略时截取至字符串的末尾。 3、最后一个参数省略时候，截取到末尾4、参数为负数时，其值为字符串长度 + 该负数。 1、当参数为负数时，自动将参数转换为0。2、substring()会将较小的数作为开始位置，将较大的数作为结束位置。 1、start：必需，指定子字符串的开始位置。2、len：可选，表示截取的字符总数，省略时截取至字符串的末尾。3、当start为负数时，会将传入的负值与字符串的长度相加。4、当len为负数时，返回空字符串。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;script> // 声明一个字符串 var str=\"hello world\"; // 截取orl console.log(str.slice(7,10)); console.log(str.slice(1)); // str.slice(4,9) console.log(str.slice(-7,-2)); console.log(\"-------\"); console.log(str.substring(-7,5)); //(0,5) // str.substring(6,9) console.log(str.substring(2,-5)); //(0,2) console.log(str.substr(6,3)); // (6,4) console.log(str.substr(-5,4)); console.log(str.substr(3,-4)); &lt;/script> &lt;/body> &lt;/html> 字符串对象方法 方法 split() replace() 语法 stringObject.split(separator) stringObject.replace(regexp/substr,replacement) 功能 把一个字符串分割成字符串数组。 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 返回值 Array String 参数 separator：必需，分隔符。 regexp：必需。规定子字符串或要替换的模式的 RegExp 对象。replacement:：必需。一个字符串值。 代码示例&lt;!doctype html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;script> var str='welcome-to-beijing'; //使用split将str转换为数组 var arr=str.split(\"-\"); var date='2016/05/05'; //[\"welcome\",\"to\",\"beijing\"] var dateArr=date.split(\"/\"); console.log(dateArr); console.log(arr); //替换replace() var tel='010-62971268,400-100-9098,010-86789889'; //newTel被替换之后的字符串 var newTel=tel.replace(',',\" \"); console.log(newTel); &lt;/script> &lt;/body> &lt;/html> 其他方法toUpperCase()语法stringValue.toUpperCase() 功能 把字符串转换为大写。 toLowerCase()语法stringValue.toLowerCase() 功能 把字符串转换为小写。 代码示例&lt;!doctype html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;script> function camelback(str){ //通过-分隔符将str拆分成数组 var arr=str.split(\"-\"),newStr=arr[0]; for(var i=1,len=arr.length;i&lt;len;i++){ var word=arr[i]; //将每一个单词的首字母转换为大写 newStr+=word.charAt(0).toUpperCase()+word.substr(1); // console.log(newStr) } return newStr; } var camelFormat=camelback(\"border-left-color\"); console.log(camelFormat) &lt;/script> &lt;/body> &lt;/html> 内置对象：MathMath对象基本方法 方法 语法 功能 返回值 Math.min() Math.min(num1,num2…numN) 求一组数中的最小值。 Number Math.max() Math.max(num1,num2…numN) 求一组数中的最大值。 Number Math.ceil() Math.ceil(num) 向上取整，即返回大于num的最小整数。 Number Math.floor() Math.floor(num) 向下取整，返回num的整数部分。 Number Math.round() Math.round (num) 将数值四舍五入为最接近的整数。 Number Math.abs() Math.abs (num) 返回num的绝对值。 Number 代码示例&lt;!doctype html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;script> var min=Math.min(5,-4,0,9,108,-55); var max=Math.max(88,0,6,47,199); console.log(min); console.log(max); var num=189.69; var int1=Math.ceil(num); // 190 var int2=Math.floor(num); // 189 var int3=Math.round(num); // 189 var nums=-55; console.log(int3); console.log(Math.abs(nums)); &lt;/script> &lt;/body> &lt;/html> random方法语法Math.random() 功能返回大于等于0小于1的一个随机数。 返回值Number 代码示例&lt;!doctype html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;script> var random=Math.random(); console.log(random); // 生成一个n到m之间的随机整数 function getRandom(n,m){ var choise=m-n+1; // 随机整数的个数 return Math.floor(Math.random()*choise+n); } var random1=getRandom(2,6); var random2=getRandom(10,88); &lt;/script> &lt;/body> &lt;/html> 内置对象:date创建日期对象功能创建一个日期时间对象 返回值不传参的情况下，返回当前的日期时间对象。 注意：如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数或者是一组用逗号隔开的表示年月日时分秒的参数。 获取日期对象的方法1、getFullYear()：返回4位数的年份 2、getMonth()：返回日期中的月份，返回值为0-11 3、getDate()：返回月份中的天数 4、getDay()：返回星期，返回值为0-6 5、getHours()：返回小时 6、getMinutes()：返回分 7、getSeconds()：返回秒 8、getTime()：返回表示日期的毫秒数 代码示例&lt;!doctype html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;script> // 创建一个日期时间对象 var weeks=[\"日\",\"一\",\"二\",\"三\",\"四\",\"五\",\"六\"], today=new Date(), year=today.getFullYear(), month=today.getMonth()+1, date=today.getDate(), week=today.getDay(), hours=today.getHours(), minutes=today.getMinutes(), seconds=today.getSeconds(), times=today.getTime(), time=year+'年'+month+'月'+date+'日'+hours+'时'+minutes+'分'+seconds+'秒 星期'+weeks[week]; console.log(\"现在是：\"+time); console.log(times); &lt;/script> &lt;/body> &lt;/html> 设置日期对象的方法代码示例&lt;!doctype html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;script> // 创建一个日期时间对象 var today=new Date(); today.setFullYear(2019); today.setMonth(15); console.log(today.getFullYear()); // 50天之后是星期 // 第一种做法 //today.setDate(today.getDate()+50); //console.log(today.getDay()); // 第二种做法 var weeks=[\"日\",\"一\",\"二\",\"三\",\"四\",\"五\",\"六\"]; var year=today.getFullYear(); var month=today.getMonth(); var day=today.getDate(); // 创建了一个目标日期对象,年,月,日,时,分,秒 var temp=new Date(year+1,month,day); console.log(\"50天后的今天是：\"+temp.getFullYear()+'-'+(temp.getMonth()+1)+'-'+temp.getDate()+'-'+'星期'+weeks[temp.getDay()]); &lt;/script> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}]},{"title":"JavaScript之内置对象01","slug":"前端/JavaScript/JavaScript之内置对象01","date":"2020-01-03T02:16:51.000Z","updated":"2020-05-12T13:06:01.325Z","comments":true,"path":"2020/01/03/qian-duan/javascript/javascript-zhi-nei-zhi-dui-xiang-01/","link":"","permalink":"http://yoursite.com/2020/01/03/qian-duan/javascript/javascript-zhi-nei-zhi-dui-xiang-01/","excerpt":"","text":"内置对象：数组对象创建数组的四种方式数组在JS中是一个内置对象 创建数组的方式 说明 new Array() 创建长度为0的数组 new Array(n) 创建一个指定长度的数组，长度为n new Array(元素1,元素2,元素3) 指定数组中每个元素创建一个数组 [元素1,元素2,元素3] 指定数组中每个元素创建一个数组 数组的特点 创建数组，元素的类型可以不同。 数组的长度可以动态变化的。 数组中还包含了方法。 数组元素的读写 读取和设置值时，使用方括号[ ]并提供相应的索引。 索引是从0开始的正整数 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;script> // 创建一个保存颜色的数组 var colors=new Array(3); colors[0]=\"#f00\"; colors[1]=\"#0f0\"; colors[2]=\"#00f\"; console.log(colors); // 创建第二个数组 var nums=new Array(1,3,6,9); console.log(nums); var cols=[\"red\",\"yellow\",\"green\"]; console.log(cols); // 读取cols这个数组中索引为1的值*/ console.log(cols[1]); var infos=[6,\"marry\",true]; console.log(infos); &lt;/script> &lt;/body> &lt;/html> 数组长度语法：array.length功能：获取数组array的长度返回值：number 注意 通过设置length可以从数组的末尾移除项或向数组中添加新项。 当把一个值放在超出当前数组大小的位置上时，数组就会重新计算其长度值，长度值等于最后一项的索引加1。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>遍历数组&lt;/title> &lt;/head> &lt;body> &lt;script> // 创建数组 var arr=[\"a\",\"b\",\"c\",\"d\"]; // 输出数组的长度 console.log(arr.length); // 4 arr[99]=\"z\"; console.log(arr.length); // 100 // 数组的遍历 for(var i=0;i&lt;arr.length;i++){ console.log(arr[i]); } &lt;/script> &lt;/body> &lt;/html> 数组的栈方法push()语法：arrayObject.push(newele1,newele2,....,neweX) 功能： 把它的参数顺序添加到 arrayObject 的尾部。 返回值： 把指定的值添加到数组后的新长度。 unshift()语法：arrayObject.unshift(newele1,newele2,....,neweX) 功能： 把它的参数顺序添加到 arrayObject 的开头。 返回值： 把指定的值添加到数组后的新长度。 pop()语法：arrayObject.pop() 功能： 删除 arrayObject 的最后一个元素 返回值： 被删除的那个元素 shift()语法：arrayObject.shift() 功能： 删除 arrayObject中的第一个元素 返回值： 被删除的那个元素 代码示例&lt;!doctype html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;script> // push var colors=new Array(\"red\",\"green\"); var len=colors.push(\"blue\",\"yellow\",\"blank\"); console.log(len); // unshift var nums=[2,7,8,6]; var size=nums.unshift(99,66); // pop var n=nums.pop(); console.log(nums); // unshift var m=colors.shift(); console.log(m); &lt;/script> &lt;/body> &lt;/html> 数组的转换方法join()语法：arrayObject.join(separator) 功能： 用于把数组中的所有元素放入一个字符串。 返回值： 字符串。 reverse()语法：arrayObject.reverse() 功能： 用于颠倒数组中元素的顺序。 返回值：数组。 数组的重排序方法sort()语法：arrayObject.sort(sortby) 功能： 用于对数组的元素进行排序。 返回值： 数组。 说明：1、即使数组中的每一项都是数值，sort()方法比较的也是字符串。2、sort()方法可以接收一个比较函数作为参数。 代码示例&lt;!doctype html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;script> // join var nums=[2,4,5]; var str=nums.join(); //2,4,5 var words=[\"border\",\"left\",\"color\"]; // border-left-color var wordstr=words.join(\"-\"); console.log(wordstr); // reverse nums.reverse(); console.log(nums); var strs=[\"a\",\"b\",\"c\",\"d\"]; // 返回dcba这个字符串 var newstr=strs.reverse().join(\"\") console.log(newstr); // 29,5,24,17,32 var arr=[9,23,15,-99,88,12,-2]; // 降序 return 参数1&lt;参数2 //arr.sort(function(a,b){return a&lt;b}); // 升序 return 参数1>参数2 arr.sort(function(a,b){return a>b}); console.log(arr); &lt;/script> &lt;/body> &lt;/html> 数组的操作方法concat()语法：arrayObject.concat(arrayX,arrayX,......,arrayX) 功能： 用于连接两个或多个数组。 返回值： 数组。 slice()语法：arrayObject.slice(start,end) 功能： 从已有的数组中返回选定的元素。 参数： start （必需）规定从何处开始选取，如果是负数，那么它规定从数组尾部开始算起的位置。 end（可选）规定从何处结束选取，该参数是数组片断结束处的数组下标。 返回值： 数组 注意： 如果没有指定end，那么切分的数组包含从 start 到数组结束的所有元素。 如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;script> var arr1=[\"a\",\"b\",\"c\"], arr2=[\"d\",\"e\",1,3], arr3; // concat arr3=arr1.concat(arr2,[\"m\",99,8]); console.log(arr3); // slice(start,end) end下标 var colors=[\"red\",\"green\",\"blue\",\"yellow\",\"orange\"]; // 1,3 var newColors3=colors.slice(-4,3); console.log(newColors3); // 完成以下代码段，实现b数组对a数组的拷贝，方法越多越好 var a=[1,\"yes\",3]; var b; // 1、数组遍历,push b=new Array(); for(var i=0;i&lt;a.length;i++){ b.push(a[i]); } console.log(b); // 2、concat() b=[].concat(a); console.log(b); // 3、slice(); b=a.slice(0); console.log(b); &lt;/script> &lt;/body> &lt;/html> splice()删除语法：arrayObject.splice(index,count) 功能： 删除从 index 处开始的零个或多个元素。 返回值：含有被删除的元素的数组。 注意count是要删除的项目数量，如果设置为 0，则不会删除项目。如果不设置，则删除从index开始的所有值。 插入语法：arrayObject.splice(index,0,item1,.....,itemX) 功能： 在指定位置插入值 参数：Index：起始位置 0：要删除的项数 item1…itemX：要插入的项 返回值： 数组 替换语法：arrayObject.splice(index,count,item1,.....,itemX) 功能：在指定位置插入值，且同时删除任意数量的项 参数：Index：起始位置 count：要删除的项数 item1…itemX：要插入的项 返回值： 从原始数组中删除的项（如果没有删除任何项，则返回空数组） 代码示例&lt;!doctype html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;script> var arr=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]; // 删除 //var delArr=arr.splice(2,3); // 插入 //var insertArr=arr.splice(3,0,\"m\",\"n\",88); // 替换 var replaceArr=arr.splice(1,2,\"x\",\"y\",\"z\"); console.log(arr); console.log(replaceArr); &lt;/script> &lt;/body> &lt;/html> indexOf()语法：arrayObject.indexOf(searchvalue，startIndex) 功能： 从数组的开头（位置0）开始向后查找。 参数：searchvalue：必需，要查找的项；startIndex：可选，起点位置的索引。 返回值： number，查找的项在数组中的位置，没有找到的情况下返回-1。 lastIndexOf()语法：arrayObject.lastIndexOf(searchvalue，startIndex) 功能： 从数组的末尾开始向前查找。 参数：searchvalue：必需，要查找的项； startIndex：可选，起点位置的索引。 返回值： number，查找的项在数组中的位置，没有找到的情况下返回-1。 代码示例&lt;!doctype html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;script> var nums=[1,7,5,7,8,1,6,9]; //var pos=nums.indexOf(7,2); //var pos=nums.lastIndexOf(1); var pos=nums.indexOf(\"7\"); console.log(pos); // 封装一个方法实现indexOf的功能 function ArrayIndexOf(arr,value){ // 检测value在arr中出现的位置 for(var i=0;i&lt;arr.length;i++){ if(arr[i]===value){ return i; } } return -1; } var pos2=ArrayIndexOf(nums,\"1\"); console.log(pos2); &lt;/script> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}]},{"title":"JavaScript之函数","slug":"前端/JavaScript/JavaScript之函数","date":"2020-01-03T02:16:25.000Z","updated":"2020-02-29T08:01:02.482Z","comments":true,"path":"2020/01/03/qian-duan/javascript/javascript-zhi-han-shu/","link":"","permalink":"http://yoursite.com/2020/01/03/qian-duan/javascript/javascript-zhi-han-shu/","excerpt":"","text":"函数的概念函数：就是封装了一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;script> // 1. 求 1~100的累加和 var sum = 0; for (var i = 1; i &lt;= 100; i++) { sum += i; } console.log(sum); // 2. 求 10~50的累加和 var sum = 0; for (var i = 10; i &lt;= 50; i++) { sum += i; } console.log(sum); // 3. 函数就是封装了一段可以被重复执行调用的代码块 目的： 就是让大量代码重复使用 function getSum(num1, num2) { var sum = 0; for (var i = num1; i &lt;= num2; i++) { sum += i; } console.log(sum); } getSum(1, 100); getSum(10, 50); &lt;/script> &lt;/body> &lt;/html> 函数的使用声明函数// 声明函数 function 函数名() { //函数体代码 } function 是声明函数的关键字,必须小写 调用函数// 调用函数 函数名(); // 通过调用函数名来执行函数体代码 注意： 调用的时候千万不要忘记添加小括号 函数不调用，自己不执行。声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>函数的使用&lt;/title> &lt;/head> &lt;body> &lt;script> // 函数使用分为两步： 声明函数 和 调用函数 // 1. 声明函数 function sayHi() { console.log('hi~~'); } // 2. 调用函数 sayHi(); &lt;/script> &lt;/body> &lt;/html> 函数的封装 函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>函数封装&lt;/title> &lt;/head> &lt;body> &lt;script> // 利用函数计算1-100之间的累加和 // 1. 声明函数 function getSum() { var sum = 0; for (var i = 1; i &lt;= 100; i++) { sum += i; } console.log(sum); } // 2. 调用函数 getSum(); &lt;/script> &lt;/body> &lt;/html> 函数的参数函数参数语法 形参：函数定义时设置接收调用时传入 实参：函数调用时传入小括号内的真实数据 参数 说明 形参 形式上的参数，函数定义的时候传递的参数，当前不知道是什么。 实参 实际上的参数，函数调用的时候传递的参数，实参是传递给形参的。 参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>函数参数&lt;/title> &lt;/head> &lt;body> &lt;script> // 1. 利用函数求任意两个数的和 function getSum(num1, num2) { console.log(num1 + num2); } getSum(1, 3); getSum(3, 8); // 2. 利用函数求任意两个数之间的和 function getSums(start, end) { var sum = 0; for (var i = start; i &lt;= end; i++) { sum += i; } console.log(sum); } getSums(1, 100); getSums(1, 10); // 3. 注意点 // (1) 多个参数之间用逗号隔开 // (2) 形参可以看做是不用声明的变量 &lt;/script> &lt;/body> &lt;/html> 函数形参和实参数量不匹配时 参数个数 说明 实参个数等于形参个数 输出正确的结果 实参个数大于形参个数 只能取到形参的个数 实参个数小于形参个数 多的形参定义为undefined，结果是NaN 总结： 函数可以带参数也可以不带参数 声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined 调用函数的时候，函数名括号里面的是实参 多个参数中间用逗号分隔。形参的个数可以和实参个数不匹配，但是结果不可预计，应该尽量要匹配。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>函数形参实参个数匹配&lt;/title> &lt;/head> &lt;body> &lt;script> // 函数形参实参个数匹配 function getSum(num1, num2) { console.log(num1 + num2); } // 1. 如果实参的个数和形参的个数一致 则正常输出结果 getSum(1, 2); // 2. 如果实参的个数多于形参的个数 会取到形参的个数 getSum(1, 2, 3); // 3. 如果实参的个数小于形参的个数 多于的形参定义为undefined 最终的结果就是 NaN // 形参可以看做是不用声明的变量 num2 是一个变量但是没有接受值 结果就是undefined getSum(1); // NaN &lt;/script> &lt;/body> &lt;/html> 函数的返回值return 语句返回值：函数调用整体代表的数据；函数执行完成后可以通过return语句将指定数据返回 。// 声明函数 function 函数名（）{ ... return 需要返回的值； } // 调用函数 函数名(); // 此时调用函数就可以得到函数体内return 后面的值 在使用 return 语句时，函数会停止执行，并返回指定的值 如果函数没有 return ，返回的值是 undefined break ,continue ,return 的区别 break ：结束当前的循环体（如 for、while） continue ：跳出本次循环，继续执行下次循环（如 for、while） return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>函数形参实参个数匹配&lt;/title> &lt;/head> &lt;body> &lt;script> // 利用函数求数组 [5,2,99,101,67,77] 中的最大数值。 function getArrMax(arr) { // 定义变量 var max = arr[0]; for (var i = 1; i &lt;= arr.length; i++) { if (arr[i] > max) { max = arr[i]; } } return max; } // 定义数组 var re = getArrMax([3, 77, 44, 99, 143]); console.log(re); &lt;/script> &lt;/body> &lt;/html> arguments使用arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点： 具有 length 属性，按索引方式储存数据。 不具有数组的 push , pop 等方法，在函数内部使用该对象，用此对象获取函数调用时传的实参。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>arguments使用&lt;/title> &lt;/head> &lt;body> &lt;script> // 利用函数求任意个数的最大值 function getMax() { // 定义最大值 var max = arguments[0]; for (var i = 1; i &lt; arguments.length; i++) { if (arguments[i] > max) { max = arguments[i]; } } return max; } // 输出结果 console.log(getMax(1, 2, 3)); console.log(getMax(1, 2, 3, 4, 5)); console.log(getMax(11, 2, 34, 444, 5, 100)); &lt;/script> &lt;/body> &lt;/html> 函数的两种声明方式命名函数利用函数关键字 function 自定义函数方式 function 函数名(参数) { 方法体; [return 返回值] } 注意：调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>命名函数&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> /*//定义函数 function hello() { alert(1); alert(2); } //函数不调用是不执行的 hello(); alert(3);*/ //定义一个函数：实现2个数的和 function sum(a, b) { //形参 var result = a + b; return result; } //调用函数：使用的是实参 var result = sum(3,5); document.write(\"计算结果是：\" + result + \"&lt;br/>\"); &lt;/script> &lt;/body> &lt;/html> 匿名函数//定义匿名函数 var 变量名 = function(形参) { return 返回值; } 注意： 因为函数没有名字，所以也被称为匿名函数。 函数表达式方式原理跟声明变量方式是一致的，函数调用的代码必须写到函数体后面。 函数函数以后主要用在事件处理函数中，通常不能重用。使用一次，如果需要重用我们建议使用命名函数。如果要使用匿名函数，也可以将函数赋值给一个变量。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>匿名函数使用&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> //将一个匿名的函数赋值为一个变量 var sum = function (a,b) { var result = a + b; return result; }; //通过变量名来调用函数 var result = sum(2,7); document.write(result + \"&lt;br/>\"); &lt;/script> &lt;/body> &lt;/html> 平均值示例&lt;!doctype html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>求平均值&lt;/title> &lt;/head> &lt;body> &lt;script> // 求任意一组数的平均值 function getAvg(){ // 多所有参数进行求和 var sum=0,len=arguments.length,i; for(i=0;i&lt;len;i++){ sum+=arguments[i]; } return sum/len; } var avg=getAvg(5,66,45,32,88,24,40,199,3900); console.log(avg); &lt;/script> &lt;/body> &lt;/html> 函数翻转数组&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>数组反转&lt;/title> &lt;/head> &lt;body> &lt;script> // 利用函数翻转任意数组 reverse 翻转 function reverse(arr) { // 创建一个空数组 var newArr = []; for (var i = arr.length - 1; i >= 0; i--) { newArr[newArr.length] = arr[i]; } return newArr; } // 定义arr1数组 var arr1 = reverse([1, 3, 4, 6, 9]); console.log(arr1); // 定义arr2数组 var arr2 = reverse(['red', 'pink', 'blue']); console.log(arr2); &lt;/script> &lt;/body> &lt;/html> 函数冒泡排序&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>数组排序&lt;/title> &lt;/head> &lt;body> &lt;script> // 利用函数冒泡排序 sort 排序 function sort(arr) { for (var i = 0; i &lt; arr.length - 1; i++) { for (var j = 0; j &lt; arr.length - i - 1; j++) { if (arr[j] > arr[j + 1]) { var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } return arr; } // 定义数组arr1 var arr1 = sort([1, 4, 2, 9]); console.log(arr1); // 定义数组arr2 var arr2 = sort([11, 7, 22, 999]); console.log(arr2); &lt;/script> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}]},{"title":"JavaScript之事件","slug":"前端/JavaScript/JavaScript之事件","date":"2020-01-01T06:21:23.000Z","updated":"2020-02-24T02:05:23.460Z","comments":true,"path":"2020/01/01/qian-duan/javascript/javascript-zhi-shi-jian/","link":"","permalink":"http://yoursite.com/2020/01/01/qian-duan/javascript/javascript-zhi-shi-jian/","excerpt":"","text":"事件的定义在网页中操作的时候，会激活各种事件，如：鼠标移动，点击按钮，双击，失去焦点等。我们可以通过JS代码来对这些事件编程，当激活这些事件的时候，实现相应的功能。可以让网页”活”起来，与用户有交互的功能。 设置事件的两种方式命名函数&lt;input type=\"button\" onclick=\"clickMe()\" id=\"btn\"> function clickMe() { //事件处理函数 } 匿名函数document.getElementById(\"btn\").onclick = function() { //事件处理函数 } 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>事件处理函数&lt;/title> &lt;/head> &lt;body> &lt;input type=\"button\" value=\"命名函数\" id=\"b1\" onclick=\"clickMe()\"> &lt;input type=\"button\" value=\"匿名函数\" id=\"b2\"> &lt;script type=\"text/javascript\"> //命名函数 function clickMe() { alert(\"命名函数\"); } //匿名函数要写在按钮元素的后面 document.getElementById(\"b2\").onclick = function () { alert(\"匿名函数\"); } &lt;/script> &lt;/body> &lt;/html> 总结 事件处理中命名函数的写法 onclick = \"函数名()\" 事件处理中匿名函数的写法 元素对象.onclick = function() 事件介绍Event(事件) 对象 Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 事件通常与函数结合使用，函数不会在事件发生前被执行！ 事件对象是和当前事件有关系。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Event对象事件&lt;/title> &lt;style type=\"text/css\"> body,html{height: 100%;} &lt;/style> &lt;/head> &lt;body> &lt;span id='span'>&lt;/span> &lt;script> onclick = function(event){ console.log(event) }; &lt;/script> &lt;/body> &lt;/html> 事件流 事件冒泡：从内到外 事件捕获：从外到内 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>事件冒泡和事件捕获&lt;/title> &lt;/head> &lt;body> &lt;div id=\"div1\" style=\"background: red; width: 400px; height: 400px\"> &lt;div id=\"div2\" style=\"background: blue;width: 200px;height: 200px\">&lt;/div> &lt;/div> &lt;script> // 获取div元素 var div1 = document.getElementById(\"div1\"); var div2 = document.getElementById(\"div2\"); // 事件捕获 div1.onclick = function(){ alert(1); } div2.onclick = function(){ alert(2); } &lt;/script> &lt;/body> &lt;/html> 加载完成事件 当整个文档加载成功，或者一个图片加载成功，会触发加载事件 。 代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>加载完成事件&lt;/title> &lt;style type=\"text/css\"> #myDiv{width: 100px;height: 100px;background: black;} &lt;/style> &lt;/head> &lt;body> &lt;div id='myDiv'>&lt;/div> &lt;/body> &lt;script> // 函数一开始是不执行的：整个浏览器窗口加载完毕以后才执行，相当于所有的元素都已经被读取了 window.onload = function(){ setTimeout(function(){ document.getElementById('myDiv').style.height = '200px'; },1000); }; &lt;/script> &lt;/html> 鼠标事件移入移出事件&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>鼠标移入和移出事件&lt;/title> &lt;style type=\"text/css\"> *{margin: 0;padding: 0;} #myDiv{width: 100px;height: 100px;background: black;color: white;} &lt;/style> &lt;/head> &lt;body> &lt;div id='myDiv'> 没有移入 &lt;/div> &lt;script> var myDiv = document.getElementById('myDiv'); // 鼠标移入 myDiv.onmouseover = function(){ myDiv.style.background = 'blue'; myDiv.innerHTML = '鼠标移入'; }; // 鼠标移出 myDiv.onmouseout = function(){ myDiv.style.background ='black'; myDiv.innerHTML = '没有移入'; }; &lt;/script> &lt;/body> &lt;/html> 经过事件 当在组件上鼠标经过的时候，会触发onmousemove事件 。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>鼠标经过事件&lt;/title> &lt;style type=\"text/css\"> body,html{height: 100%;} &lt;/style> &lt;/head> &lt;body> &lt;span id='span'>&lt;/span> &lt;script> var oS = document.getElementById('span'); onmousemove = function(event){ // 点击位置距离当前body可视区域的x，y坐标 oS.innerHTML = event.clientX + ',' + event.clientY; }; &lt;/script> &lt;/body> &lt;/html> 按下和抬起事件 当在组件上鼠标按下的时候，会触发onmousedown事件。 当在组件上鼠标弹起的时候，会触发onmouseup事件 。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>鼠标按下和抬起&lt;/title> &lt;style type=\"text/css\"> body,html{height: 100%;} &lt;/style> &lt;/head> &lt;body> &lt;div id='myDiv'>abcdefgwerty&lt;/div> &lt;input type=\"\" id='ipt' name=\"\"> &lt;script type=\"text/javascript\"> var myDiv = document.getElementById('myDiv'); var ipt = document.getElementById('ipt'); // 取消默认事件 myDiv.onmousedown = function(){ return false; }; // 取消右键 oncontextmenu = function(event){ //alert(1); console.log(event) return false; }; // 取消默认事件 ipt.onmousedown = function(){ return false; } /* // 鼠标按下事件 onmousedown = function(){ console.log('鼠标按下'); }; // 鼠标抬起事件 onmouseup = function(){ console.log('鼠标抬起'); }; */ &lt;/script> &lt;/body> &lt;/html> 点击事件 点击事件，由单击，双击按两个事件组成。 当在组件上单击的时候，会触发onclick事件，当在组件上双击的时候，会触发ondblclick事件 。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>单击和双击事件&lt;/title> &lt;/head> &lt;body> 姓名： &lt;input type=\"text\" id=\"t1\"> &lt;br/>&lt;br/> 姓名： &lt;input type=\"text\" id=\"t2\"> &lt;br/>&lt;br/> &lt;input type=\"button\" value=\"单击复制/双击清除\" id=\"btn\"> &lt;script type=\"text/javascript\"> //单击事件 document.getElementById(\"btn\").onclick = function () { document.getElementById(\"t2\").value = document.getElementById(\"t1\").value; } //双击事件 document.getElementById(\"btn\").ondblclick = function () { document.getElementById(\"t1\").value = \"\"; document.getElementById(\"t2\").value = \"\"; } &lt;/script> &lt;/body> &lt;/html> 事件冒泡语法：event.cancelBubble = true; 阻止事件冒泡 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>事件冒泡&lt;/title> &lt;style type=\"text/css\"> *{margin: 0;padding: 0;} #div1{width: 100px;height: 100px;background: red;position: absolute;} #div2{width: 100px;height: 100px;background: black;position: absolute;left: 300px;top: 300px;} &lt;/style> &lt;/head> &lt;body> &lt;div id='div1'> &lt;div id='div2'>&lt;/div> &lt;/div> &lt;script type=\"text/javascript\"> var div1 = document.getElementById('div1'), div2 = document.getElementById('div2'); div1.onclick = function(){ alert(1); }; // 阻止事件冒泡 div2.onclick = function(event){ event.cancelBubble = true; } &lt;/script> &lt;/body> &lt;/html> 键盘事件 键盘事件，由键盘按下keydown，键盘按下keypress,键盘弹起几个事件组成。 当在组件上键盘按下的时候，会触发onkeydown事件。 当在组件上键盘按下的时候，也会触发onkeypress事件。 当在组件上键盘弹起的时候，会触发onkeyup事件 。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>鼠标按下和抬起&lt;/title> &lt;style type=\"text/css\"> body,html{height: 100%;} &lt;/style> &lt;/head> &lt;body> “记得要先用鼠标选中该组件，然后敲击键盘” &lt;br> &lt;input type=\"button\" onkeydown=\"down(event)\" value=\"用于演示按下keydown\" > &lt;br> &lt;br> &lt;input type=\"button\" onkeypress=\"press(event)\" value=\"用于演示按下keypress\" > &lt;br> &lt;br> &lt;input type=\"button\" onkeyup=\"up()\" value=\"用于演示弹起\" > &lt;br> &lt;br> &lt;div id=\"message\"> &lt;/div> &lt;script type=\"text/javascript\"> var number =0; function down(e){ var text = \"按下了键\" + e.keyCode; if(e.shiftKey==1) text += \" 并且按下了shift键\"; document.getElementById(\"message\").innerHTML=text ; } function up(){ document.getElementById(\"message\").innerHTML=\"弹起了键盘\"; } function press(e){ var text = \"按下了键\" + e.keyCode; if(e.shiftKey==1) text += \" 并且按下了shift键\"; document.getElementById(\"message\").innerHTML=text ; } &lt;/script> &lt;/body> &lt;/html> 其他事件加载完成事件 当整个文档加载成功，或者一个图片加载成功，会触发加载事件 。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>加载完成事件&lt;/title> &lt;style type=\"text/css\"> #myDiv{width: 100px;height: 100px;background: black;} &lt;/style> &lt;/head> &lt;body> &lt;div id='myDiv'>&lt;/div> &lt;/body> &lt;script> // 函数一开始是不执行的：整个浏览器窗口加载完毕以后才执行，相当于所有的元素都已经被读取了 window.onload = function(){ setTimeout(function(){ document.getElementById('myDiv').style.height = '200px'; },1000); }; &lt;/script> &lt;/html> 得到焦点事件 onfocus == 得到焦点 onblur == 失去焦点 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>得到焦点和失去焦点&lt;/title> &lt;/head> &lt;body> &lt;input type=\"text\" id=\"txt\"> &lt;/body> &lt;script> // 获得文本对象 var txt = document.getElementById(\"txt\"); // 得到焦点 txt.onfocus = function(){ txt.style.background = \"red\"; } // 失去焦点 txt.onblur = function(){ txt.style.background = \"blue\"; } &lt;/script> &lt;/html> OnChange事件 值发生变化的时候触发。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>onchange事件&lt;/title> &lt;/head> &lt;body> &lt;select name=\"\" id=\"city\"> &lt;option value=\"\">北京&lt;/option> &lt;option value=\"\">天津&lt;/option> &lt;option value=\"\">上海&lt;/option> &lt;/select> &lt;/body> &lt;script> // 获得文本 var city = document.getElementById(\"city\"); // 文本修改值 city.onchange = function(){ alert(\"改变值了\"); } &lt;/script> &lt;/html> 添加事件处理HTML事件处理语法：把事件添加到了节点身上 缺点：HTML和javaScript耦合 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>HTML事件处理&lt;/title> &lt;/head> &lt;body> &lt;div id=\"box\" onclick=\"alert( fn(20,10) )\">我是box&lt;/div> &lt;/body> &lt;script> function fn(num1,num2){ return num1*num2; } &lt;/script> &lt;/html> DOM0级事件处理 语法： box.onclick = function(){} 缺点：同样的元素，同样的事件，后面的会覆盖前面 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>HTML事件处理&lt;/title> &lt;/head> &lt;body> &lt;div id=\"box\">我是box&lt;/div> &lt;/body> &lt;script> // 获得文本元素 var box = document.getElementById(\"box\"); /* box.onclick = function(){ alert( fn(30,20) ); } function fn(num1,num2){ return num1*num2; }*/ /*box.onclick = function(){ alret(1); } box.onclick = function(){ alert(2); }*/ // 加载事件完成 window.onload = function(){ alert(1); } window.onload = function(){ alert(2); } &lt;/script> &lt;/html> DOM2级事件处理(事件绑定)基础语法 addEventListener('放入事件名称（不用加on）',fn,true/false) 注意 能做到事件叠加不会覆盖之前的事件。 一般情况下不要加第三个参数 有兼容问题。 true 代表是事件捕获情况下执行。 false 事件冒泡情况下执行。 缺点：在IE（8或者8以下）不兼容 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>事件绑定&lt;/title> &lt;/head> &lt;body> &lt;input type=\"button\" value='add' name=\"\" id='ipt'> &lt;script type=\"text/javascript\"> ipt.onclick = function(){ alert(1); }; ipt.addEventListener('click',function(){ alert(2); }); &lt;/script> &lt;/body> &lt;/html> IE事件处理语法：box.attachEvent(事件名称,函数) 参数1需要加入on &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>IE事件处理&lt;/title> &lt;/head> &lt;body> &lt;div id=\"box\">我是box&lt;/div> &lt;/body> &lt;script> var box = document.getElementById(\"box\"); box.attachEvent(\"onclick\",function(){ alert(1); }) box.attachEvent(\"onclick\",function(){ alert(2); }) &lt;/script> &lt;/html> 跨浏览器事件处理 DOM0事件处理程序 DOM2事件处理程序 IE事件处理程序 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>跨浏览器事件处理&lt;/title> &lt;/head> &lt;body> &lt;div id=\"box\">我是box盒子&lt;/div> &lt;/body> &lt;script> var box = document.getElementById(\"box\"); function setEvent(dom,evt,fn){ if(dom.addEventListener){ dom.addEventListener(evt,fn,false); }else if(dom.attachEvent){ // IE事件处理程序 dom.attachEvent(\"on\"+evt,fn); }else{ dom[\"on\"+evt] = fn; } } setEvent(box,\"click\",function(){ alert(1); }) setEvent(box,\"click\",function(){ alert(2); }) &lt;/script> &lt;/html> 删除事件处理dom0级事件处理语法： DOM对象.事件名称 = null &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>dom0级事件处理&lt;/title> &lt;/head> &lt;body> &lt;div id=\"box\">我是box&lt;/div> &lt;script> var box = document.getElementById(\"box\"); box.onclick = function(){ alert(1); } box.onclick = null; &lt;/script> &lt;/body> &lt;/html> dom2级事件处理语法： DOM对象.removeEventListener(事件名称,函数,false|true) 注意： 参数1 == 事件名称不需要加入on。 参数2 == 函数,添加和删除必须都是同一个函数，才有效。 参数3 == （false==冒泡） （true===捕获） &lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>dom2级事件处理&lt;/title> &lt;/head> &lt;body> &lt;input type=\"button\" value='add' name=\"\" id='ipt'> &lt;script type=\"text/javascript\"> function a(){ alert(1); ipt.removeEventListener('click',a); }; function b(){ alert(2); }; ipt.addEventListener('click',a); ipt.addEventListener('click',b); &lt;/script> &lt;/body> &lt;/html> IE事件处理语法： DOM对象. attachEvent(事件名称,函数) 注意： 参数1》事件名称需要加入on。 参数2》函数,添加和删除必须都是同一个函数，才有效 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>IE事件处理&lt;/title> &lt;/head> &lt;body> &lt;div id=\"box\">我是box&lt;/div> &lt;script> var box = document.getElementById(\"box\"); function fn(){ alert(222); } // 绑定事件 box.attachEvent(\"onclick\",fn) // 解绑事件 box.detachEvent(\"onclick\",fn) &lt;/script> &lt;/body> &lt;/html> 跨浏览器事件处理&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>跨浏览器事件处理&lt;/title> &lt;/head> &lt;body> &lt;div id=\"box\">我是box&lt;/div> &lt;script> function removeEvent(dom,evt,fn){ if(dom.removeEventListener){ dom.removeEventListener(evt,fn,false); }else if(dom.detachEvent){ dom.detachEvent(\"on\"+evt,fn); }else{ dom[\"on\"+evt] = null; } } &lt;/script> &lt;/body> &lt;/html> 事件对象语法： 非IE中事件对象====》参数 IE中事件对象===》window.event 跨浏览器事件对象===》window.event || e（参数） &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>事件对象&lt;/title> &lt;/head> &lt;body> &lt;div id=\"box\">我是box&lt;/div> &lt;/body> &lt;script> // 获得文档 var box = document.getElementById(\"box\"); // 绑定事件 box.onclick = function(e){ //alert(e); //alert(window.event); //1>非IE ===》参数e //2>IE===》window.event var evt = window.event || e; alert(evt); } &lt;/script> &lt;/html> 事件对象属性 target(非IE)===》目标（返回对应的DOM节点） srcElement（IE中）====》目标（返回对应的DOM节点） 处理兼容： 事件对象.target||事件对象.srcElement &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>事件对象属性&lt;/title> &lt;/head> &lt;body> &lt;div id=\"box\"> 我是box &lt;p>11111&lt;/p> &lt;span>22222&lt;/span> &lt;/div> &lt;/body> &lt;script> var box = document.getElementById(\"box\"); box.onclick = function(e){ var e = window.event||e; var tar = e.target || e.srcElement; alert(tar); } &lt;/script> &lt;/html> 事件委托原理：就是给予父级元素事件，父级元素可以找到子级事件源。通过判断事件源 classname nodename id，找到咱们需要的事件源 给予js脚本，最大的好处可以控制未来(动态生成)的元素。 优点： 1》性能较好（提高） 2》即使后添加的也有效 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>事件委托&lt;/title> &lt;style type=\"text/css\"> .div{width: 200px;height: 200px;background: black;float: left;margin: 100px;} .div1{width: 250px;height: 250px;background: black;float: left;margin: 100px;} &lt;/style> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> document.documentElement.onclick = function(){ // 非IE对应的节点 //console.log(event.target); // IE对应的节点 //console.log(event.srcElement); var iTarget = event.target || event.srcElement; if(iTarget.className == 'div'){ iTarget.style.background = 'red'; } else if(iTarget.className =='div1'){ iTarget.style.background = 'green'; } }; for(var i = 0;i &lt; 10;i++){ // 得到oDiv节点 var oDiv = document.createElement('div'); if(i&lt;5){ oDiv.className = 'div'; } else{ oDiv.className = 'div1'; } // 向html中添加节点 document.body.appendChild(oDiv); }; &lt;/script> &lt;/body> &lt;/html> 事件阻止冒泡语法： 事件对象.属性名称 非IE：e.stopPropagation IE：e.cancelBubble = true; 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>事件阻止冒泡&lt;/title> &lt;/head> &lt;style> #dv1{ width:300px; height:300px; background: red; } #dv2{ width:100px; height:100px; background: blue; } &lt;/style> &lt;body> &lt;div id=\"dv1\"> &lt;div id=\"dv2\">&lt;/div> &lt;/div> &lt;/body> &lt;script> // 获得文本元素 var dv1 = document.getElementById(\"dv1\"), dv2 = document.getElementById(\"dv2\"); dv1.onclick = function(){ alert(\"dv1\"); } dv2.onclick = function(e){ var e = window.event || e; // 条件判断 if(e.stopPropagation){ e.stopPropagation(); }else{ e.cancelBubble = true; } alert(\"dv2\"); } &lt;/script> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}]},{"title":"JavaScript之DOM操作2","slug":"前端/JavaScript/JavaScript之DOM操作2","date":"2020-01-01T06:21:01.000Z","updated":"2020-05-12T13:14:01.984Z","comments":true,"path":"2020/01/01/qian-duan/javascript/javascript-zhi-dom-cao-zuo-2/","link":"","permalink":"http://yoursite.com/2020/01/01/qian-duan/javascript/javascript-zhi-dom-cao-zuo-2/","excerpt":"","text":"DOM属性基本属性dom元素 一些普通常见的属性是可以直接获取或者设置的，例如 id class type href src。 代码示例&lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>基本属性&lt;/title> &lt;/head> &lt;body> &lt;div id='div1'>&lt;/div> &lt;script> console.log(div1.id); &lt;/script> &lt;/body> &lt;/html> 显示属性 自定义的属性必须使用 setAttribute。setAttribute(属性，属性值)，就可以显示在页面的元素上面了。 只想挂属性不挂值 setAttribute(属性，” “); &lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>自定义属性&lt;/title> &lt;/head> &lt;body> &lt;div id='div1' class='div2' >&lt;/div> &lt;script type=\"text/javascript\"> div1.setAttribute('leo','') //div1.setAttribute('leo',18); &lt;/script> &lt;/body> &lt;/html> 获取属性获取元素上的属性getAttribute(属性); &lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>获取属性&lt;/title> &lt;/head> &lt;body> &lt;a href=\"http://www.baidu.com\" id='needA'>链接&lt;/a> &lt;script type=\"text/javascript\"> console.log(needA.getAttribute('href')); &lt;/script> &lt;/body> &lt;/html> 删除属性删除元素上的属性removeAttribute(属性)。 &lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>删除属性&lt;/title> &lt;/head> &lt;body> &lt;div id='div1' class='div2' leo='18'>&lt;/div> &lt;a href=\"http://www.baidu.com\" id='needA'>链接&lt;/a> &lt;script type=\"text/javascript\"> div1.removeAttribute('leo'); needA.removeAttribute('href'); &lt;/script> &lt;/body> &lt;/html> 隐式属性hasAttribute 判断元素上的可见属性,如果有的情况下 就返回一个true。没有的情况下 就返回一个false。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>hasAttribute&lt;/title> &lt;style type=\"text/css\"> #div1{width: 200px;height: 200px;background: red;} &lt;/style> &lt;/head> &lt;body> &lt;div id='div1' class='div2' leo='18'>&lt;/div> &lt;a href=\"http://www.baidu.com\" id='needA'>链接&lt;/a> &lt;script type=\"text/javascript\"> div1.onclick = function(){ if(div1.hasAttribute('leo')){ div1.setAttribute('leo',19) } else{ div1.setAttribute('leo',18); } }; &lt;/script> &lt;/body> &lt;/html> className属性 className 属性设置或返回元素的 class 属性。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>hasAttribute&lt;/title> &lt;style type=\"text/css\"> .div2{width: 200px;height: 200px;background: red;} .div3{ background: yellow; } &lt;/style> &lt;/head> &lt;body> &lt;div id='div1' class='div2' leo='18'>&lt;/div> &lt;script type=\"text/javascript\"> div1.onclick = function(){ div1.className = 'div2 div3'; }; &lt;/script> &lt;/body> &lt;/html> classList属性定义： classList 属性返回元素的类名，作为 DOMTokenList 对象。 该属性用于在元素中添加，移除及切换 CSS 类。 classList 属性是只读的，但你可以使用 add() 和 remove() 方法修改它。 add()：添加 一个 类。 &lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>&lt;/title> &lt;style type=\"text/css\"> .box1{width: 200px;height: 200px;background: black;transition:.3s;} .box2{background: red;} &lt;/style> &lt;/head> &lt;body> &lt;div id='div1' class='box1'>&lt;/div> &lt;script type=\"text/javascript\"> div1.onclick = function(){ div1.classList.add('box2'); } &lt;/script> &lt;/body> &lt;/html> remove()：删除一个 类。 &lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>&lt;/title> &lt;style type=\"text/css\"> .box1{width: 200px;height: 200px;background: black;transition:.3s;} .box2{background: red;} .box4{box-shadow: 0 0 10px black;} &lt;/style> &lt;/head> &lt;body> &lt;div id='div1' class='box1 box2 box4'>&lt;/div> &lt;script type=\"text/javascript\"> div1.onclick = function(){ div1.classList.remove('box2'); } &lt;/script> &lt;/body> &lt;/html> contains()：判断有没有该类 如果有返回true 没有返回false。 &lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>&lt;/title> &lt;style type=\"text/css\"> .box1{width: 200px;height: 200px;background: black;transition:.3s;} .box2{background: red;} .box4{box-shadow: 0 0 10px black;} &lt;/style> &lt;/head> &lt;body> &lt;div id='div1' class='box1 box2 box4'>&lt;/div> &lt;script type=\"text/javascript\"> div1.onclick = function(){ if(div1.classList.contains('box3')){ alert('该元素 有 box3 的类') } else{ alert('该元素 没有 box3的类') } } &lt;/script> &lt;/body> &lt;/html> toggle()：切换一个类如果有就删除，没有就添加。 &lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>&lt;/title> &lt;style type=\"text/css\"> .box1{width: 200px;height: 200px;background: black;transition:.3s;} .box2{background: red;} .box4{box-shadow: 0 0 10px black;} &lt;/style> &lt;/head> &lt;body> &lt;div id='div1' class='box1 box2'>&lt;/div> &lt;script type=\"text/javascript\"> div1.onclick = function(){ div1.classList.toggle('box4'); } &lt;/script> &lt;/body> &lt;/html> HTML DOM节点关系html图解 html结构&lt;html> &lt;head> &lt;title>遍历节点&lt;/title> &lt;/head> &lt;body> &lt;p>文本叶子节点&lt;/p> &lt;/body> &lt;/html> 节点关系图 说明 d1 d2 d3 的parentNode是parentDiv，parentDiv的firstNode是d1。 parentDiv的lastNode是d3，d2的previousSibling是d1。 d2的nextSibling是d3，parentDiv的children是 d1 d2 d3 。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>节点关系图&lt;/title> &lt;/head> &lt;body> &lt;div id=\"parentDiv\"> &lt;div id=\"d1\">第一个div&lt;/div> &lt;div id=\"d2\">第二个div&lt;/div> &lt;div id=\"d3\">第三个div&lt;/div> &lt;/div> &lt;/body> &lt;/html> 父节点关系(parentNode)注明 通过parentNode获取父节点。从id=d1的div开始递归获取其父节点。 分别获取如下父节点 DIV[id=parentDiv] -&gt; body-&gt;html-&gt;document 。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>父节点关系&lt;/title> &lt;/head> &lt;body> &lt;script> var node = null; function showParent(){ if(null==node) node = document.getElementById(\"d1\"); if(document == node) alert(\"已是根节点:document\"); else{ alert(node.parentNode); node = node.parentNode; } } &lt;/script> &lt;div id=\"parentDiv\"> 父Div的内容 &lt;div id=\"d1\">第一个div&lt;/div> &lt;div id=\"d2\">第二个div&lt;/div> &lt;div id=\"d3\">第三个div&lt;/div> &lt;/div> &lt;button onclick=\"showParent()\">不断递归d1的父节点&lt;/button> &lt;/body> &lt;/html> 同胞节点关系 通过 previousSibling和nextSibling属性获取前一个，以及后一个同胞节点。 注意 d1和d2标签是紧挨着的，所以d2前一个节点是d1。 d2和d3不是紧挨着 标签之间有任何字符、空白、换行都会产生文本元素。 所以获取到的节点是#text. 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>同胞节点关系&lt;/title> &lt;/head> &lt;body> &lt;script> function showPre(){ var d2 = document.getElementById(\"d2\"); alert(d2.previousSibling.innerHTML); } function showNext(){ var d2 = document.getElementById(\"d2\"); alert(d2.nextSibling.nodeName); } &lt;/script> &lt;div id=\"parentDiv\"> 父Div的内容 &lt;div id=\"d1\">第一个div&lt;/div>&lt;div id=\"d2\">第二个div&lt;/div> &lt;div id=\"d3\">第三个div&lt;/div> &lt;/div> &lt;button onclick=\"showPre()\">获取d2的前一个同胞&lt;/button> &lt;button onclick=\"showNext()\">获取d2的后一个同胞&lt;/button> &lt;/body> &lt;/html> 子节点关系(childNodes)firstChild 第一个子节点，lastChild 最后一个子节点childNodes 所有子节点 。 注意firstChild 如果父节点的开始标签和第一个元素的开始标签之间有文本、空格、换行，那么firstChild第一个子节点将会是文本节点，不会是第一个元素节点 。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>子节点关系&lt;/title> &lt;/head> &lt;body> &lt;script> function showfirst(){ var div = document.getElementById(\"parentDiv\"); alert(div.firstChild.nodeName); } function showlast(){ var div = document.getElementById(\"parentDiv\"); alert(div.lastChild.nodeName); } function showall(){ var div = document.getElementById(\"parentDiv\"); alert(div.childNodes.length); } &lt;/script> &lt;div id=\"parentDiv\"> 父Div的内容 &lt;div id=\"d1\">第一个div&lt;/div> &lt;div id=\"d2\">第二个div&lt;/div> &lt;div id=\"d3\">第三个div&lt;/div>&lt;/div> &lt;button onclick=\"showfirst()\">第一个子节点&lt;/button> &lt;button onclick=\"showlast()\">最后一个子节点&lt;/button> &lt;button onclick=\"showall()\">所有子节点数量&lt;/button> &lt;/body> &lt;/html> 区别： childNodes和children都可以获取一个元素节点的子节点。 childNodes 会包含文本节点。 children 会排除文本节点。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>区别&lt;/title> &lt;/head> &lt;body> &lt;div id=\"parentDiv\"> &lt;div id=\"d1\">第一个div&lt;/div> &lt;div id=\"d2\">第二个div&lt;/div> &lt;div id=\"d3\">第三个div&lt;/div>&lt;/div> &lt;button onclick=\"showNumber1()\">通过childNodes获取子节点总数&lt;/button> &lt;button onclick=\"showNumber2()\">通过children()获取子节点总数&lt;/button> &lt;script> function showNumber1(){ alert(document.getElementById(\"parentDiv\").childNodes.length); } function showNumber2(){ alert(document.getElementById(\"parentDiv\").children.length); } &lt;/script> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}]},{"title":"JavaScript之DOM操作1","slug":"前端/JavaScript/JavaScript之DOM操作1","date":"2020-01-01T06:20:50.000Z","updated":"2020-05-12T13:12:14.026Z","comments":true,"path":"2020/01/01/qian-duan/javascript/javascript-zhi-dom-cao-zuo-1/","link":"","permalink":"http://yoursite.com/2020/01/01/qian-duan/javascript/javascript-zhi-dom-cao-zuo-1/","excerpt":"","text":"HTML DOM定义文档对象模型( DOM, Document Object Model )主要用于对 HTML 文档的内容进行操作。DOM 把 HTML 文档表达成一个节点树，通过对节点进行操作，实现对文档内容的添加、删除、修改、查找等功能。 节点概念DOM 节点就是 HTML 上所有的内容 ,包括 : 文档节点 元素节点(标签) 元素属性节点 文本节点 注释节点 如图所示 注解DOM把所有的html都转换为节点。整个文档 是一个节点，元素是节点。元素属性是节点。元素内容 是节点。注释也是节点。 图解 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>节点概念&lt;/title> &lt;/head> &lt;body> &lt;div id=\"d1\">hello HTML DOM&lt;/div> &lt;/body> &lt;script> function p(s){ document.write(s); document.write(\"&lt;br>\"); } var div1 = document.getElementById(\"d1\"); p(\"文档节点\"+document); p(\"元素\"+div1); p(\"属性节点\"+div1.attributes[0]); p(\"内容节点\"+div1.childNodes[0]); &lt;/script> &lt;/html> 获取父级元素 ParentNode(父级元素) 代码示例&lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>获取父级元素&lt;/title> &lt;/head> &lt;body> &lt;div> &lt;div> &lt;div id='div1'> &lt;/div> &lt;/div> &lt;/div> &lt;script type=\"text/javascript\"> //console.log(div1); div1.style.width = '200px'; div1.style.height = '200px'; div1.style.background = 'red'; //选取父级 div1.parentNode.style.width ='300px'; div1.parentNode.style.height ='300px'; div1.parentNode.style.background ='yellow'; div1.parentNode.parentNode.style.width = '400px'; div1.parentNode.parentNode.style.height = '400px'; div1.parentNode.parentNode.style.background = 'green'; console.log(div1.parentNode.parentNode.parentNode) &lt;/script> &lt;/body> &lt;/html> 获取子级元素 子级Children() 代码示例&lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>&lt;/title> &lt;/head> &lt;body> &lt;div id='parentDiv'> &lt;div>&lt;/div> &lt;div>&lt;/div> &lt;div>&lt;/div> &lt;div>&lt;/div> &lt;/div> &lt;script type=\"text/javascript\"> for(var i = 0;i &lt; parentDiv.children.length;i++){ parentDiv.children[i].style.width ='200px'; parentDiv.children[i].style.height ='200px'; parentDiv.children[i].style.background = 'green'; } //console.log() parentDiv.children[0].style.width = '200px'; parentDiv.children[0].style.height = '200px'; parentDiv.children[0].style.background = 'red'; parentDiv.children[2].style.width = '300px'; parentDiv.children[2].style.height = '300px'; parentDiv.children[2].style.background = 'yellow'; &lt;/script> &lt;/body> &lt;/html> HTML DOM 获取节点 获取节点的方法 作用 document.getElementById(“id”) 通过id得到一个元素 document.getElementsByTagName(“标签名”) 通过标签名得到一组元素 document.getElementsByName(“name”) 通过name属性得到一组元素 document.getElementsByClassName(“类名”) 通过class属性得到一组元素 querySelector() 只返回匹配指定选择器的第一个元素 querySelectorAll() 返回所有匹配元素 getElementById() 通过id获取元素节点 。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>getElementById&lt;/title> &lt;/head> &lt;body> &lt;div id=\"d1\">hello HTML DOM&lt;/div> &lt;/body> &lt;script> var div1 = document.getElementById(\"d1\"); document.write(div1); &lt;/script> &lt;/html> getElementsByTagName() 通过标签名称获取元素节点 。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>getElementsByTagName&lt;/title> &lt;/head> &lt;body> &lt;div >hello javascript&lt;/div> &lt;div >hello BOM&lt;/div> &lt;div >hello DOM&lt;/div> &lt;br> &lt;/body> &lt;script> var divs = document.getElementsByTagName(\"div\"); for(i=0;i&lt;divs.length;i++){ document.write(divs[i]); document.write(\"&lt;br>\"); } &lt;/script> &lt;/html> getElementsByClassName() 通过类名获取元素节点 。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>getElementsByClassName&lt;/title> &lt;/head> &lt;body> &lt;h1 class=\"d\" >hello javascript&lt;/h1> &lt;h2 class=\"d\" >hello BOM&lt;/h2> &lt;div class=\"d\" >hello DOM&lt;/div> &lt;br> &lt;/body> &lt;script> var elements= document.getElementsByClassName(\"d\"); for(i=0;i&lt;elements.length;i++){ document.write(elements[i]); document.write(\"&lt;br>\"); } &lt;/script> &lt;/html> getElementsByName() 通过表单元素的name获取元素节点 。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>getElementsByName&lt;/title> &lt;/head> &lt;body> 用户名 &lt;input name=\"userName\"> &lt;br> 密码 &lt;input name=\"userPassword\"> &lt;br> &lt;/body> &lt;script> var elements= document.getElementsByName(\"userName\"); for(i=0;i&lt;elements.length;i++){ document.write(elements[i]); document.write(\"&lt;br>\"); } &lt;/script> &lt;/html> querySelector() 返回文档中匹配指定CSS选择器的一个元素。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>querySelector&lt;/title> &lt;/head> &lt;body> &lt;p>这是一个p与元素。&lt;/p> &lt;p>这也是一个p与元素。&lt;/p> &lt;p>点击按钮修改文档中第一个 p 元素的背景颜色。&lt;/p> &lt;button onclick=\"myFunction()\">点我&lt;/button> &lt;/body> &lt;script> function myFunction() { document.querySelector(\"p\").style.backgroundColor = \"red\"; } &lt;/script> &lt;/html> querSelectorAll() 返回文档中匹配指定CSS选择器的一组元素 代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>querySelectorAll&lt;/title> &lt;style> .example { border: 1px solid black; margin: 5px; } &lt;/style> &lt;/head> &lt;body> &lt;h1>一个h1元素&lt;/h1> &lt;div>一个div元素&lt;/div> &lt;p>一个p元素。&lt;/p> &lt;p>另一个p元素。&lt;/p> &lt;div class=\"example\"> &lt;p>在div中的一个p元素。&lt;/p> &lt;/div> &lt;p>点击按钮修改文档中所有p元素的背景颜色。&lt;/p> &lt;button onclick=\"myFunction()\">点我&lt;/button> &lt;p>&lt;strong>注意:&lt;/strong>Internet Explorer8及更早版本不支持 querySelectorAll()方法。&lt;/p> &lt;script> function myFunction() { var x = document.querySelectorAll(\"p\"); // 定义变量 var i; for (i = 0; i &lt; x.length; i++) { x[i].style.backgroundColor = \"red\"; } } &lt;/script> &lt;/body> &lt;/html> 获取不到节点注意通过id获取元素节点同样的代码 document.getElementById却无法获取元素节点。这是因为javascript是解释语言，是顺序执行的。 在执行到 document.getElementById的时候，div标签还没有加载，所以无法获取。 代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>innerHTML&lt;/title> &lt;script> var div1 = document.getElementById(\"d1\"); document.write(div1); &lt;/script> &lt;/head> &lt;body> &lt;div id=\"d1\">hello HTML DOM&lt;/div> &lt;/body> &lt;/html> HTML DOM 创建节点 方法名 作用 document.createElement(‘元素名’); 创建新的元素节点 document.createAttribute(‘属性名’); 创建新的属性节点 document.createTextNode(‘文本内容’); 创建新的文本节点 document.createComment(‘注释节点’); 创建注释节点 document.createDocumentFragment( ); 创建文档片段节点 createElement()&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>创建新的节点&lt;/title> &lt;style type=\"text/css\"> div{width: 200px;height: 200px;background: red;} &lt;/style> &lt;/head> &lt;body> &lt;input type=\"button\" value='我是一个美丽的小按钮' name=\"\" id='ipt'> &lt;span id='outNode'>&lt;/span> &lt;script> var i = 0; ipt.onclick = function(){ var oDiv = document.createElement('div'); oDiv.innerHTML = i; outNode.appendChild(oDiv); i++; }; &lt;/script> &lt;/body> &lt;/html> 高效创建节点innerHTML innerHTML设置或获取位于对象起始和结束标签内的HTML。 innerHTML 返回dom的内容。 如果 ＝ 就是赋予dom内容。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>innerHTML&lt;/title> &lt;/head> &lt;body> &lt;p>你好&lt;/p> &lt;div id=\"test\">&lt;h5>就是喜欢你&lt;/h5>&lt;/div> &lt;script> var hj=document.getElementById(\"test\").innerHTML; alert(hj); var kj=document.getElementById(\"test\").outerHTML; //alert(kj); //document.write(kj); &lt;/script> &lt;/body> &lt;/html> outerHTML outerHTML 会返回 dom本身＋自己的内容。 如果 ＝ 就是连自己也给替换了。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>innerHTML&lt;/title> &lt;/head> &lt;body> &lt;p>你好&lt;/p> &lt;div id=\"test\">&lt;h5>就是喜欢你&lt;/h5>&lt;/div> &lt;script> var hj=document.getElementById(\"test\").innerHTML; //alert(hj); var kj=document.getElementById(\"test\").outerHTML; alert(kj); &lt;/script> &lt;/body> &lt;/html> innerTextinnerText 设置或获取位于对象起始和结束标签内的文本。 代码示例outerText outerText设置(包括标签)或获取(不包括标签)对象的文本 。 代码示例HTML DOM 删除节点remove() 删除自身。 代码示例&lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>&lt;/title> &lt;/head> &lt;body> &lt;div id='outNode'> &lt;span> 11111 &lt;/span> &lt;span id='oSpan'> 22222 &lt;/span> &lt;/div> &lt;script type=\"text/javascript\"> // 删除自身。 outNode.remove(); //oSpan.remove(); //outNode.children[0].remove(); &lt;/script> &lt;/body> &lt;/html> removeChild() 从子节点列表中删除某个节点。 第一：先获取该元素的父节点 第二：通过父节点，调用removeChild删除该节点 代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>removeChild &lt;/title> &lt;/head> &lt;body> &lt;script> function removeDiv(){ var parentDiv = document.getElementById(\"parentDiv\"); var div2= document.getElementById(\"div2\"); parentDiv.removeChild(div2); } &lt;/script> &lt;div id=\"parentDiv\"> &lt;div id=\"div1\">安全的div&lt;/div> &lt;div id=\"div2\">即将被删除的div&lt;/div> &lt;/div> &lt;button onclick=\"removeDiv()\">删除第二个div&lt;/button> &lt;/body> &lt;/html> removeAttribute() 删除指定的属性 。 第一：先获取该元素节点。 第二：元素节点，调用removeAttribute删除指定属性节点。 代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>removeChild &lt;/title> &lt;script> function removeHref(){ var link= document.getElementById(\"link\"); link.removeAttribute(\"href\"); } &lt;/script> &lt;/head> &lt;body> &lt;a id=\"link\" href=\"http://12306.com\">http://12306.com&lt;/a> &lt;br> &lt;button onclick=\"removeHref()\">删除超链的href属性&lt;/button> &lt;/body> &lt;/html> HTML DOM插入节点appendChild()为指定元素节点的最后一个子节点之后添加节点。该方法返回新的子节点。 通过appendChild追加节点。 追加节点一定是把新的节点插在最后面。 1. 创建新节点 2. 获取父节点 3. 通过appendChild追加 代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>appendChild&lt;/title> &lt;/head> &lt;body> &lt;ul id=\"List\"> &lt;li>kobe&lt;/li> &lt;li>Jordan&lt;/li> &lt;/ul> &lt;p id=\"demo\">单击按钮将球星添加到列表中&lt;/p> &lt;button onclick=\"myFunction()\">点我&lt;/button> &lt;script> function myFunction(){ // 创建元素节点 var node=document.createElement(\"li\"); // 创建文本节点 var textnode=document.createTextNode(\"james\"); node.appendChild(textnode); document.getElementById(\"List\").appendChild(node); } &lt;/script> &lt;p>&lt;strong>注意:&lt;/strong>&lt;br>首先创建一个节点，&lt;br> 然后创建一个文本节点，&lt;br>然后将文本节点添加到LI节点上。&lt;br>最后将节点添加到列表中。&lt;/p> &lt;/body> &lt;/html> insertBefore()在指定的已有子节点之前插入新的子节点。 代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>insertBefore&lt;/title> &lt;/head> &lt;body> &lt;ul id=\"myList\"> &lt;li>kobe&lt;/li> &lt;li>Jordan&lt;/li> &lt;/ul> &lt;p id=\"demo\">单击按钮插入一个项目列表&lt;/p> &lt;button onclick=\"myFunction()\">点我&lt;/button> &lt;script> function myFunction(){ // 创建元素节点 var newItem=document.createElement(\"LI\"); // 创建文本节点 var textnode=document.createTextNode(\"james\"); // 添加到文本节点 newItem.appendChild(textnode); // 创建list元素节点 var list=document.getElementById(\"myList\"); // 插入新的子节点 list.insertBefore(newItem,list.childNodes[0]); } &lt;/script> &lt;p>&lt;strong>注意:&lt;/strong>&lt;br>首先创建一个li节点,&lt;br>然后创建一个文本节点,&lt;br>然后添加文本节点的在li节点。&lt;br>最后在第一个子节点列表插入li节点。&lt;/p> &lt;/body> &lt;/html> cloneNode() 创建节点的拷贝。并返回该副本 拷贝的节点要有父节点，如果没有父节点，要通过appendChild()、insertBefore()、replaceChild()等方法对齐进行添加。 代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>cloneNode&lt;/title> &lt;/head> &lt;body> &lt;ul id=\"myList1\"> &lt;li>Coffee&lt;/li> &lt;li>Tea&lt;/li> &lt;/ul> &lt;ul id=\"myList2\"> &lt;li>Water&lt;/li> &lt;li>Milk&lt;/li> &lt;/ul> &lt;p id=\"demo\">单击按钮将一个列表复制到另一个列表中&lt;/p> &lt;button onclick=\"myFunction()\">点我&lt;/button> &lt;script> function myFunction(){ var itm=document.getElementById(\"myList2\").lastChild; var cln=itm.cloneNode(true); document.getElementById(\"myList1\").appendChild(cln); } &lt;/script> &lt;p>尝试更改&lt;em>deep&lt;/em>参数为假，只有一个空的li元素将被克隆&lt;/p> &lt;/body> &lt;/html> HTML DOM 替换节点replaceChild()replaceChild（要插入的节点，被替换的节点）返回被替换的节点。 说明1. 获取父节点 2. 创建子节点 3. 获取被替换子节点 4. 通过replaceChild进行替换 注意: replaceChild 第一个参数是保留的节点，第二个参数是被替换的节点。 代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>replaceChild&lt;/title> &lt;/head> &lt;body> &lt;div id=\"parentDiv\"> &lt;div id=\"d1\">第一个div&lt;/div> &lt;div id=\"d2\">第二个div&lt;/div> &lt;div id=\"d3\">第三个div&lt;/div> &lt;/div> &lt;script> function replaceDiv(){ var d4= document.createElement(\"div\"); var text = document.createTextNode(\"第四个div\"); d4.appendChild(text); var d3 = document.getElementById(\"d3\"); var parentDiv = document.getElementById(\"parentDiv\"); parentDiv.replaceChild(d4,d3); } &lt;/script> &lt;button onclick=\"replaceDiv()\">替换第3个div&lt;/button> &lt;/body> &lt;/html> HTML DOM 集合HTMLCollection 对象 HTMLCollection 对象类似包含 HTML 元素的一个数组。 方法 作用 getElementsByTagName() 返回HTMLCollection对象 代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>返回HTMLCollection对象&lt;/title> &lt;/head> &lt;body> &lt;h2>JavaScript HTML DOM&lt;/h2> &lt;p>Hello World!&lt;/p> &lt;p>Hello Runoob!&lt;/p> &lt;p id=\"demo\">&lt;/p> &lt;script> var myCollection = document.getElementsByTagName(\"p\"); document.getElementById(\"demo\").innerHTML = \"第二个段落的内容为:&lt;span style='color:red;'> \" + myCollection[1].innerHTML + '&lt;/span>'; &lt;/script> &lt;/body> &lt;/html> length属性 HTMLCollection 对象的 length 属性定义了集合中元素的数量。 代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>length属性&lt;/title> &lt;/head> &lt;body> &lt;h2>JavaScript HTML DOM&lt;/h2> &lt;p>Hello World!&lt;/p> &lt;p>Hello Runoob!&lt;/p> &lt;p>点击按钮修改 p 元素的背景颜色。&lt;/p> &lt;button onclick=\"myFunction()\">点我&lt;/button> &lt;script> function myFunction() { var myCollection = document.getElementsByTagName(\"p\"); var i; for (i = 0; i &lt; myCollection.length; i++) { myCollection[i].style.color = \"red\"; } } &lt;/script> &lt;/body> &lt;/html> 注意 HTMLCollection 不是一个数组！HTMLCollection 看起来可能是一个数组，但其实不是。 可以像数组一样，使用索引来获取元素。 HTMLCollection 无法使用数组的方法： valueOf(), pop(), push(), 或 join() 。 HTML DOM 节点列表定义NodeList 对象是一个从文档中获取的节点列表 (集合) 。 说明 NodeList 对象类似HTMLCollection对象。 所有浏览器的 childNodes 属性返回的是 NodeList 对象。 大部分浏览器的 querySelectorAll() 返回 NodeList 对象。 代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>菜鸟教程(runoob.com)&lt;/title> &lt;/head> &lt;body> &lt;h2>JavaScript HTML DOM!&lt;/h2> &lt;p>Hello World!&lt;/p> &lt;p>Hello java!&lt;/p> &lt;p id=\"demo\">&lt;/p> &lt;script> var myNodelist = document.querySelectorAll(\"p\"); document.getElementById(\"demo\").innerHTML = \"第二个段落的内容为:&lt;span style='color:red;'> \" + myNodelist[1].innerHTML + '&lt;/span>'; &lt;/script> &lt;/body> &lt;/html> length属性 NodeList 对象 length 属性定义了节点列表中元素的数量。 代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>length属性&lt;/title> &lt;/head> &lt;body> &lt;h2>JavaScript HTML DOM!&lt;/h2> &lt;p>Hello World!&lt;/p> &lt;p>Hello java&lt;/p> &lt;p>点击按钮修改所有 p 元素的背景颜色。&lt;/p> &lt;button onclick=\"myFunction()\">点我&lt;/button> &lt;script> function myFunction() { var myNodelist = document.querySelectorAll(\"p\"); var i; for (i = 0; i &lt; myNodelist.length; i++) { myNodelist[i].style.color = \"red\"; } } &lt;/script> &lt;/body> &lt;/html> 区别 HTMLCollection是 HTML 元素的集合。NodeList 是一个文档节点的集合。 NodeList 与 HTMLCollection 都与数组对象有点类似，可以使用索引 (0, 1, 2, 3, 4, …) 来获取元素。 NodeList 与 HTMLCollection 都有 length 属性。 HTMLCollection 元素可以通过 name，id 或索引来获取。NodeList 只能通过索引来获取。 只有 NodeList 对象有包含属性节点和文本节点。 注意- 节点列表不是一个数组！节点列表看起来可能是一个数组，但其实不是。 - 节点列表可以像数组一样，使用索引来获取元素。 - 节点列表无法使用数组的方法： valueOf(), pop(), push(), 或 join() 。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}]},{"title":"JavaScript之BOM操作","slug":"前端/JavaScript/JavaScript之BOM操作","date":"2020-01-01T06:19:15.000Z","updated":"2020-02-29T08:05:08.378Z","comments":true,"path":"2020/01/01/qian-duan/javascript/javascript-zhi-bom-cao-zuo/","link":"","permalink":"http://yoursite.com/2020/01/01/qian-duan/javascript/javascript-zhi-bom-cao-zuo/","excerpt":"","text":"BOMBOM：Browser Object Model 浏览器对象模型，操作浏览器中各种对象。 说明 浏览器对象模型 (BOM) 使 JavaScript 有能力与浏览器”对话”。 Window 对象是BOM中所有对象的核心，除了是BOM中所有对象的父对象外，还包含一些窗口控制函数。 Window对象特点 所有浏览器都支持 window 对象。它表示浏览器窗口。 所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。 全局变量是 window 对象的属性。 全局函数是 window 对象的方法。 显示区域的高度和宽度&lt;script> document.write(\"文档内容\"); document.write(\"文档显示区域的宽度\"+window.innerWidth); document.write(\"&lt;br>\"); document.write(\"文档显示区域的高度\"+window.innerHeight); &lt;/script> 获取窗体的宽度和高度&lt;script> document.write(\"浏览器的宽度:\"+window.outerWidth); document.write(\"&lt;br>\"); document.write(\"浏览器的高度:\"+window.outerHeight); &lt;/script> 浏览器离屏幕的距离&lt;script> // 浏览器离屏幕左边的距离 console.log(window.screenLeft); // 浏览器离屏幕上边的距离 console.log(window.screenTop); &lt;/script> 打开新窗口&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>openNewWindow&lt;/title> &lt;script> function openNewWindow(){ myWindow=window.open(\"htpps://www.163.com\"); } &lt;/script> &lt;/head> &lt;body> &lt;button onclick=\"openNewWindow()\">打开一个新的窗口&lt;/button> &lt;/body> &lt;/html> JavaScript计时器 关键字 作用 setTimeout 只执行一次 setInterval 不停地重复执行 clearInterval 终止重复执行 只执行一次函数setTimeout(functionname, 距离开始时间毫秒数 )通过setTimeout在制定的毫秒数时间后,执行一次 函数functionname 。 代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>setTimeout&lt;/title> &lt;script> function printTime(){ var d = new Date(); var h= d.getHours(); var m= d.getMinutes(); var s= d.getSeconds(); document.getElementById(\"time\").innerHTML= h+\":\"+m+\":\"+s; } function showTimeIn2Seconds(){ setTimeout(printTime,2000); } &lt;/script> &lt;/head> &lt;body> &lt;div id=\"time\">&lt;/div> &lt;button onclick=\"showTimeIn2Seconds()\">点击后2秒钟后显示当前时间，并且只显示一次&lt;/button> &lt;/body> 重复执行函数setInterval(函数名, 重复执行的时间间隔毫秒数 ),通过setInterval重复执行同一个函数，重复的时间间隔由第二个参数指定 。 注意 不要在setInterval调用的函数中使用document.write()， 部分浏览器，比如firefox有这个问题，其他浏览器没这个问题。 代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>setInterval&lt;/title> &lt;/head> &lt;body> &lt;p>每隔1秒钟，打印当前时间&lt;/p> &lt;div id=\"time\">&lt;/div> &lt;script> function printTime(){ var d = new Date(); var h= d.getHours(); var m= d.getMinutes(); var s= d.getSeconds(); document.getElementById(\"time\").innerHTML= h+\":\"+m+\":\"+s; } var t = setInterval(printTime,1000); &lt;/script> &lt;br>&lt;br> &lt;/body> &lt;/html> 终止重复执行代码示例&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>clearInterval&lt;/title> &lt;/head> &lt;body> &lt;p>每隔1秒钟，打印当前时间&lt;/p> &lt;div id=\"time\">&lt;/div> &lt;script> var t = setInterval(printTime,1000); function printTime(){ var d = new Date(); var h= d.getHours(); var m= d.getMinutes(); var s= d.getSeconds(); document.getElementById(\"time\").innerHTML= h+\":\"+m+\":\"+s; if(s%5==0) clearInterval(t); } &lt;/script> &lt;br>&lt;br> &lt;/body> &lt;/html> Location对象 表示浏览器中的地址栏 。 跳转页面&lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>跳转页面&lt;/title> &lt;/head> &lt;body> &lt;div id='div1'>go&lt;/div> &lt;script type=\"text/javascript\"> div1.onclick = function(){ location.href = 'https://www.baidu.com' }; &lt;/script> &lt;/body> &lt;/html> 刷新页面&lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>刷新页面&lt;/title> &lt;/head> &lt;body> &lt;div id='div1'>go&lt;/div> &lt;script type=\"text/javascript\"> div1.onclick = function(){ location.reload(); }; &lt;/script> &lt;/body> &lt;/html> History对象 用于记录访问历史。 history.back() history.back() - 与在浏览器点击后退按钮相同 &lt;script> function goBack() { history.back(); } &lt;/script> &lt;button onclick=\"goBack()\">返回&lt;/button> history.forward() history forward() 方法加载历史列表中的下一个 URL。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;script> function goForward() { window.history.forward() } &lt;/script> &lt;/head> &lt;body> &lt;input type=\"button\" value=\"Forward\" onclick=\"goForward()\"> &lt;/body> &lt;/html> JavaScript 弹窗警告框(alert) 警告框经常用于确保用户可以得到某些信息。 &lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>警告框&lt;/title> &lt;/head> &lt;body> &lt;div id='div1'>go&lt;/div> &lt;script type=\"text/javascript\"> div1.onclick = function(){ alert(1) }; &lt;/script> &lt;/body> &lt;/html> 确认框(confirm) 确认框通常用于验证是否接受用户操作。 当确认卡弹出时，用户可以点击 “确认” 或者 “取消” 来确定用户操作。 当你点击 “确认”, 确认框返回 true， 如果点击 “取消”, 确认框返回 false。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>确认框&lt;/title> &lt;/head> &lt;body> &lt;p>点击按钮，显示确认框。&lt;/p> &lt;button onclick=\"myFunction()\">点我&lt;/button> &lt;p id=\"demo\">&lt;/p> &lt;script> function myFunction(){ var x; var r=confirm(\"按下按钮!\"); if (r==true){ x=\"你按下了\\\"确定\\\"按钮!\"; } else{ x=\"你按下了\\\"取消\\\"按钮!\"; } document.getElementById(\"demo\").innerHTML=x; } &lt;/script> &lt;/body> &lt;/html> 提示框(prompt) 提示框经常用于提示用户在进入页面前输入某个值。 当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。 如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为 null。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>提示框&lt;/title> &lt;/head> &lt;body> &lt;p>点击按钮查看输入的对话框。&lt;/p> &lt;button onclick=\"myFunction()\">点我&lt;/button> &lt;p id=\"demo\">&lt;/p> &lt;script> function myFunction(){ var x; var person=prompt(\"请输入你的名字\",\"Harry Potter\"); if (person!=null &amp;&amp; person!=\"\"){ x=\"你好 \" + person + \"! 今天感觉如何?\"; document.getElementById(\"demo\").innerHTML=x; } } &lt;/script> &lt;/body> &lt;/html> Navigator对象 即浏览器对象 ， 提供浏览器相关的信息 。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>navigator&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> document.write(\"&lt;p>浏览器产品名称：\"); document.write(navigator.appName + \"&lt;/p>\"); document.write(\"&lt;p>浏览器版本号：\"); document.write(navigator.appVersion + \"&lt;/p>\"); document.write(\"&lt;p>浏览器内部代码：\"); document.write(navigator.appCodeName + \"&lt;/p>\"); document.write(\"&lt;p>操作系统：\"); document.write(navigator.platform + \"&lt;/p>\"); document.write(\"&lt;p>是否启用Cookies：\"); document.write(navigator.cookieEnabled + \"&lt;/p>\"); document.write(\"&lt;p>浏览器的用户代理报头：\"); document.write(navigator.userAgent + \"&lt;/p>\"); &lt;/script> &lt;/body> &lt;/html> Screen对象 对象表示用户的屏幕相关信息 。 属性 作用 height 电脑的显示器的height width 电脑的现实的width availHeight 除了信息栏的高度 availWidth 除了信息栏的宽度 screenLeft/X 浏览器距离屏幕左边的距离 screenTop/Y 浏览器距离屏幕上面的距离 innerWidth/Height 浏览器内容的宽度 和 高度 outerWidth/Height 浏览器外部的宽度 和 高度 代码示例&lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>&lt;/title> &lt;/head> &lt;body> &lt;div id='div1'>&lt;/div> &lt;script type=\"text/javascript\"> setInterval(function(){ var l = screenX, t = screenY,b = screen.height - (outerHeight + t),r = screen.width - (outerWidth + l) div1.innerHTML = '浏览器距离左边的像素为' + l + ',浏览器距离上面的像素为' + t +',浏览器距离下边的像素为' + b +',浏览器距离右面的像素为' + r; },0); /* 及时显示浏览器距离左边 上面 右边 和下面的距离 screenX/left screenY/top sceen.height /window.outerHeight 下面的距离 bottom = screen.height - (window.outerHeight + screenY) right = screen.width - (window.outerWidth + screenX) */ &lt;/script> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}]},{"title":"JavaScript之闭包","slug":"前端/JavaScript/JavaScript之闭包","date":"2020-01-01T06:18:23.000Z","updated":"2020-02-24T10:32:31.553Z","comments":true,"path":"2020/01/01/qian-duan/javascript/javascript-zhi-bi-bao/","link":"","permalink":"http://yoursite.com/2020/01/01/qian-duan/javascript/javascript-zhi-bi-bao/","excerpt":"","text":"闭包定义： 子函数使用父函数变量的行为叫做闭包。 作用： 子函数可以延长父函数变量的生命周期。 可以拓展父函数的空间 特性： 在js中函数内部的局部变量只允许其子函数使用。 父函数没法使用子函数的局部变量。子函数可以使用父函数的局部变量。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>闭包&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> function a(){ //c 是局部变量 外面拿不到 var c = 10; function b(){ var f = 20; console.log(c); function d(){ console.log(c) } }; b(); console.log(f); }; a(); &lt;/script> &lt;/body> &lt;/html> 生命周期特点 当js检测不到该变量使用 那么就会杀死该变量。 如果想延长其变量的生命周期 那么就可以从新声明一个新的变量 给予之前的变量的值。 如果想让变量得到永恒 那么就把变量指向window。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>生命周期&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> window.onload = function(){ /* var a = 10; function show(){ alert(a); } */ window.c = 10; /* setTimeout(function(){ show(); },500000000); */ } setTimeout(function(){ alert(c) },100) &lt;/script> &lt;/body> &lt;/html> 回收机制产生垃圾回收原因因为程序中存在很多数据 , 这些数据在内存中占据一定的空间 。在程序运行中 ，一些没有用的数据（这些数据可以称为垃圾）还会在内存中占据空间。如果不进行垃圾回收的话，随着程序的运行，可用的内存越来越小 ，必然会带来程序性能的下降，造成卡、慢甚至系统异常。 js垃圾回收机制： jascript 具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。 原理： 垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。 方法标记清除js 中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。此时的变量在函数执行过程中一直存在，直到函数结束后，将变量标记为“离开环境”，变量就被回收了。（JavaScript 中全局变量的在浏览器卸载页面才会被销） &lt;script> function count() { var num = 0; num ++ console.log(num); } count(); // 1 cout(); // 2 &lt;/script> 定义一个函数count，函数 count 被调用了两次结果 num 都输出 1 ，说明当第一次执行之后函数里面的变量 num 会被回收。然后在第二次调用时又重新声明变量 num 并初始化为0,再进行计算输出结果 1。 引用计数（不常用）内存管理 计算机分配给 Web 浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript的网页耗尽全部系统内存而导致系统崩溃。 确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用。 &lt;script> function personObj(name) { var person = new Object(); person.name = name; return person; } var student = personObj(\"Sunshine\"); console.log(student.name); // 手动解除student的引用 student = null; &lt;/script> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}]},{"title":"CSS3转换","slug":"前端/CSS3/CSS3转换","date":"2019-12-27T13:01:55.000Z","updated":"2019-12-27T13:06:32.302Z","comments":true,"path":"2019/12/27/qian-duan/css3/css3-zhuan-huan/","link":"","permalink":"http://yoursite.com/2019/12/27/qian-duan/css3/css3-zhuan-huan/","excerpt":"","text":"CSS3 TransformCSS3的变形属性让元素在一个坐标系统中变形。这个属性包含一系列变形函数，可以移动、旋转和缩放元素。 语法transform ： none | &lt;transform-function> [ &lt;transform-function> ]*; 默认值transform: none; CSS3 2D转换旋转rotate通过指定的角度参数对原元素指定一个2D rotation（2D 旋转）。 语法transform: rotate(&lt;angle>); 参数说明angle指旋转角度，正数表示顺时针旋转，负数表示逆时针旋转。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>rotate&lt;/title> &lt;style type=\"text/css\"> * { margin: 0; padding: 0; list-style-type: none; } a, img { border: 0; } body { font: 12px/180% Arial; } .main { width: 1000px; margin: 50px auto; position: relative; } .pic { width: 300px; height: 290px; border: 1px solid #ccc; background: #fff; box-shadow: 2px 2px 3px #aaa; } .pic img { margin: 10px 0 0 8px; width: 285px; } .pic p { text-align: center; font-size: 20px; } .pic1 { -webkit-transform: rotate(7deg); -moz-transform: rotate(7deg); -ms-transform: rotate(7deg); -o-transform: rotate(7deg); transform: rotate(7deg); } .pic2 { -webkit-transform: rotate(-8deg); -moz-transform: rotate(-8deg); -ms-transform: rotate(-8deg); -o-transform: rotate(-8deg); transform: rotate(-8deg); } .pic3 { position: absolute; top: 40px; left: 350px; z-index: 2; -webkit-transform: rotate(-35deg); -moz-transform: rotate(-35deg); -ms-transform: rotate(-35deg); -o-transform: rotate(-35deg); transform: rotate(-35deg); } .pic4 { position: absolute; top: 360px; left: 350px; z-index: 3; -webkit-transform: rotate(35deg); -moz-transform: rotate(35deg); -ms-transform: rotate(35deg); -o-transform: rotate(35deg); transform: rotate(35deg); } .pic5 { position: absolute; top: 150px; left: 600px; z-index: 4; -webkit-transform: rotate(60deg); -moz-transform: rotate(60deg); -ms-transform: rotate(60deg); -o-transform: rotate(60deg); transform: rotate(60deg); } .pic6 { position: absolute; top: 180px; left: 280px; z-index: 5; -webkit-transform: rotate(-60deg); -moz-transform: rotate(-60deg); -ms-transform: rotate(-60deg); -o-transform: rotate(-60deg); transform: rotate(-60deg); } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"main\"> &lt;div class=\"pic pic1\">&lt;img src=\"images/1.jpg\">&lt;p>2D转换&lt;/p>&lt;/div> &lt;div class=\"pic pic2\">&lt;img src=\"images/2.jpg\">&lt;p>2D转换&lt;/p>&lt;/div> &lt;div class=\"pic pic3\">&lt;img src=\"images/3.jpg\">&lt;p>2D转换&lt;/p>&lt;/div> &lt;div class=\"pic pic4\">&lt;img src=\"images/4.jpg\">&lt;p>2D转换&lt;/p>&lt;/div> &lt;div class=\"pic pic5\">&lt;img src=\"images/5.jpg\">&lt;p>2D转换&lt;/p>&lt;/div> &lt;div class=\"pic pic6\">&lt;img src=\"images/6.jpg\">&lt;p>2D转换&lt;/p>&lt;/div> &lt;/div> &lt;/body> &lt;/html> 移动translatetranslate()方法，根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。 translateX通过给定一个X方向上的数目指定一个translation。 语法transform: translateX(&lt;translation-value>); 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>translateX&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: translateX(200px); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> translateY通过给定一个Y方向上的数目指定一个translation。 语法transform: translateY(&lt;translation-value>); 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>translateY&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: translateY(200px); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> translate通过矢量[tx, ty]指定一个2D translation, tx是第一个过渡值参数, ty是第二个过渡值参数选项。 语法transform: translate(&lt;translation-value>[, &lt;translation-value>]); 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>translate&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: translate(200px, 100px); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> 缩放scalescale()方法，指定对象的2D scale（2D缩放)。 scaleX使用 [sx, 1] 缩放矢量执行缩放操作，sx为所需参数。 语法transform: scaleX(&lt;number>); 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>scaleX&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: scaleX(.5); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> scaleY使用 [1, sy] 缩放矢量执行缩放操作，sy为所需参数。 语法transform: scaleY(&lt;number>); 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>scaleY&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: scaleY(.5); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> scale提供执行[sx,sy]缩放矢量的两个参数指定一个2D scale（2D缩放）。 语法transform: scale(&lt;number>[, &lt;number>]); 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>scale&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: scale(.5, .5); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> 扭曲skewskew()方法，指定对象skew transformation（斜切扭曲）。 skewX按给定的角度沿X轴指定一个skew transformation（斜切变换）。 语法transform: skewX(&lt;angle>); 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>skewX&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: skewX(15deg); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> skewY按给定的角度沿Y轴指定一个skew transformation（斜切变换）。 语法transform: skewY(&lt;angle>); 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>skewY&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: skewY(15deg); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> skewX轴Y轴上的skew transformation（斜切变换）。第一个参数对应X轴，第二个参数对应Y轴。 语法transform: skew(&lt;angle> [, &lt;angle>]); 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>skew&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: skew(15deg, 15deg); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> CSS3 3D转换旋转rotateXrotateX方法指定对象在x轴上的旋转角度。 语法transform: rotateX(angle); 参数说明 angle表示旋转的角度。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>rotateX&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: rotateX(45deg); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> 旋转rotateYrotateY方法指定对象在y轴上的旋转角度。 语法transform: rotateY(angle); 参数说明angle表示旋转的角度。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>rotateY&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: rotateY(45deg); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> 旋转rotateZrotateZ方法指定对象在z轴上的旋转角度。 语法transform: rotateZ(angle); 参数说明angle表示旋转的角度。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>rotateZ&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: rotateZ(45deg); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> 旋转rotate3drotate3d方法指定对象的3D旋转角度。 语法transform: rotate3d(x, y, z, angle); 参数说明前3个参数分别表示旋转的方向x,y,z，第4个参数表示旋转的角度，参数不允许省略。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>rotate3d&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: rotate3d(1, 1, 1, 45deg); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> 移动translateZtranslateZ方法指定对象Z轴的平移。 语法transform: translateZ(z); 参数说明参数对应Z轴，不允许省略。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>translateZ&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: translateZ(200px); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> 移动translate3dtranslate3d方法指定对象的3D位移。 语法transform: translate3d(x, y, z); 参数说明 第1个参数对应X轴，第2个参数对应Y轴，第3个参数对应Z轴，参数不允许省略。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>translate3d&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: translate3d(200px, 200px, 200px); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> 缩放scaleZscaleZ方法指定对象的z轴缩放。 语法transform: scaleZ(z); 参数说明 参数对应Z轴，不允许省略。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>scaleZ&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: scaleZ(.5); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> 缩放scale3dscale3d方法指定对象的3D缩放。 语法transform: scale3d(x, y, z); 参数说明第1个参数对应X轴，第2个参数对应Y轴，第3个参数对应Z轴，参数不允许省略。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>scale3d&lt;/title> &lt;style type=\"text/css\"> div { width: 1500px; height: 250px; background: #abcdef; margin: auto; } div > img { transform: scale3d(.5, .5, .5); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;img src=\"images/sprite.jpg\">&lt;/div> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}],"keywords":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}]},{"title":"CSS3文本效果","slug":"前端/CSS3/CSS3文本效果","date":"2019-12-27T13:01:37.000Z","updated":"2019-12-27T13:06:02.238Z","comments":true,"path":"2019/12/27/qian-duan/css3/css3-wen-ben-xiao-guo/","link":"","permalink":"http://yoursite.com/2019/12/27/qian-duan/css3/css3-wen-ben-xiao-guo/","excerpt":"","text":"CSS3 文本阴影text-shadow 属性text-shadow 属性应用于阴影文本 语法text-shadow: h-shadow v-shadow blur color; 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>text-shadow&lt;/title> &lt;style type=\"text/css\"> h1 { text-shadow: 5px 5px 5px red; } &lt;/style> &lt;/head> &lt;body> &lt;h1>lesson1 text-shadow&lt;/h1> &lt;/body> &lt;/html> CSS3 换行word-break 属性word-break 属性规定自动换行的处理方法 语法word-break: normal|break-all|keep-all; 代码示例 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>word-break&lt;/title> &lt;style type=\"text/css\"> h1 { width: 800px; margin: 10px auto; background: #abcdef; } h1:nth-child(1) { word-break: normal; } h1:nth-child(2) { word-break: break-all; } h1:nth-child(3) { word-break: keep-all; } h1:nth-child(4) { word-break: normal; } h1:nth-child(5) { word-break: break-all; } h1:nth-child(6) { word-break: keep-all; } h1 > span { color: red; } &lt;/style> &lt;/head> &lt;body> &lt;h1>&lt;span>word-break: normal;&lt;/span>&lt;br>Youth is not a time of life; it is a state of mind; it is not a matter of rosy cheeks, red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions; it is the freshness of the deep springs of life.&lt;/h1> &lt;h1>&lt;span>word-break: break-all;&lt;/span>&lt;br>Youth is not a time of life; it is a state of mind; it is not a matter of rosy cheeks, red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions; it is the freshness of the deep springs of life.&lt;/h1> &lt;h1>&lt;span>word-break: keep-all;&lt;/span>&lt;br>Youth is not a time of life; it is a state of mind; it is not a matter of rosy cheeks, red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions; it is the freshness of the deep springs of life.&lt;/h1> &lt;h1>&lt;span>word-break: normal;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>word-break: break-all;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>word-break: keep-all;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;/body> &lt;/html> word-wrap 属性word-wrap 属性允许长单词或 URL 地址换行到下一行 语法word-wrap: normal|break-word; 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>word-wrap&lt;/title> &lt;style type=\"text/css\"> h1 { width: 800px; margin: 10px auto; background: #abcdef; } h1:nth-child(1) { word-wrap: normal; } h1:nth-child(2) { word-wrap: break-word; } h1:nth-child(3) { word-wrap: normal; } h1:nth-child(4) { word-wrap: break-word; } h1 > span { color: red; } &lt;/style> &lt;/head> &lt;body> &lt;h1>&lt;span>word-wrap: normal;&lt;/span>&lt;br>bababadalgharaghtakamminarronnkonnbronntonnerronntuonnthunntrovarrhounawnskawntoohoohoordenenthurnuk&lt;/h1> &lt;h1>&lt;span>word-wrap: break-word;&lt;/span>&lt;br>bababadalgharaghtakamminarronnkonnbronntonnerronntuonnthunntrovarrhounawnskawntoohoohoordenenthurnuk&lt;/h1> &lt;h1>&lt;span>word-wrap: normal;&lt;/span>&lt;br>这个字是由100个字母组成的。就出现在爱尔兰作家乔埃斯(James Joyce 1882-1942)作品《芬尼根守灵夜》(Finnegans Wake)的扉页，象征代表亚当和夏娃。（http://www.bababadalgharaghtakamminarronnkonnbronntonnerronntuonnthunntrovarrhounawnskawntoohoohoordenenthurnuk.com）&lt;/h1> &lt;h1>&lt;span>word-wrap: break-word;&lt;/span>&lt;br>这个字是由100个字母组成的。就出现在爱尔兰作家乔埃斯(James Joyce 1882-1942)作品《芬尼根守灵夜》(Finnegans Wake)的扉页，象征代表亚当和夏娃。（http://www.bababadalgharaghtakamminarronnkonnbronntonnerronntuonnthunntrovarrhounawnskawntoohoohoordenenthurnuk.com）&lt;/h1> &lt;/body> &lt;/html> CSS3 新文本属性text-align-last 属性text-align-last 属性规定如何对齐文本的最后一行 语法text-align-last: auto|left|right|center|justify|start|end|initial|inherit; text-emphasis 属性向元素的文本应用重点标记以及重点标记的前景色 语法text-emphasis: text-emphasis-style text-emphasis-color; 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>text-align-last&lt;/title> &lt;style type=\"text/css\"> h1 { width: 700px; margin: 10px auto; background: #abcdef; } h1:nth-child(1) { text-align-last: auto; } h1:nth-child(2) { text-align-last: left; } h1:nth-child(3) { text-align-last: right; } h1:nth-child(4) { text-align-last: center; } h1:nth-child(5) { text-align-last: justify; } h1:nth-child(6) { text-align-last: start; } h1:nth-child(7) { text-align-last: end; } h1:nth-child(8) { text-align-last: initial; } h1:nth-child(9) { text-align-last: inherit; } h1 > span { color: red; } &lt;/style> &lt;/head> &lt;body> &lt;h1>&lt;span>text-align-last: auto;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>text-align-last: left;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>text-align-last: right;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>text-align-last: center;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>text-align-last: justify;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>text-align-last: start;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>text-align-last: end;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>text-align-last: initial;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>text-align-last: inherit;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;/body> &lt;/html> text-justify 属性text-justify 属性规定当 text-align 被设置为 justify 时的齐行方法 语法text-justify: auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|trim; 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>text-justify&lt;/title> &lt;style type=\"text/css\"> h1 { width: 700px; margin: 10px auto; background: #abcdef; text-align: justify; } h1:nth-child(1) { text-justify: auto; } h1:nth-child(2) { text-justify: inter-word; } h1:nth-child(3) { text-justify: inter-ideograph; } h1:nth-child(4) { text-justify: inter-cluster; } h1:nth-child(5) { text-justify: distribute; } h1:nth-child(6) { text-justify: kashida; } h1:nth-child(7) { text-justify: trim; } h1 > span { color: red; } &lt;/style> &lt;/head> &lt;body> &lt;h1>&lt;span>text-justify: auto;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>text-justify: inter-word;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>text-justify: inter-ideograph;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>text-justify: inter-cluster;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>text-justify: distribute;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>text-justify: kashida;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;h1>&lt;span>text-justify: trim;&lt;/span>&lt;br>将梦想悬挂于枝头，在夏季的丰盛中饱满，绽放；为梦想披星戴月，刷新生命的温度。&lt;br>那些因梦想蜕变了的灵魂，历经时光坎坷，痛苦挣扎，依然在枝头放歌，温暖了生命如花的影子。&lt;br>前世，储蓄梦想；今生，演绎铿锵。&lt;/h1> &lt;/body> &lt;/html> text-overflow 属性text-overflow 属性规定当文本溢出包含元素时发生的事情 语法text-overflow: clip|ellipsis|string; 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>text-overflow&lt;/title> &lt;style type=\"text/css\"> h1 { width: 700px; margin: 10px auto; background: #abcdef; overflow: hidden; } h1:nth-child(1) { text-overflow: clip; } h1:nth-child(2) { text-overflow: ellipsis; } h1:nth-child(3) { text-overflow: '>>'; } h1 > span { color: red; } &lt;/style> &lt;/head> &lt;body> &lt;h1>&lt;span>text-overflow: clip;&lt;/span>&lt;br>bababadalgharaghtakamminarronnkonnbronntonnerronntuonnthunntrovarrhounawnskawntoohoohoordenenthurnuk&lt;/h1> &lt;h1>&lt;span>text-overflow: ellipsis;&lt;/span>&lt;br>bababadalgharaghtakamminarronnkonnbronntonnerronntuonnthunntrovarrhounawnskawntoohoohoordenenthurnuk&lt;/h1> &lt;h1>&lt;span>text-overflow: '>>';&lt;/span>&lt;br>bababadalgharaghtakamminarronnkonnbronntonnerronntuonnthunntrovarrhounawnskawntoohoohoordenenthurnuk&lt;/h1> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}],"keywords":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}]},{"title":"CSS3伪元素","slug":"前端/CSS3/CSS3伪元素","date":"2019-12-27T13:01:21.000Z","updated":"2019-12-27T13:05:50.691Z","comments":true,"path":"2019/12/27/qian-duan/css3/css3-wei-yuan-su/","link":"","permalink":"http://yoursite.com/2019/12/27/qian-duan/css3/css3-wei-yuan-su/","excerpt":"","text":"伪元素CSS 伪元素用于向某些选择器设置特殊效果。 语法元素::伪元素 （Element::pseudo-element） first-line属性根据 “first-line” 伪元素中的样式对 Element 元素的第一行文本进行格式化。 注意： “first-line” 伪元素只能用于块级元素。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>First-Line&lt;/title> &lt;style type=\"text/css\"> div { width: 500px; margin: 0 auto; } div::first-line { color: #f00; font-weight: bold; } &lt;/style> &lt;/head> &lt;body> &lt;div> 大家好，欢迎学习CSS3！大家好，欢迎学习CSS3！大家好，欢迎学习CSS3！大家好，欢迎学习CSS3！大家好， 欢迎学习CSS3！大家好，欢迎学习CSS3！大家好，欢迎学习CSS3！大家好，欢迎学习CSS3！大家好，欢迎 学习CSS3！大家好，欢迎学习CSS3！大家好，欢迎学习CSS3！大家好，欢迎学习CSS3！ &lt;/div> &lt;/body> &lt;/html> first-letter属性用于向文本的首字母设置特殊样式。 注意 first-letter伪元素只能用于块级元素。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>First-Letter&lt;/title> &lt;style type=\"text/css\"> div { width: 500px; margin: 0 auto; font-size: 12px; } div::first-letter { color: #f00; font-size: 24px; font-weight: bold; } &lt;/style> &lt;/head> &lt;body> &lt;div> 大家好，欢迎学习CSS3！大家好，欢迎学习CSS3！大家好，欢迎学习CSS3！大家好，欢迎学习CSS3！大家好， 欢迎学习CSS3！大家好，欢迎学习CSS3！大家好，欢迎学习CSS3！大家好，欢迎学习CSS3！大家好，欢迎 学习CSS3！大家好，欢迎学习CSS3！大家好，欢迎学习CSS3！大家好，欢迎学习CSS3！ &lt;/div> &lt;/body> &lt;/html> before属性在元素的内容前面插入新内容。 注意： 常用”content”配合使用 特点： 第一个子元素 行级元素 内容通过content写入 标签中找不到对应的标签 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>before&lt;/title> &lt;style type=\"text/css\"> div { width: 300px; height: 100px; border: 1px solid #000; } div::before { content: \"我在内容的前面\"; } &lt;/style> &lt;/head> &lt;body> &lt;div>伪元素&lt;/div> &lt;/body> &lt;/html> after属性在元素的内容后面插入新内容。 注意 常用“content”配合使用，多用于清除浮动。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>after&lt;/title> &lt;style type=\"text/css\"> div { width: 300px; height: 100px; border: 1px solid #000; } div::after { content: \"我在内容的后面\"; } &lt;/style> &lt;/head> &lt;body> &lt;div>伪元素&lt;/div> &lt;/body> &lt;/html> selection属性用于设置在浏览器中选中文本后的背景色与前景色。 注意 ::selection在IE家族中，只有IE9+版本支持，在Firefox中需要加上其前缀“-moz”。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Selection&lt;/title> &lt;style type=\"text/css\"> div::selection { background: red; color: #ff0; } &lt;/style> &lt;/head> &lt;body> &lt;div> SelectionSelectionSelectionSelectionSelectionSelectionSelectionSelectionSelection &lt;/div> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}],"keywords":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}]},{"title":"CSS3属性选择器","slug":"前端/CSS3/CSS3属性选择器","date":"2019-12-27T13:01:03.000Z","updated":"2019-12-27T13:05:35.041Z","comments":true,"path":"2019/12/27/qian-duan/css3/css3-shu-xing-xuan-ze-qi/","link":"","permalink":"http://yoursite.com/2019/12/27/qian-duan/css3/css3-shu-xing-xuan-ze-qi/","excerpt":"","text":"属性选择器 对带有指定属性的HTML 元素设置样式 使用CSS3属性选择器，你可以只指定元素的某个属性，或者你还可以同时指定元素的某个属性和其对应的属性值。 Element[attribute]选择所有带有attribute属性元素 Element[attribute=“value”]选择所有使用attribute=\"value\"的元素 Element[attribute~=“value”]选择 attribute 属性包含单词 \"value\" 的元素 Element[attribute^=“value”]选择 attribute 属性值以 \"value\" 开头的所有元素 Element[attribute$=“value”]选择attribute 属性值以 \"value\" 结尾的所有元素 Element[attribute*=“value”]选择attribute 属性值包含 \"value\" 的所有元素 Element[attribute|=“value”]选择 attribute 属性值为 \"value”或以 \"value-\" 开头的元素 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Attribute&lt;/title> &lt;style type=\"text/css\"> a[href] { text-decoration: none; } a[href=\"#\"] { color: #f00; } a[class~=\"two\"] { color: #ff0; } a[href^=\"#\"] { color: #0f0; } a[href$=\"#\"] { color: #00f; } a[href*=\"#\"] { color: #0ff; } a[href|=\"#\"] { color: #f0f; } &lt;/style> &lt;/head> &lt;body> &lt;a href=\"attribute.html\">attribute&lt;/a> &lt;a href=\"#\">attribute&lt;/a> &lt;a class=\"one two\" href=\"#\">attribute&lt;/a> &lt;a class=\"two three\" href=\"#\">attribute&lt;/a> &lt;a href=\"#1\">attribute&lt;/a> &lt;a href=\"#2\">attribute&lt;/a> &lt;a href=\"#3\">attribute&lt;/a> &lt;a href=\"#4\">attribute&lt;/a> &lt;a href=\"1#\">attribute&lt;/a> &lt;a href=\"2#\">attribute&lt;/a> &lt;a href=\"3#\">attribute&lt;/a> &lt;a href=\"4#\">attribute&lt;/a> &lt;a href=\"1#1\">attribute&lt;/a> &lt;a href=\"2#2\">attribute&lt;/a> &lt;a href=\"3#3\">attribute&lt;/a> &lt;a href=\"4#4\">attribute&lt;/a> &lt;a href=\"#-1\">attribute&lt;/a> &lt;a href=\"#-2\">attribute&lt;/a> &lt;a href=\"#-3\">attribute&lt;/a> &lt;a href=\"#-4\">attribute&lt;/a> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}],"keywords":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}]},{"title":"CSS3结构类选择器","slug":"前端/CSS3/CSS3结构类选择器","date":"2019-12-27T13:00:28.000Z","updated":"2019-12-27T13:05:20.873Z","comments":true,"path":"2019/12/27/qian-duan/css3/css3-jie-gou-lei-xuan-ze-qi/","link":"","permalink":"http://yoursite.com/2019/12/27/qian-duan/css3/css3-jie-gou-lei-xuan-ze-qi/","excerpt":"","text":"UI元素状态伪类定义 “:enabled”,”:disabled”,”:checked”伪类称为UI元素状态伪类。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>UI元素状态伪类&lt;/title> &lt;style type=\"text/css\"> input{ width: 200px; height: 30px; } input:enabled{ border: 1px solid #f00; } input:disabled{ background: #abcdef; border: 1px solid #ff0; } &lt;/style> &lt;/head> &lt;body> &lt;input type=\"text\" disabled=\"disabled\"> &lt;input type=\"text\"> &lt;input type=\"text\"> &lt;input type=\"text\"> &lt;/body> &lt;/html> CSS3结构类CSS3的:nth选择器也成为CSS3结构类。 选择方法:first-child、:last-child、:nth-child()、:nth-last-child()、:nth-of-type()、 :nth-last-of-type()、:first-of-type、:last-of-type、:only-child、:only-of-type、:empty first-child属性选择属于其父元素的首个子元素的每个 Element 元素。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>First-Child&lt;/title> &lt;style type=\"text/css\"> section > div:first-child { color: #f00; } &lt;/style> &lt;/head> &lt;body> &lt;div>0-1&lt;/div> &lt;div>0-2&lt;/div> &lt;div>0-3&lt;/div> &lt;section> &lt;div>1-1&lt;/div> &lt;div>1-2&lt;/div> &lt;div>1-3&lt;/div> &lt;/section> &lt;section> &lt;div>2-1&lt;/div> &lt;div>2-2&lt;/div> &lt;div>2-3&lt;/div> &lt;/section> &lt;/body> &lt;/html> last-child属性指定属于其父元素的最后一个子元素的 Element 元素 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Last-Child&lt;/title> &lt;style type=\"text/css\"> div:last-child { color: #f00; } &lt;/style> &lt;/head> &lt;body> &lt;div>0-1&lt;/div> &lt;div>0-2&lt;/div> &lt;div>0-3&lt;/div> &lt;section> &lt;div>1-1&lt;/div> &lt;div>1-2&lt;/div> &lt;div>1-3&lt;/div> &lt;/section> &lt;section> &lt;div>2-1&lt;/div> &lt;div>2-2&lt;/div> &lt;div>2-3&lt;/div> &lt;/section> &lt;/body> &lt;/html> nth-child(N)属性:nth-child(N) 选择器匹配属于其父元素的第 N 个子元素，不论元素的类型 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>nth-Child&lt;/title> &lt;style type=\"text/css\"> ul > li:nth-child(3) { background: #f00; } div:nth-child(2) { color: #f00; } &lt;/style> &lt;/head> &lt;body> &lt;ul> &lt;li>1&lt;/li> &lt;li>2&lt;/li> &lt;li>3&lt;/li> &lt;li>4&lt;/li> &lt;/ul> &lt;hr> &lt;div>0-1&lt;/div> &lt;div>0-2&lt;/div> &lt;div>0-3&lt;/div> &lt;section> &lt;div>1-1&lt;/div> &lt;div>1-2&lt;/div> &lt;div>1-3&lt;/div> &lt;/section> &lt;section> &lt;div>2-1&lt;/div> &lt;div>2-2&lt;/div> &lt;div>2-3&lt;/div> &lt;/section> &lt;/body> &lt;/html> 关于参数(N)Element:nth-child(number) - 选择某元素下的第number个Element元素。 Element:nth-child(n) - n是一个简单表达式，取值从“0”开始计算。这里只能是“n”，不能用其他字母代替。 Element:nth-child(odd)、Element:nth-child(even) - odd和even是可用于匹配下标是奇数或偶数的Element元素的关键词（第一个的下标是1) nth-last-child(N)属性匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>nth-Child&lt;/title> &lt;style type=\"text/css\"> ul > li:nth-last-child(3) { background: #f00; } &lt;/style> &lt;/head> &lt;body> &lt;ul> &lt;li>1&lt;/li> &lt;li>2&lt;/li> &lt;li>3&lt;/li> &lt;li>4&lt;/li> &lt;/ul> &lt;hr> &lt;div>0-1&lt;/div> &lt;div>0-2&lt;/div> &lt;div>0-3&lt;/div> &lt;section> &lt;div>1-1&lt;/div> &lt;div>1-2&lt;/div> &lt;div>1-3&lt;/div> &lt;/section> &lt;section> &lt;div>2-1&lt;/div> &lt;div>2-2&lt;/div> &lt;div>2-3&lt;/div> &lt;/section> &lt;hr> &lt;ul> &lt;li>1&lt;/li> &lt;li>2&lt;/li> &lt;li>3&lt;/li> &lt;li>4&lt;/li> &lt;/ul> &lt;/body> &lt;/html> nth-of-type(N)属性:nth-of-type(N)选择器匹配属于父元素的特定类型的第 N 个子元素的每个元素。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>nth-of-type&lt;/title> &lt;style type=\"text/css\"> /*div:nth-child(2) { color: #f00; }*/ div:nth-of-type(2) { color: #f00; } &lt;/style> &lt;/head> &lt;body> &lt;div>0-1&lt;/div> &lt;section> &lt;div>1-1&lt;/div> &lt;div>1-2&lt;/div> &lt;div>1-3&lt;/div> &lt;/section> &lt;div>0-2&lt;/div> &lt;div>0-3&lt;/div> &lt;section> &lt;div>2-1&lt;/div> &lt;div>2-2&lt;/div> &lt;div>2-3&lt;/div> &lt;/section> &lt;/body> &lt;/html> nth-last-of-type(N)属性匹配属于父元素的特定类型的第 N 个子元素的每个元素，从最后一个子元素开始计数。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>nth-Last-of-type&lt;/title> &lt;style type=\"text/css\"> /*div:nth-last-child(2) { color: #f00; }*/ div:nth-last-of-type(2) { color: #f00; } &lt;/style> &lt;/head> &lt;body> &lt;div>0-1&lt;/div> &lt;section> &lt;div>1-1&lt;/div> &lt;div>1-2&lt;/div> &lt;div>1-3&lt;/div> &lt;/section> &lt;div>0-2&lt;/div> &lt;div>0-3&lt;/div> &lt;section> &lt;div>2-1&lt;/div> &lt;div>2-2&lt;/div> &lt;div>2-3&lt;/div> &lt;/section> &lt;/body> &lt;/html> 区别nth-last-of-type(n) 指定元素类型 nth-last-child(n) 不限制元素类型 first-of-type属性:first-of-type 选择器匹配属于其父元素的特定类型的首个子元素的每个元素。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>First-of-type&lt;/title> &lt;style type=\"text/css\"> div:first-of-type { color: #f00; } &lt;/style> &lt;/head> &lt;body> &lt;div>0-1&lt;/div> &lt;section> &lt;div>1-1&lt;/div> &lt;div>1-2&lt;/div> &lt;div>1-3&lt;/div> &lt;/section> &lt;div>0-2&lt;/div> &lt;div>0-3&lt;/div> &lt;section> &lt;div>2-1&lt;/div> &lt;div>2-2&lt;/div> &lt;div>2-3&lt;/div> &lt;/section> &lt;/body> &lt;/html> last-of-type属性:last-of-type 选择器匹配属于其父元素的特定类型的最后一个子元素的每个元素 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Last-of-type&lt;/title> &lt;style type=\"text/css\"> div:last-of-type { color: #f00; } &lt;/style> &lt;/head> &lt;body> &lt;div>0-1&lt;/div> &lt;section> &lt;div>1-1&lt;/div> &lt;div>1-2&lt;/div> &lt;div>1-3&lt;/div> &lt;/section> &lt;div>0-2&lt;/div> &lt;div>0-3&lt;/div> &lt;section> &lt;div>2-1&lt;/div> &lt;div>2-2&lt;/div> &lt;div>2-3&lt;/div> &lt;/section> &lt;/body> &lt;/html> only-child属性:only-child 选择器匹配属于其父元素的唯一子元素的每个元素。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>only-child&lt;/title> &lt;style type=\"text/css\"> article:only-child { background: #f00; } &lt;/style> &lt;/head> &lt;body> &lt;section> &lt;article>1&lt;/article> &lt;article>2&lt;/article> &lt;/section> &lt;section> &lt;article>3&lt;/article> &lt;/section> &lt;section> &lt;div>4&lt;/div> &lt;article>5&lt;/article> &lt;div>6&lt;/div> &lt;/section> &lt;/body> &lt;/html> only-of-type属性:only-of-type 选择器匹配属于其父元素的特定类型的唯一子元素的每个元素。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>only-of-type&lt;/title> &lt;style type=\"text/css\"> article:only-of-type { background: #f00; } &lt;/style> &lt;/head> &lt;body> &lt;section> &lt;article>1&lt;/article> &lt;article>2&lt;/article> &lt;/section> &lt;section> &lt;article>3&lt;/article> &lt;/section> &lt;section> &lt;div>4&lt;/div> &lt;article>5&lt;/article> &lt;div>6&lt;/div> &lt;/section> &lt;section> &lt;div>7&lt;/div> &lt;article>8&lt;/article> &lt;article>9&lt;/article> &lt;div>10&lt;/div> &lt;/section> &lt;/body> &lt;/html> empty属性:empty 选择器匹配没有子元素（包括文本节点）的每个元素。 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>empty&lt;/title> &lt;style type=\"text/css\"> div { height: 200px; background: #abcdef; } div:empty { background: #f00; } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;div>Second&lt;/div> &lt;div>&lt;/div> &lt;div>Third&lt;/div> &lt;/body> &lt;/html> 否定选择器（:not）:not(Element/selector) 选择器匹配非指定元素/选择器的每个元素。 语法父元素:not(子元素/子选择器) （Father:not(Children/selector)） 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>not&lt;/title> &lt;style type=\"text/css\"> * { margin: 0; padding: 0; border: none; } a { text-decoration: none; color: #333; font-size: 14px; display: block; float: left; width: 100px; height: 30px; } nav { width: 800px; margin: 0 auto; } nav > a:not(:last-of-type) { border-right: 1px solid red; } &lt;/style> &lt;/head> &lt;body> &lt;nav> &lt;a href=\"#\">first&lt;/a> &lt;a href=\"#\">second&lt;/a> &lt;a href=\"#\">third&lt;/a> &lt;a href=\"#\">fourth&lt;/a> &lt;a href=\"#\">fifth&lt;/a> &lt;/nav> &lt;/body> &lt;/html> CSS权重什么是权重 当很多的规则被应用到某一个元素上时，权重是一个决定哪种规则生效，或者是优先级的过程。 权重等级与权值 行内样式(1000)&gt;ID选择器(100)&gt;类、属性选择器和伪类选择器(10)&gt; 元素和伪元素(1) &gt;*(0)。 权重计算口诀 从0开始，一个行内样式+1000，一个id+100，一个属性选择器、class或者伪类+10，一个元素名或者伪元素+1。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}],"keywords":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}]},{"title":"CSS3基本选择器","slug":"前端/CSS3/CSS3基本选择器","date":"2019-12-27T13:00:05.000Z","updated":"2019-12-27T13:05:03.607Z","comments":true,"path":"2019/12/27/qian-duan/css3/css3-ji-ben-xuan-ze-qi/","link":"","permalink":"http://yoursite.com/2019/12/27/qian-duan/css3/css3-ji-ben-xuan-ze-qi/","excerpt":"","text":"基本选择器 符选择器、元素选择器、类选择器、ID选择器、后代选择器 新增基本选择器子元素选择器、相邻兄弟元素选择器、通用兄弟选择器、群组选择器 子元素选择器子元素选择器只能选择某元素的子元素。 语法父元素 > 子元素 （Father > Children） 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>子元素选择器&lt;/title> &lt;style type=\"text/css\"> section > div { color: #f00; } &lt;/style> &lt;/head> &lt;body> &lt;section> &lt;article> &lt;div>article里面的文字&lt;/div> &lt;/article> &lt;div>article外面的文字&lt;/div> &lt;/section> &lt;/body> &lt;/html> 相邻兄弟元素选择器相邻兄弟选择器可以选择紧接在另一元素后的元素，而且他们具有一个相同的父元素 语法元素 + 兄弟相邻元素 （Eelement + Sibling） 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>兄弟元素选择器&lt;/title> &lt;style type=\"text/css\"> section > div + article { color: #f00; } &lt;/style> &lt;/head> &lt;body> &lt;section> &lt;div>article外面的文字&lt;/div> &lt;article> &lt;div>article里面的文字&lt;/div> &lt;/article> &lt;article> &lt;div>article里面的文字&lt;/div> &lt;/article> &lt;/section> &lt;/body> &lt;/html> 通用兄弟选择器选择某元素后面的所有兄弟元素，而且他们具有一个相同的父元素 语法元素 ~ 后面所有兄弟相邻元素 （Eelement ~ Siblings） 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>通用兄弟选择器&lt;/title> &lt;style type=\"text/css\"> section > div ~ article { color: #f00; } &lt;/style> &lt;/head> &lt;body> &lt;section> &lt;article> &lt;div>article里面的文字&lt;/div> &lt;/article> &lt;div>article外面的文字&lt;/div> &lt;article> &lt;div>article里面的文字&lt;/div> &lt;/article> &lt;article> &lt;div>article里面的文字&lt;/div> &lt;/article> &lt;article> &lt;div>article里面的文字&lt;/div> &lt;/article> &lt;article> &lt;div>article里面的文字&lt;/div> &lt;/article> &lt;article> &lt;div>article里面的文字&lt;/div> &lt;/article> &lt;/section> &lt;/body> &lt;/html> 群组选择器群组选择器是将具有相同样式的元素分组在一起，每个选择器之间使用逗号“，“进行隔开。 语法元素1, 元素2, …, 元素n （Eelement1, Element2, …, Elementn） 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>群组选择器&lt;/title> &lt;style type=\"text/css\"> section > article, section > aside, section > div { color: #f00; margin-top: 10px; background: #abcdef; } &lt;/style> &lt;/head> &lt;body> &lt;section> &lt;article>article&lt;/article> &lt;aside>aside&lt;/aside> &lt;div>div&lt;/div> &lt;/section> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}],"keywords":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}]},{"title":"CSS3边框与圆角","slug":"前端/CSS3/CSS3边框与圆角","date":"2019-12-27T12:59:48.000Z","updated":"2019-12-27T13:04:48.915Z","comments":true,"path":"2019/12/27/qian-duan/css3/css3-bian-kuang-yu-yuan-jiao/","link":"","permalink":"http://yoursite.com/2019/12/27/qian-duan/css3/css3-bian-kuang-yu-yuan-jiao/","excerpt":"","text":"CSS3 圆角border-radius 属性一个最多可指定四个border -*- radius属性的复合属性，这个属性允许你为元素添加圆角边框。 语法border-radius: 1-4 length|% / 1-4 length|%; 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>border&lt;/title> &lt;style type=\"text/css\"> div { width: 800px; height: 300px; border: 5px solid red; margin: 0 auto; border-radius: 50%; } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;/body> &lt;/html> CSS3 盒阴影box-shadow 属性box-shadow属性可以设置一个或多个下拉阴影的框 语法box-shadow: h-shadow v-shadow blur spread color inset; 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>BoxShadow&lt;/title> &lt;style type=\"text/css\"> div { width: 800px; height: 300px; background: red; margin: 0 auto; box-shadow: 50px 30px 0px 0px yellow; } &lt;/style> &lt;/head> &lt;body> &lt;div>大家好！欢迎来到CSS3的世界&lt;/div> &lt;/body> &lt;/html> CSS3 边界图片border-image-source 属性border-image-source属性指定要使用的图像，而不是由border-style属性设置的边框样式。 语法border-image-source: none|image; border-image-slice 属性border-image -slice属性指定图像的边界向内偏移。 语法border-image-slice: number|%|fill; border-image-width 属性border-image -width属性指定图像边界的宽度 语法border-image-width: number|%|auto; border-image-outset 属性border-image-outset用于指定在边框外部绘制 border-image-area 的量 语法border-image-outset: length|number; border-image-repeat 属性该属性用于图像边界是否应重复（repeated）、拉伸（stretched）或铺满（rounded） 语法border-image-repeat: stretch|repeat|round|initial|inherit; 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Border Image&lt;/title> &lt;style type=\"text/css\"> div { width: 853px; height: 392px; border-image-source: url(\"border.jpg\"); border-image-slice: 50%; border-image-width: 50%; border-image-outset: 2; border-image-repeat: repeat; } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}],"keywords":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}]},{"title":"CSS3背景","slug":"前端/CSS3/CSS3背景","date":"2019-12-27T12:59:29.000Z","updated":"2019-12-27T13:04:35.666Z","comments":true,"path":"2019/12/27/qian-duan/css3/css3-bei-jing/","link":"","permalink":"http://yoursite.com/2019/12/27/qian-duan/css3/css3-bei-jing/","excerpt":"","text":"CSS3 背景图像区域background-clip 属性background-clip属性指定背景绘制区域 语法 background-clip: border-box|padding-box|content-box; 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Clip&lt;/title> &lt;style type=\"text/css\"> * { margin: 0; padding: 0; border: none; } div { width: 800px; height: 400px; padding: 50px; border: 50px solid transparent; background: url('bg1.jpg') no-repeat center center; background-clip: border-box; background-clip: padding-box; background-clip: content-box; } span.div_border { position: absolute; top: 0; left: 0; width: 800px; height: 400px; padding: 50px; border: 50px solid rgba(255, 0, 0, .25); } span.div_padding { position: absolute; top: 50px; left: 50px; width: 800px; height: 400px; border: 50px solid rgba(255, 255, 0, .25); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;span class=\"div_border\">&lt;/span> &lt;span class=\"div_padding\">&lt;/span> &lt;/body> &lt;/html> CSS3 背景图像定位background-origin属性background-origin属性指定background-position属性应该是相对位置 语法 background-origin: padding-box|border-box|content-box; 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Clip&lt;/title> &lt;style type=\"text/css\"> * { margin: 0; padding: 0; border: none; } div { width: 800px; height: 400px; padding: 50px; border: 50px solid transparent; background: url('bg1.jpg') no-repeat 50px 100px; background-origin: border-box; background-origin: padding-box; background-origin: content-box; } span.div_border { position: absolute; top: 0; left: 0; width: 800px; height: 400px; padding: 50px; border: 50px solid rgba(255, 0, 0, .25); } span.div_padding { position: absolute; top: 50px; left: 50px; width: 800px; height: 400px; border: 50px solid rgba(255, 255, 0, .25); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;span class=\"div_border\">&lt;/span> &lt;span class=\"div_padding\">&lt;/span> &lt;/body> &lt;/html> CSS3 背景图像大小background-size属性background-size属性指定背景图片大小 语法 background-size: length|percentage|cover|contain; 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Size&lt;/title> &lt;style type=\"text/css\"> div { width: 800px; height: 500px; background: url(\"bg1.jpg\") no-repeat; background-size: contain; background-size: cover; background-size: 800px 500px; background-size: 800px; background-size: 50% 50%; background-size: 50%; background-size: 100% 100%; background-size: 100%; } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;/body> &lt;/html> CSS3 多重背景图像CSS3 允许为元素使用多个背景图像 语法 background-image: url(img1.jpg), url(img2.png); 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Size&lt;/title> &lt;style type=\"text/css\"> div { width: 800px; height: 500px; background-image: url('bg2.png'), url('bg1.jpg'); background-image: url('bg1.jpg'), url('bg2.png'); } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}],"keywords":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}]},{"title":"HTML5新增与删除标签","slug":"前端/HTML5/HTML5新增与删除标签","date":"2019-12-27T12:55:14.000Z","updated":"2019-12-27T12:58:26.877Z","comments":true,"path":"2019/12/27/qian-duan/html5/html5-xin-zeng-yu-shan-chu-biao-qian/","link":"","permalink":"http://yoursite.com/2019/12/27/qian-duan/html5/html5-xin-zeng-yu-shan-chu-biao-qian/","excerpt":"","text":"结构标签 结构标签(块状元素) &lt;article> 标记定义一篇文章 &lt;header> 标记定义一个页面或一个区域的头部 &lt;nav> 标记定义导航链接 &lt;section> 标记定义一个区域 &lt;aside> 标记定义页面内容部分的侧边栏 &lt;hgroup> 标记定义文件中一个区块的相关信息 &lt;figure> 标记定义一组媒体内容以及它们的标题 &lt;figcaption>标记定义 figure 元素的标题。 &lt;footer> 标记定义一个页面或一个区域的底部 &lt;dialog> 标记定义一个对话框(会话框)类似微信 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>结构标签&lt;/title> &lt;style type=\"text/css\"> footer { height: 50px; background: #abcdef; line-height: 50px; text-align: center; font-size: 24px; font-weight: bold; color: #696969; } &lt;/style> &lt;/head> &lt;body> &lt;header> &lt;div>Logo&lt;/div> &lt;nav> &lt;a href=\"index.html\">首页&lt;/a> &lt;a href=\"#\">介绍&lt;/a> &lt;a href=\"#\">案例&lt;/a> &lt;a href=\"#\">链接&lt;/a> &lt;a href=\"#\">关于&lt;/a> &lt;/nav> &lt;/header> &lt;section> &lt;hgroup> &lt;h1>&lt;/h1> &lt;h3>文/猫腻&lt;/h3> &lt;/hgroup> &lt;aside> &lt;a href=\"#se1\">Section One&lt;/a> &lt;a href=\"#se2\">Section Two&lt;/a> &lt;/aside> &lt;article> &lt;p>望着身边高大帅气的他，看着他的笑脸，忽然觉得这样真好&lt;/p> Section ONE 安静的大厅里，祖孙二人一时无语。院子里，京都来人采购的花茶堆放在一角，袋子里的茶香花香味缓缓渗了出来，将满院的花香都比了下去。 Section TOW 老夫人半闭着眼睛，说道：“当年你的母亲何其聪慧，但就是心地太善良，才落得……”她忽然睁开双眼，盯着范闲一字一句道：“宁肯自己去害死别人，也不要让别人害死自己。 &lt;/article> &lt;/section> &lt;section> &lt;figure> &lt;figcaption>庆余年&lt;/figcaption> &lt;div class=\"video\">...&lt;/div> &lt;/figure> &lt;/section> &lt;section> &lt;dialog> &lt;dt>小明：嗯,,,,内容还不错，，&lt;/dt> &lt;dd>codewhy：还好吧.&lt;/dd> &lt;/dialog> &lt;/section> &lt;footer> Copyright,,,,, &lt;/footer> &lt;/body> &lt;/html> 注意：块状元素编写顺序header/section/aside/article/footer header/section/footer > aside/article/figure/hgroup/nav > div/figcaption 多媒体标签 三类多媒体标签 &lt;video> 标记定义一个视频 &lt;audio> 标记定义音频内容 &lt;source> 标记定义媒体资源 &lt;canvas> 标记定义图片 &lt;embed> 标记定义外部的可交互的内容或插件，比如flash 标签意义 多媒体标签的出现意味着富媒体的发展以及支持不使用插件的情况下即可操作媒体文件，极大地提升了用户体验。 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Audio&lt;/title> &lt;/head> &lt;body> &lt;!--标记定义音频内容--> &lt;audio autoplay=\"autoplay\"> &lt;source src=\"../Source/passion.mp3\" type=\"audio/mpeg\"> &lt;/audio> &lt;!--标记视频内容--> &lt;video controls=\"controls\" width=\"1024\" height=\"768\"> &lt;source src=\"../Source/pal4.mp4\" type=\"video/mp4\"> &lt;/video> &lt;!--标记定义外部的可交互的内容或插件，比如flash--> &lt;embed src=\"../Source/HappyBirthday.swf\" width=\"1024\" height=\"768\">&lt;/embed> &lt;/body> &lt;/html> 状态标签&lt;meter> 状态标签(实时状态显示：气压、气温)C、O &lt;progress> 状态标签 (任务过程：安装、加载) C、F、O 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Meter&lt;/title> &lt;/head> &lt;body> &lt;meter value=\"220\" min=\"20\" max=\"380\" low=\"200\" high=\"240\" optimum=\"220\">&lt;/meter> &lt;meter value=\"0.75\">75%&lt;/meter> &lt;!--任务过程--> &lt;progress value=\"30\" max=\"100\"> &lt;progress max=\"100\">&lt;/progress> &lt;/body> &lt;/html> 列表标签&lt;datalist> 为input标记定义一个下拉列表,配合option F、O &lt;details> 标记定义一个元素的详细内容 ，配合summary C 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Datalist和Details&lt;/title> &lt;/head> &lt;body> &lt;input placeholder=\"请选择您喜欢的手机品牌\" list=\"phoneList\" /> &lt;datalist id=\"phoneList\"> &lt;option value=\"iPhone\">iPhone&lt;/option> &lt;option value=\"Samsung\">Samsung&lt;/option> &lt;option value=\"Huawei\">Huawei&lt;/option> &lt;option value=\"hTC\">hTC&lt;/option> &lt;option value=\"Meizu\">Meizu&lt;/option> &lt;/datalist> &lt;details open=\"open\"> &lt;summary>树下的猫&lt;/summary> &lt;p>我是一只坐在树下的貓，每天我都坐在树下，看花花世界，人海茫茫……我每天都会做相同的梦，梦里看到一位 公子，身患重病，危在旦夕。公子身边有一名女子，她的眼里尽是关切和深深的依恋。 &lt;/p> &lt;/details> &lt;/body> &lt;/html> 命令列表&lt;menu> 命令列表（目前所有主流浏览器都不支持） &lt;menuitem> menu命令列表标签（只有FireFox8.0+支持） &lt;command> menu标记定义一个命令按钮（只有IE9支持） 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Menu&lt;/title> &lt;/head> &lt;body> &lt;meun type=\"toolbar\"> &lt;li> &lt;meun label=\"File\"> &lt;button type=\"button\">New...&lt;/button> &lt;button type=\"button\">Open...&lt;/button> &lt;button type=\"button\">Save...&lt;/button> &lt;/meun> &lt;/li> &lt;li> &lt;meun label=\"Edit\"> &lt;button type=\"button\">Cut...&lt;/button> &lt;button type=\"button\">Copy...&lt;/button> &lt;button type=\"button\">Paste...&lt;/button> &lt;/meun> &lt;/li> &lt;/meun> &lt;/body> &lt;/html> 注释标签&lt;ruby> 标记定义注释或音标 &lt;rp> 告诉那些不支持 ruby元素的浏览器如何去显示 &lt;rt> 标记定义对ruby的注释内容文本 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Ruby&lt;/title> &lt;/head> &lt;body> &lt;p>我们来&lt;ruby>夼&lt;rp>(&lt;/rp>&lt;rt>Kuang&lt;/rt>&lt;rp>)&lt;/rp>&lt;/ruby>一个话题。&lt;/p> &lt;/body> &lt;/html> 其他标签&lt;mark> 标记定义有标记的文本 (黄色选中状态) &lt;output> 标记定义一些输出类型，计算表单结果配合oninput事件 &lt;keygen> 标记定义表单里一个生成的键值(加密信息传送) &lt;time> 标记定义一个日期/时间，目前所有主流浏览器都不支持 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Mark和Output&lt;/title> &lt;/head> &lt;body> &lt;p>妈妈叫我回家的时候顺路买一盒&lt;mark>牛奶&lt;/mark>，需要很新鲜的那种。&lt;/p> &lt;hr/> &lt;form oninput=\"totalPrice.value=parseInt(price.value)*parseInt(number.value)\"> &lt;input type=\"text\" id=\"price\" value=\"5000\"> *&lt;input type=\"number\" id=\"number\" value=\"1\"> =&lt;output name=\"totalPrice\" for=\"price number\">&lt;/output> &lt;/form> &lt;/body> &lt;/html> 重定义标签 显示不变，只是表达的含义进行了重新定义的标签。 &lt;b> 代表内联文本，通常是粗体，没有传递表示重要的意思 &lt;i> 代表内联文本，通常是斜体，没有传递表示重要的意思 &lt;dd> 可以同details与figure一同使用，定义包含文本，dialog也可用 &lt;dt> 可以同details与figure一同使用，汇总细节，dialog也可用 &lt;hr> 不仅表示水平线，还表示主题结束，显示效果相同 &lt;menu> 重新定义用户界面的菜单，配合command或者menuitem使用 &lt;small> 表示小字体，例如打印注释或者法律条款 &lt;strong>表示重要性而不是强调符号 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/categories/HTML5/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}],"keywords":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/categories/HTML5/"}]},{"title":"HTML5属性变化","slug":"前端/HTML5/HTML5属性变化","date":"2019-12-27T12:54:51.000Z","updated":"2019-12-27T12:57:46.975Z","comments":true,"path":"2019/12/27/qian-duan/html5/html5-shu-xing-bian-hua/","link":"","permalink":"http://yoursite.com/2019/12/27/qian-duan/html5/html5-shu-xing-bian-hua/","excerpt":"","text":"Input属性电子邮件Input类型&lt;input type=\"email\" name=\"email\"> 统一资源定位符input类型&lt;input type=\"url\" name=\"url\"> 电话号码input类型&lt;input type=\"tel\" name=\"tel\"> 数字input类型&lt;input type=\"number\" name=\"number\"> 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>number&lt;/title> &lt;/head> &lt;body> &lt;input type=\"email\" name=\"email\"> &lt;hr/> &lt;input type=\"url\" name=\"url\"> &lt;hr/> &lt;input type=\"tel\" name=\"tel\"> &lt;hr/> &lt;input type=\"number\" name=\"number\"> &lt;/body> &lt;/html> date类型代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>date&lt;/title> &lt;/head> &lt;body> date:&lt;input type=\"date\" name=\"date\">&lt;br> month:&lt;input type=\"month\" name=\"month\">&lt;br> week:&lt;input type=\"week\" name=\"week\">&lt;br> time:&lt;input type=\"time\" name=\"time\">&lt;br> datetime:&lt;input type=\"datetime\" name=\"datetime\">&lt;br> datetime-local:&lt;input type=\"datetime-local\" name=\"datetime-local\">&lt;br> &lt;/body> &lt;/html> Range input类型&lt;input type=\"range\" name=\"range\" min=\"1\" max=\"10\"> Search input类型input type=\"search\" name=\"search\"> Color input 类型&lt;input type=\"color\" name=\"color\"> 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>&lt;/title> &lt;/head> &lt;body> &lt;input type=\"range\" name=\"range\" min=\"1\" max=\"10\"> &lt;hr/> &lt;input type=\"search\" name=\"search\"> &lt;hr/> &lt;input type=\"color\" name=\"color\"> &lt;/body> &lt;/html> 表单新增属性1.autocomplete属性form或者input域应该拥有自动完成的功能 &lt;formautocomplete = \"on\" >&lt;/form> 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>autocomplete&lt;/title> &lt;/head> &lt;body> &lt;form action=\"lesson2_1 autocomplete.html\" autocomplete=\"on\"> &lt;input type=\"text\" name=\"text\"> &lt;input type=\"email\" name=\"email\" autocomplete=\"off\"> &lt;input type=\"submit\"> &lt;/form> &lt;/body> &lt;/html> 2.autofocus属性 规定在页面加载时，域自动地获得焦点。 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>autofocus&lt;/title> &lt;/head> &lt;body> &lt;form action=\"lesson2_1 autocomplete.html\" autocomplete=\"on\"> &lt;input type=\"text\" name=\"text\"> &lt;input type=\"email\" name=\"email\" autocomplete=\"off\" autofocus=\"autofocus\"> &lt;input type=\"submit\"> &lt;/form> &lt;/body> &lt;/html> 注意 autofocus属性适用于所有input标签类型。 3.multiple属性规定输入域中可选择多个文件或者输入多个值。 &lt;input>标签的 email 和 file 类型。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>multiple&lt;/title> &lt;/head> &lt;body> &lt;form action=\"lesson2_1 autocomplete.html\" autocomplete=\"on\"> &lt;input type=\"file\" name=\"file\" multiple=\"multiple\"> &lt;input type=\"email\" name=\"email\" autocomplete=\"off\" autofocus=\"autofocus\" multiple=\"multiple\"> &lt;input type=\"email\" name=\"email\" autocomplete=\"off\" autofocus=\"autofocus\"> &lt;input type=\"submit\"> &lt;/form> &lt;/body> &lt;/html> 3.placeholder属性提供一个提示，描述输入域中所期待的值。 &lt;input>标签的 text、search、url、tel、email、password 类型 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>placeholder&lt;/title> &lt;/head> &lt;body> &lt;form action=\"lesson2_1 autocomplete.html\" autocomplete=\"on\"> &lt;input type=\"text\" name=\"text\" placeholder=\"您好，请在这里输入您的用户名！\"> &lt;input type=\"email\" name=\"email\" autocomplete=\"off\"> &lt;input type=\"submit\"> &lt;/form> &lt;/body> &lt;/html> 4.required属性规定必须在提交之前填写输入域，输入域不能为空。 &lt;input>标签的 text、search、url、tel、email、password、datepickers、number、checkbox、radio 以及 file。 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>required&lt;/title> &lt;/head> &lt;body> &lt;form action=\"lesson2_1 autocomplete.html\"> &lt;input type=\"text\" name=\"text\" required=\"required\"> &lt;input type=\"email\" name=\"email\" required=\"required\"> &lt;input type=\"submit\"> &lt;/form> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/categories/HTML5/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}],"keywords":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/categories/HTML5/"}]},{"title":"CPP之模板","slug":"c++/CPP之模板","date":"2019-12-16T07:58:05.000Z","updated":"2020-05-06T10:41:14.703Z","comments":true,"path":"2019/12/16/c/cpp-zhi-mo-ban/","link":"","permalink":"http://yoursite.com/2019/12/16/c/cpp-zhi-mo-ban/","excerpt":"","text":"函数模板引出 首先通过函数重载，实现同名函数，根据不同的参数类型，进行智能调用。 对比函数重载，函数模板，只需要一个函数就搞定。 意义: 模板是泛型编程的一种重要思想。stl就是利用模板实现的一个具体实例。 函数模板的写法template &lt;typename T> void fun(T tt) { cout &lt;&lt; tt &lt;&lt; endl; } 格式书写： template template 可以有多个参数 ： template &lt;typename T, typename Y&gt; 作用域： 仅对下边挨着的代码段有效。 代码实现：#include &lt;iostream> using namespace std; // 定义模板 template&lt;typename T, typename Y> void fun(T a, Y y) { // 输出结果 cout &lt;&lt; a &lt;&lt;\" \"&lt;&lt; y &lt;&lt; endl; } template&lt;typename T, typename Y> void fun1(T a, Y y) { // 输出结果 cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl; } int main() { // 调用函数 fun('a', 12); fun1(\"helloworld\", 34); return 0; } 具体化 特点：1- 就是将指定的类型，单独处理。 template void fun(job& j1, job& j2); 要单独写个实现. 调用：fun(结构1， 结构2)； 2-调用顺序 原版函数-&gt;具体化-&gt;模板 代码实现：#include &lt;iostream> using namespace std; struct Node { int a; double b; }; template&lt;class TTT> void fun(TTT a) { cout &lt;&lt; a &lt;&lt; endl; } template&lt;> void fun&lt;Node>(Node no) { cout &lt;&lt; no.a &lt;&lt; \" \" &lt;&lt; no.b &lt;&lt; endl; } int main() { Node no = {12, 12.12}; fun(no); return 0; } 实例化 特点： 生成指定类型的函数定义 template void fun(job&amp; j1, job&amp; j2); 调用：fun(结构1， 结构2)； 没有函数实现 代码实现:#include &lt;iostream> using namespace std; struct Node { int a; double b; }; template&lt;class TTT> void fun(TTT a) { cout &lt;&lt; a &lt;&lt; endl; } /* 代码实例化 */ template void fun&lt;int>(int a); int main() { Node no = {12, 12.12}; fun(12.13); return 0; } 类模板特点 1.可以设定默认值 template &lt;typename T, typename Y = char> 只有类模板可以有默认值 必须从右向左连续赋值默认类型，跟函数参数默认值一样，传递的时候会覆盖掉。 2.创建对象传递模板参数列表 类模板，需要在类型后加模板参数列表 CFather&lt;int, char> fp;有默认值的时候可以不传。但是必须要有&lt;>，CFather&lt;> fp; CFather&lt;int,char>* pf = new CFather&lt;int ,char>;除了类之外，任何位置出现CFather,都要加上模板参数列表. 3.类外实现的函数模板的写法 template &lt;class T,class B , class C> void CA&lt;T, B, C>::fun(T a) { } void CFather&lt;int, char>::Show() { cout &lt;&lt; a &lt;&lt; endl; } 代码实现: #include &lt;iostream> using namespace std; template&lt;typename T, typename Y = int> class CFather { public: T a; CFather(T t) { a = 12; } void Show(); }; template&lt;typename T, typename Y> void CFather&lt;T, Y>::Show() { cout &lt;&lt; a &lt;&lt; endl; } int main() { //模板参数列表 CFather&lt;int,char> pf(1); pf.Show(); CFather&lt;int,char>* fp = new CFather&lt;int, char>(1); fp->Show(); return 0; } 继承的模板特点:模板参数列表的传递: 直接指定固定的类型 通过子类模板参数列表传递 继承的时候要写：public CFather&lt;T> 构造函数传递(父类有参数构造）：CFather&lt;T> 创建对象时候要写 CFather&lt;int, char> fp; 代码实现#include &lt;iostream> using namespace std; template&lt;typename T, typename Y = int> class CFather { public: T a; CFather() { a = 12; } virtual void Show() { cout &lt;&lt; \"SHow\" &lt;&lt; endl; } }; template&lt;typename X, typename Z> class CSon : public CFather&lt;X, Z> { public: CSon() : CFather&lt;X, Z>() { } void Show() { } }; int main() { CFather&lt;int , char>* pf = new CSon&lt;int , char>; system(\"pause\"); return 0; } 多态的模板注意： 子类没模板 CFather&lt;short, char&gt;* pf = new CSon; 子类有模板 CFather&lt;short, char&gt;* pf = new CSon&lt;short, int ,char&gt;; 类型一定要对应上 代码实现：#include &lt;iostream> using namespace std; template&lt;typename T, typename Y = int> class CFather { public: virtual void fun() { cout &lt;&lt; \"CFather\" &lt;&lt; endl; } }; template&lt; typename X, typename W, typename Z> class CSon : public CFather&lt;X, Z> { public: void fun() { cout &lt;&lt; \"CSon\" &lt;&lt; endl; } }; int main() { CFather&lt;short, char>* pf = new CSon&lt;short, int ,char>; pf->fun(); return 0; } ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"CPP之运算符重载","slug":"c++/CPP之运算符重载","date":"2019-12-15T13:34:29.000Z","updated":"2020-05-06T10:41:06.608Z","comments":true,"path":"2019/12/15/c/cpp-zhi-yun-suan-fu-chong-zai/","link":"","permalink":"http://yoursite.com/2019/12/15/c/cpp-zhi-yun-suan-fu-chong-zai/","excerpt":"","text":"运算符重载的需求 C++预定义的运算符，只能用于基本数据类型的运算：整型、实型、字符型、逻辑型.......+、-、*、/、%、^、&amp;、~、!、|、=、&lt;&lt;>>、!=、…… 在数学上，两个复数可以直接进行+、-等运算。但在C++中，直接将+或-用于复数对象是不允许的。 有时会希望，让对象也能通过运算符进行运算。这样代码更简洁，容易理解。 例如： complex_a和complex_b是两个复数对象；求两个复数的和, 希望能直接写： complex_a + complex_b 运算符重载的定义 运算符重载，就是对已有的运算符(C++中预定义的运算符)赋予多重的含义，使同一运算符作用于不同类型的数据时导致不同类型的行为。 运算符重载的目的是：扩展C++中提供的运算符的适用范围，使之能作用于对象。 同一个运算符，对不同类型的操作数，所发生的行为不同。 complex_a + complex_b 生成新的复数对象 5 + 4 = 9 作用：赋予运算符自定义功能。 默认:常数+常数 比如对象+对象，默认情况下是不被允许的，当我们重载了+后，就可以实现对象相加了。 对象+常数，常数+对象重载函数，函数的两个参数在小括号内，运算符的两个参数在两侧。 运算符重载的形式： 运算符重载的实质是函数重载 可以重载为普通函数，也可以重载为成员函数 。 把含运算符的表达式转换成对运算符函数的调用。 把运算符的操作数转换成运算符函数的参数。 运算符被多次重载时，根据实参的类型决定调用哪个运算符函数。 返回值类型 operator 运算符（形参表） { …… } 1-无返回值代码实现#include &lt;iostream> using namespace std; class CStu { public: // 声明两个成员变量 int nAge; double dScore; // 创建构造函数 CStu() { nAge = 12; dScore = 12.12; } }; //运算符重载 void operator+(CStu&amp; st, int a) { cout &lt;&lt; (st.nAge + a) &lt;&lt; endl; } void operator+(int a, CStu&amp; st) { cout &lt;&lt; (st.nAge + a) &lt;&lt; endl; } int main() { // 声明两个对象 CStu st1, st2; // + int a = 13; a + 13; //st1 + st2; st1 + 12; 12 + st2; return 0; } 2-带返回值代码实现#include &lt;iostream> using namespace std; class CStu { public: // 声明两个成员变量 int nAge; double dScore; // 创建构造函数 CStu() { nAge = 12; dScore = 12.12; } }; //运算符重载 int operator+(CStu&amp; st, int a) { return (st.nAge + a); } int main() { // 声明两个对象 CStu st1, st2; cout &lt;&lt; (st1 + 12 + 13) &lt;&lt; endl; return 0; } 3-类外重载 左边是左参数，右边是右参数 #include &lt;iostream> using namespace std; class CStu { public: int nAge; double dScore; CStu() { nAge = 12; dScore = 12.12; } }; //运算符重载 int operator+(CStu&amp; st, int a) { return (st.nAge + a); } int operator+(int a, CStu&amp; st) { return (st.nAge + a); } CStu&amp; operator+(CStu&amp; st1, CStu&amp; st) { st1.nAge += st.nAge; return st1; } CStu&amp; operator::(CStu&amp; st1,int a) { st1.nAge += st.nAge; return st1; } int main() { CStu st1, //对象1 st2; // 输出结果 cout &lt;&lt; (st1 + 12 + 13 + (st2 + st2) + 23); return 0; } 4-类内重载 默认左边是类的类型 #include &lt;iostream> using namespace std; class CStu { public: int nAge; CStu() { nAge = 12; } // 类内重载 int operator+(int a) { return (this->nAge + a); } }; // 类外重载 int operator+(int a, CStu&amp; st) { return (a - st.nAge); } int main() { CStu st; cout &lt;&lt; (st + 12) &lt;&lt; endl; cout &lt;&lt; (13 + st) &lt;&lt; endl; return 0; } 5-二元运算符算术运算符 + ,- ,* ,/ ,% , 关系运算符 >= ,&lt;= ,> ,&lt; ,!= ,== >位运算符 >^ ,&amp; ,I >逻辑运算符 >&amp;&amp;，|| 代码实现： #include &lt;iostream> using namespace std; class CStu { public: int nAge; CStu(int age) { nAge = age; } int operator >= (CStu&amp; st2) { return (nAge >= st2.nAge); } int operator &amp; (CStu&amp; st2) { return (nAge &amp; st2.nAge); } int operator &amp;&amp; ( CStu&amp; st2) { return (nAge &amp;&amp; st2.nAge); } }; int operator += (CStu&amp; st1, CStu&amp; st2) { return (st1.nAge &amp;&amp; st2.nAge); } int main() { CStu st1(14); //st1.nage CStu st2(13); cout &lt;&lt; (st1 >= st2); cout &lt;&lt; (st1 &amp;&amp; st2); system(\"pause\"); return 0; } 6- 一元运算符#include &lt;iostream> using namespace std; class CStu { public: int nAge; CStu(int age) { nAge = age; } // 内重载 int operator-() { return (-nAge); } }; // 外重载 int operator!(CStu&amp; st) { return (!st.nAge); } int main() { CStu st1(14); //st1.nage cout &lt;&lt; (!st1); system(\"pause\"); return 0; } 7- 输出运算符重载特点： cout是一个对象 参数1是ostream引用，参数2是对象的常引用 返回值保证连续输出 必须是类外 类友元 #include &lt;iostream> using namespace std; class CStu { private: int nAge; public: CStu() { nAge = 12; } // 定义友元函数 friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const CStu&amp; st); }; ostream&amp; operator &lt;&lt; (ostream&amp; os, const CStu&amp; st) { os &lt;&lt; st.nAge; return os; } int main() { // 创建对象 CStu st; // 输出对象 cout &lt;&lt; st &lt;&lt; st &lt;&lt; \"kobe\"; return 0; } 8- 输入运算符重载istream& operator>> (istream& is, CStu& st){ // 需要输入检测是否失败 return is; } 代码示例 #include &lt;iostream> using namespace std; class CStu { private: int nAge; double dbHeight; public: CStu() { nAge = 0; dbHeight = 0.0; } void Show() { cout &lt;&lt; nAge &lt;&lt; endl; cout &lt;&lt; dbHeight &lt;&lt; endl; } friend istream&amp; operator >> (istream&amp; ist, CStu&amp; st); }; istream&amp; operator >> (istream&amp; ist, CStu&amp; st) { ist >> st.nAge >> st.dbHeight; // 需要输入检测是否失败 if (ist.fail()) { st.nAge = 0; st.dbHeight = 0; } return ist; } int main() { // 创建st对象 CStu st; cin >> st; st.Show(); return 0; } 9-赋值运算符重载#include &lt;iostream> using namespace std; class CStu { private: int nAge; double dbHeight; public: CStu() { nAge = 0; dbHeight = 0.0; } int operator=(int a) { nAge = a; return nAge; } int&amp; operator+=( int a) { nAge = nAge + a; return nAge; } }; /* // 类外重载 int&amp; operator+=(CStu&amp; st1, int a) { st1.nAge = st1.nAge + a; return st1.nAge; } */ int main() { // 创建对象 CStu st; int a = 111; cout &lt;&lt; (st += a += 113); return 0; } 10- 下标运算符重载下标运算符:[ ] ​ 返回引用 ​ 只能类内 #include &lt;iostream> using namespace std; class CStu { public: int a; int b; int c; double d; int nError; CStu() { a = 12; b = 23; c = 34; d = 45; nError = -1; } //返回指针 int&amp; operator[](int n) { switch(n) { case 0: return &amp;a; case 1: return &amp;d; } return &amp;nError; } }; int main() { CStu st; //st[1] cout &lt;&lt; *(int *)st[0]; cout &lt;&lt; *(double *)st[1]; // void 没有确定的大小 // ==》void* ==》 *(double *)st[1] = 15; cout &lt;&lt; *(double *)st[1]; return 0; } 11- 自加自减运算符重载#include &lt;iostream> using namespace std; class CStu { public: int nAge; CStu() { nAge = 12; } int operator++() { nAge += 1; return nAge; } int operator--() { this->nAge -= 1; return nAge; } int operator++(int n) //int n 理解成一个标记 { n = nAge; // nAge += 1; return n; } }; /* // 类外++ int operator++(CStu&amp; st) { st.nAge += 1; return st.nAge; } */ /* // 类外 -- int operator--(CStu&amp; st) { st.nAge -= 1; return st.nAge; } */ // 后置 ++ int operator++(CStu&amp; st, int n) //int n 理解成一个标记 { n = st.nAge; // st.nAge += 1; return n; } // 后置 -- int operator--(CStu&amp; st, int n) //int n 理解成一个标记 { n = st.nAge; // st.nAge -= 1; return n; } int main() { int a = 12; //int b = ++a; // b == 13 //a++; int b = a++; //b == 12, a == 13 CStu st; //cout &lt;&lt; ++st; //13 // cout &lt;&lt; --st; //12 cout &lt;&lt; st--; cout &lt;&lt; st.nAge; return 0; } 重载类型转换 特点​ 1、没有显示返回类型，但是要写返回值。​ 2、没有参数。​ 3、必须定义成类的成员函数​ 4、不应该改变对象的内容，所以是const函数。​ 5、避免过度使用。 使用时间 #include &lt;iostream> using namespace std; class CStu { public: int a; double b; CStu() { a = 13; b = 12.12; } // 类型转换没有返回值 operator int() const { return a; } operator double() const { return b; } }; int main() { // 创建对象 CStu st; cout &lt;&lt; int(st) &lt;&lt; endl; cout &lt;&lt; (double)st &lt;&lt; st.b &lt;&lt; endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"CPP之异常处理","slug":"c++/CPP之异常处理","date":"2019-12-15T13:33:42.000Z","updated":"2020-05-06T10:41:09.100Z","comments":true,"path":"2019/12/15/c/cpp-zhi-yi-chang-chu-li/","link":"","permalink":"http://yoursite.com/2019/12/15/c/cpp-zhi-yi-chang-chu-li/","excerpt":"","text":"程序的错误分类 语法错误: 语法错误在编译和链接阶段就能发现，只有 100% 符合语法规则的代码才能生成可执行程序。语法错误是最容发现、最容易定位、最容易排除的错误，程序员最不需要担心的就是这种错误。 逻辑错误: 是说我们编写的代码思路有问题，不能够达到最终的目标，这种错误可以通过调试来解决。 运行时错误: 是指程序在运行期间发生的错误，例如除数为 0、内存分配失败、数组越界、文件不存在等。C++ 异（Exception）机制就是为解决运行时错误而引入的。 代码示例： #include &lt;iostream> #include &lt;cstdlib> using namespace std; // 定义fun函数 void fun(int a) { // 条件判断 if (0 == a) { abort(); } // 输出结果 cout &lt;&lt; \"a\" &lt;&lt; a &lt;&lt; endl; } int main() { // 调用函数 fun(0); return 0; } 捕获异常 借助 C++ 异常机制来捕获上面的异常，避免程序崩溃。捕获异常的语法为 ： ry{ // 可能抛出异常的语句 }catch(exceptionType variable){ // 处理异常的语句 } try和catch都是 C++ 中的关键字，后跟语句块，不能省略{ }。try 中包含可能会抛出异常的语句，一旦有异常抛出就会被后面的 catch 捕获。从 try 的意思可以看出，它只是“检测”语句块有没有异常，如果没有发生异常，它就“检测”不到。catch 是“抓住”的意思，用来捕获并处理 try 检测到的异常；如果 try 语句块没有检测到异常（没有异常抛出），那么就不会执行 catch 中的语句。 注意 抛出对象的时候，要用引用或者指针，不然会拷贝备份出来，即拷贝构造函数。 代码实现: #include &lt;iostream> #include &lt;cstdlib> //cstdio using namespace std; class CPeople { public: int b; CPeople() { b = 12; } }; void fun(int a) { if (0 == a) { abort(); } cout &lt;&lt; \"a \" &lt;&lt; a &lt;&lt; endl; } void fun1(int a) { while (a &lt; 10) { if (5 == a) { throw 123.123; } a++; } } void fun2(CPeople&amp; c) { while (c.b &lt; 20) { if (15 == c.b) { throw &amp;c; } c.b++; } } int main() { // 创建对象 CPeople po; try { fun2(po); } catch(CPeople&amp; a) { } catch(CPeople* d) { d->b++; } catch(int b) { try { fun1(b+1); } catch(int a) { } } catch(char c) { cout &lt;&lt; c &lt;&lt; endl; } catch(...) { cout &lt;&lt; \"default \" &lt;&lt; endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"CPP之拷贝构造","slug":"c++/CPP之拷贝构造","date":"2019-12-15T13:32:28.000Z","updated":"2020-05-06T10:41:17.084Z","comments":true,"path":"2019/12/15/c/cpp-zhi-kao-bei-gou-zao/","link":"","permalink":"http://yoursite.com/2019/12/15/c/cpp-zhi-kao-bei-gou-zao/","excerpt":"","text":"拷贝构造1-调用时间 1、新建一个对象，并将其初始化为同类现有对象 #include &lt;iostream> using namespace std; class CStu { public: CStu(){ } // 拷贝构造 CStu(const CStu&amp; a) { } }; int main() { // 声明对象 CStu st1; CStu stNew(st1); CStu stNew = st1; CStu stNew = CStu(st1); CStu* stNew = new CStu(st1); // 赋值无法实现拷贝构造 /* CStu st2; st2 = st1; CStu(st2); */ return 0; } 2.当程序生成对象副本时 函数参数传递对象的值 函数返回对象 #include &lt;iostream> using namespace std; class CStu { public: CStu() { } }; void fun(CStu a) { } CStu fun() { CStu a; return a; } int main() { CStu st1; fun(); return 0; } 2-默认拷贝构造 默认的复制构造函数，逐个复制非静态成员（成员的复制称为浅复制）值，复制的是成员的值。系统默认的这个又叫浅拷贝 #include &lt;iostream> using namespace std; class CStu { public: int b; char c[4]; CStu() { b = 12; c[0] = 'a'; strcpy_s(c, 4, \"abc\"); // 源 } CStu(const CStu&amp; a) { this->b = a.b; strcpy_s(this->c, 4, a.c); } }; int main() { CStu st; cout &lt;&lt; st.b &lt;&lt; \" \" &lt;&lt; st.c &lt;&lt; endl; CStu st1 = st; cout &lt;&lt; st1.b &lt;&lt; \" \" &lt;&lt; st1.c &lt;&lt; endl; return 0; } ==特点==：同一个类的多个对象，内存排布是一样的，地址不同 3-深拷贝深拷贝：指针成员不能直接赋值，要用内存拷贝，memcpy，strcpyd等。 解决拷贝构造所引发的指针成员二次释放崩溃的问题的方式 深拷贝 传地址 传引用 #include &lt;iostream> using namespace std; class CStu { public: int *a; CStu() { a = new int[2]; a[0] = 12; a[1] = 13; } CStu(const CStu&amp; b) { this->a = new int[2]; memcpy(this->a, b.a, 8); //memory copy } ~CStu() { delete[] a; } }; /* 传递引用 */ CStu&amp; fun(CStu&amp; a) { return a; } /* 传递指针 */ CStu* fun(CStu* a) { return a; } int main() { { CStu at; cout &lt;&lt; at.a[0] &lt;&lt; \" \" &lt;&lt; at.a[1] &lt;&lt; endl; fun(&amp;at); CStu st = at; cout &lt;&lt; st.a[0] &lt;&lt; \" \" &lt;&lt; st.a[1] &lt;&lt; endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"C语言之流程控制","slug":"C语言/C语言之流程控制","date":"2019-12-15T13:23:51.000Z","updated":"2020-05-12T03:26:44.691Z","comments":true,"path":"2019/12/15/c-yu-yan/c-yu-yan-zhi-liu-cheng-kong-zhi/","link":"","permalink":"http://yoursite.com/2019/12/15/c-yu-yan/c-yu-yan-zhi-liu-cheng-kong-zhi/","excerpt":"","text":"条件判断if-else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为 false 时执行。 语法： if(boolean_expression) { /* 如果布尔表达式为真将执行的语句 */ } else { /* 如果布尔表达式为假将执行的语句 */ } 流程图 代码示例 #include &lt;stdio.h> int main() { // 定义变量 short a = 1; short b = 2; int c = a - b; // 条件判断 if( c > 0 ) { printf(\"a > b\\n\"); } else { printf(\"a &lt;= b\\n\"); } return 0; } if- else if-else语句 代码示例 #include &lt;stdio.h> int main() { // 定义且初始化变量 int x = 0; int y = 0; printf(\"请输入两个数：\"); // 请输入两个数 scanf(\"%d%d\", &amp;x, &amp;y); if (x > y) { printf(\"The bigger is: %d\\n\", x); } else if (x &lt; y) { printf(\"The bigger is: %d\\n\", y); } else { printf(\"The 2 integers is equal: x == y\\n\"); } return 0; } switch语句一个 switch 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 switch case 进行检查。 流程图 代码示例 #include &lt;stdio.h> int main() { // 定义num变量 int num = 0; printf(\"Input a number: \"); scanf(\"%d\", &amp;num); // 选择分支 switch( num ) { case 1: printf(\"A\\n\"); break; case 2: printf(\"B\\n\"); break; case 3: printf(\"C\\n\"); break; case 4: printf(\"D\\n\"); break; case 5: printf(\"E\\n\"); break; default: printf(\"Invalid Input\\n\"); } return 0; } 循环判断while 循环只要给定的条件为真，C 语言中的 while 循环语句会重复执行一个目标语句。 语法 while(condition) { statement(s); } 流程图 代码示例 #include &lt;stdio.h> int main() { // 定义sum变量 int sum = 0; // 定义i变量 int i = 1; while( i &lt;= 100 ) { sum = sum + i; i = i + 1; } printf(\"sum = %d\\n\", sum); printf(\"i = %d\\n\", i); return 0; } 编程实战 求2-100以内的所有质数 注意：质数只能被1 和 x整除 #include &lt;stdio.h> int main() { // 定义变量i int i = 2; while( i &lt;= 100 ) { // 定义标记 int flag = 0; int j = 2; while( j &lt; i ) { if( i%j == 0 ) { flag = flag + 1; } j = j + 1; } if( flag == 0 ) { printf(\"%d, \", i); } i = i + 1; } printf(\"\\n\"); return 0; } for 循环for 循环的语法： for ( init; condition; increment ) { statement(s); } 流程图 代码示例 #include &lt;stdio.h> int main() { // 初始化两个sum的值 int esum = 0; int osum = 0; int i = 0; for(i=1; i&lt;=100; i=i+2) { osum = osum + i; esum = esum + (i + 1); } printf(\"osum = %d\\n\", osum); printf(\"esum = %d\\n\", esum); return 0; } do…while 循环 在 C 语言中，do…while 循环是在循环的尾部检查它的条件。 do…while 循环与 while 循环类似，但是 do…while 循环会确保至少执行一次循环。 语法 do { statement(s); }while( condition ); 流程图 代码示例 #include &lt;stdio.h> int main () { /* 局部变量定义 */ int a = 10; /* do 循环执行 */ do { printf(\"a 的值： %d\\n\", a); a = a + 1; }while( a &lt; 20 ); return 0; } breakbreak能够强制结束当前结构，阻止程序向下执行。 代码示例 #include &lt;stdio.h> int main() { int sum = 0; int i = 1; while( 1 ) { sum = sum + i; if( i == 100 ) break; i = i + 1; } printf(\"sum = %d\\n\", sum); printf(\"i = %d\\n\", i); return 0; } continue continue立即结束当前循环体，直接进入下一轮条件判断。 continue与break不同，并不会结束整个循环。 代码示例： #include &lt;stdio.h> int main() { int i = 0; int n = 0; for(i=1; i&lt;1000; i=i+1) { if( i % 7 ) continue; printf(\"%d \", i); n = n + 1; } printf(\"\\n\"); printf(\"Count: %d\\n\", n); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}]},{"title":"CPP之覆盖","slug":"c++/CPP之覆盖","date":"2019-12-15T13:23:51.000Z","updated":"2020-05-06T10:41:23.445Z","comments":true,"path":"2019/12/15/c/cpp-zhi-fu-gai/","link":"","permalink":"http://yoursite.com/2019/12/15/c/cpp-zhi-fu-gai/","excerpt":"","text":"覆盖定义 父类和子类中出现同名的成员时，C++采用的一种处理方式，就叫覆盖 数据成员同名类内: 子类覆盖父类，可以用类名作用域区分 类外: 类名作用域区分 代码实现: #include &lt;iostream> using namespace std; class CFather { public: int a; CFather() { a = 12; } }; class CSon : public CFather { public: int a; CSon() { a = 10; } void fun() //名字像同 就覆盖 { cout &lt;&lt; CFather::a &lt;&lt; endl; } }; int main() { CSon so; // 通过类名作用域调用 cout &lt;&lt; so.CFather::a &lt;&lt; endl; return 0; } 父类子类函数名字相同 子类覆盖父类 使用时可以通过类名作用域区分,父类子类的函数。 没有重载关系。 友元函数不能被继承。 代码实现： #include &lt;iostream> using namespace std; class CFather { private: int b; public: int a; CFather() { a = 12; b = 13; } void fun(int a) { cout &lt;&lt; \"Cfather Fun\" &lt;&lt; endl; } friend void show(); }; class CSon : public CFather { private : int c; public: int a; CSon() { a = 10; c = 14; } //名字相同就覆盖，子类就会覆盖父类 void fun() { cout &lt;&lt; \"CSon Fun\" &lt;&lt; endl; } }; void show() { CSon so; cout &lt;&lt; so.c &lt;&lt; endl; } int main() { CSon so; // 使用类名作用域去调用父类 so.CFather::fun(1); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"C语言之数据类型","slug":"C语言/C语言之数据类型","date":"2019-12-15T13:23:51.000Z","updated":"2020-05-12T03:26:29.587Z","comments":true,"path":"2019/12/15/c-yu-yan/c-yu-yan-zhi-shu-ju-lei-xing/","link":"","permalink":"http://yoursite.com/2019/12/15/c-yu-yan/c-yu-yan-zhi-shu-ju-lei-xing/","excerpt":"","text":"数据类型 数据类型的本质就是一个模子。 数据类型代表需要占用的内存的大小。 图示： 变量 变量的本质是内存中一段连续存储空间的别名。 程序中通过变量来申请并且命名存储空间。 通过变量的的名字可以使用存储空间。 初始化变量 软件在运行前需要向操作系统申请存储空间，在内存空间足够空闲时，操作系统将分配一段内存空间并将该外存中软件拷贝一份存入该内存空间中，并启动该软件运行。 在软件运行期间，该软件所占内存空间不再分配给其他软件。 当该软件运行完毕后，操作系统将回收该内存空间（==注意：操作系统并不清空该内存空间遗留下来的数据==），以便再次分配给其他软件使用。综上所述，一个软件所分配到的空间中极可能存在着以前其他软件使用过后的残留数据，这些数据被称之为垃圾数据。所以通常情况下我们为一个变量，为一个数组，分配好存储空间之前都要对该内存空间初始化。 对应进制数 控制符的操作printf()函数的使用# include &lt;stdio.h> int main(void) { //printf(\"哈哈!\\n\"); // \\n表示换行 // int i = 10; // printf(\"%o\\n\", i); //i是整形，应该是%d int j = 3; int k = 5; //printf(\"%d %d\\n\", j, k); //OK //printf(\"%d\\n\", j, k); //error 输出控制符和输出参数的个数不匹配 printf(\"i = %d, j = %d\\n\", j, k); return 0; } printf()对应的格式化字符 %d int %ld long int %c char %f float %lf double %x int 或者long int 或者 short int %o 同上 %s 字符串 Scanf()函数的用法功能：将从键盘输入的字符转化为输入控制符所规定格式的数据，然后存入以输入参数的值为地址的变量中。 语法 scanf(\"输入控制符\"， 输入参数) 代码示例： # include &lt;stdio.h> int main(void) { // 定义变量i ch int i; char ch; scanf(\"%d\", &amp;i);//&amp;i 表示i的地址 &amp;是一个取地址符 printf(\"i = %d\\n\", i); scanf(\"%c\", &amp;ch); printf(\"ch = %c\\n\", ch); return 0; } 强制类型转换 大类型赋值给小类型时，又可能发生溢出。 当数值在小类型范围内，赋值成功。 当数值超过小类型的范围，发生溢出。 小类型可以安全的赋值给大类型。 浮点类型赋值给整形，会发生截断。(小数部分丢失) 整型赋值给浮点类型，能够完成。 代码示例#include &lt;stdio.h> int main() { // 定义变量 int a = 50000; short b = 0; int i = 0; float f = 0.2; printf(\"a = %d\\n\", a); // a=50000 printf(\"b = %d\\n\", b); // b=0 printf(\"\\n\"); b = a; printf(\"a = %d\\n\", a); // a=50000 printf(\"b = %d\\n\", b); // b = -15536 printf(\"\\n\"); b = 30000; a = b; printf(\"a = %d\\n\", a); // a = 30000 printf(\"b = %d\\n\", b); // b = 30000 printf(\"\\n\"); printf(\"\\n\"); printf(\"i = %d\\n\", i); // 0 printf(\"f = %f\\n\", f); // 0.200000 printf(\"\\n\"); f = 3.14f; i = f; printf(\"i = %d\\n\", i); // i=3 printf(\"f = %f\\n\", f); // 3.140000 return 0; } 逻辑运算与位运算逻辑运算 逻辑运算的参与者为逻辑值(真或假)。 任何非零值在逻辑运算中都为真。 任何零值在逻辑运算中都为假。 图示： &amp;&amp;运算 从左向右进行，如果一个操作数为假，则表达式为假。 第一个为假的操作数之后的其他操作数不在计算。 ||运算 从左向右进行，如果有一个操作数为真，则整个表达式为真 第一个为真的操作数之后的其他的操作数不在计算。 取非运算(!) 单目运算(只需要一个操作数)，运算结果为逻辑值。 对真值取非的结果为假。 对假值取非的结果为真。 代码示例 #include &lt;stdio.h> int main() { int a = 1; int b = 2; int c = 0; c = a &amp;&amp; b; printf(\"c = %d\\n\", c); c = !(a - b) || (c &lt; b); printf(\"c = %d\\n\", c); c = 10000; c = !!c; printf(\"c = %d\\n\", c); return 0; } 位运算位运算(&amp;, |, ~, ^, &lt;&lt;, &gt;&gt;) 直接对数据的二进制位进行操作。 位运算的基本单位是二进制，所以也是一种0和1的操作。 可以使用括号()改变位运算的运算顺序。 位运算的操作数只能是整型数。(浮点数不能直接进行位运算) 运算符 含义 示例 优先级 ~ 按位求反 01011010 1 &lt;&lt; 左移：高位移出，低位补零 0011 &lt;&lt; 1 ~ 0110 2 &gt;&gt; 右移：低位移出，高位补符号位 0101 &gt;&gt; 2 ~ 0001 2 &amp; 按位与 0111 &amp; 1100 ~ 0100 3 ^ 按位异或：相同为0,不同为1 0111 ^1100 ~ 1011 4 | 按位或 0111 | 1100 - 1111 5 注意： 按位与和逻辑与的计算法相同:两者为1,结果为1,否则为0. 按位或和逻辑或的计算法相同:两者为0,结果为0，否则为1。 代码示例 #include &lt;stdio.h> int main() { printf(\"c = %d\\n\", 5 | 2); // 7 printf(\"c = %d\\n\", 7 ^ 8); // 15 printf(\"c = %d\\n\", 2 ^ 3); // 1 printf(\"c = %d\\n\", (15 >> 2) &amp; 13); // 1 printf(\"c = %d\\n\", 173 ^ 60); // 145 return 0; } 有符号和无符号数据类型的最高位用于标识数据的符号。 最高位为1，表示这个数为负数。 最高位为0，表示这个数为正数。 有符号数的表示法1.在计算机内部用补码表示有符号数。 正数的补码为正数本身。 负数的补码为负数的绝对值各位取反后加1 无符号数表示法2.在计算机内部用原码表示无符号数 - 无符号数默认为正数。 - 无符号数没有符号位。signed和unsigned C语言中变量默认为有符号的类型。 unsigned关键字声明变量为无符号类型。 C语言中只有整数类型才能够声明unsigned变量 代码示例 #include &lt;stdio.h> int main() { // 定义无符号数变量 unsigned int i = 5; // 定义变量 int j = -10; if( (i + j) > 0 ) { printf(\"i + j > 0\\n\"); } else { printf(\"i + j &lt;= 0\\n\"); } return 0; } 注意 当无符号数与有符号数混合计算时候，会将有符号数转换为无符号数再进行计算，结果为无符号数。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}]},{"title":"CPP之继承","slug":"c++/CPP之继承","date":"2019-12-15T13:23:08.000Z","updated":"2020-05-06T10:41:19.919Z","comments":true,"path":"2019/12/15/c/cpp-zhi-ji-cheng/","link":"","permalink":"http://yoursite.com/2019/12/15/c/cpp-zhi-ji-cheng/","excerpt":"","text":"继承和派生的概念继承：在定义一个新的类B时，如果该类与某个已有的类A相似(指的是B拥有A的全部特点)，那么就可以把A作为一个 基类，而把B作为基类的一个 派生类( ( 也称子类) )。 派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。 派生类一经定义后，可以独立使用，不依赖于基类。 继承的作用: 代码的重用性 继承的格式 class CXiaoming : public CPeople 基类，又叫父类 派生类，又叫子类 可以继承很多层 继承对象的声明 ​ 普通对象 ​ 指针对象 ​ 基类也可以自己创建对象 代码实现 #include &lt;iostream> using namespace std; class CPeople //基类 父类 { public: void Study() { cout &lt;&lt; \"Study\" &lt;&lt; endl; } }; class CChild : public CPeople //派生类 子类 { public: void GoToSchool() { Study(); cout &lt;&lt; \"GoToSchool\" &lt;&lt; endl; } }; class CManWoman : public CPeople { public: void GoToWork() { cout &lt;&lt; \"GoToWork\" &lt;&lt; endl; } }; class COldMan : public CPeople { public: void GoToPark() { cout &lt;&lt; \"GoToPark\" &lt;&lt; endl; } }; int main() { CChild child; child.Study(); CChild* child1 = new CChild; child1->Study(); COldMan oldman; oldman.Study(); CPeople cpo; cpo.Study(); return 0; } 继承的限定词 private 父类中的public，protected成员，在子类中为private，降低访问权限 protected 父类中的public成员，在子类中为protected，降低访问权限 public 父类如何子类如何 代码实现： #include &lt;iostream> using namespace std; class CPeople { private: void fun1() { cout &lt;&lt; \"father privete\" &lt;&lt; endl; } protected: void fun2() { cout &lt;&lt; \"father protected\" &lt;&lt; endl; } public: void fun3() { cout &lt;&lt; \"father public\" &lt;&lt; endl; } }; //public 父类怎么样， 子类就怎么 //protected 继承之后， 父类的public 降级成protected 父类中的 protected private 不变 //private 全变 私有 class Cxiaoming : private CPeople { public: int a; void fun4() { //fun1(); } }; class xiaohua : public Cxiaoming { void fun5() { fun3(); } }; int main() { Cxiaoming xm; // xm.fun3(); // xm.fun2(); // xm.fun1(); CPeople po; po.fun3(); return 0; } 构造函数以无参构造函数的执行顺序 先调用父类的，父类还有父类就继续向上 #include &lt;iostream> using namespace std; class CPeople { public: CPeople() { cout &lt;&lt; \"CPople\" &lt;&lt; endl; } }; class Cxiaoming : public CPeople { public: Cxiaoming() { cout &lt;&lt; \"Cxiaoming\" &lt;&lt; endl; } }; class xiaohua : public Cxiaoming { public: xiaohua() { cout &lt;&lt; \"xiaohua\" &lt;&lt; endl; } }; int main() { Cxiaoming xiaoming; //继承构造的调用顺序，先父 再 子类 //xiaohua xh; cin >> a; cout &lt;&lt; a &lt;&lt; endl; return 0; } 代参构造函数的执行顺序 父类有参数的构造，需要通过子类初始化列表来传递参数。只关注自己父类的多个构造函数选择传递。默认是无参的参数列表写谁，调用谁。 #include &lt;iostream> using namespace std; class CgrandFather { public: CgrandFather(int a, int b) { } CgrandFather(int c) { } }; class CFather : public CgrandFather { public: CFather(int a) : CgrandFather(a) { cout &lt;&lt; \"i am fatherclass\\n\"; } void show() { cout &lt;&lt; \"hello\\n\"; } }; class CSon : public CFather { public: int b; CSon(int a) : CFather(a) { } void show() { cout &lt;&lt; \"hello11\\n\"; } }; int main() { CSon son(3); son.CFather::show(); return 0; } 析构函数 调用顺序：由辈分小的到辈分大的。 #include &lt;iostream> using namespace std; class CgrandFather { public: CgrandFather() { cout &lt;&lt; \"CgrandFather\" &lt;&lt; endl; } ~CgrandFather() { cout &lt;&lt; \"CgrandFather\" &lt;&lt; endl; } }; class CFather : public CgrandFather { public: ~CFather() { cout &lt;&lt; \"CFather\" &lt;&lt; endl; } }; class CSon : public CFather { public: CSon() { cout &lt;&lt; \"CSon\" &lt;&lt; endl; } ~CSon() { cout &lt;&lt; \"CSon\" &lt;&lt; endl; } }; int main() { { CSon so; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"CPP之多态与虚函数","slug":"c++/CPP之多态与虚函数","date":"2019-12-15T13:21:02.000Z","updated":"2020-05-06T10:41:46.164Z","comments":true,"path":"2019/12/15/c/cpp-zhi-duo-tai-yu-xu-han-shu/","link":"","permalink":"http://yoursite.com/2019/12/15/c/cpp-zhi-duo-tai-yu-xu-han-shu/","excerpt":"","text":"多态与虚函数的基本概念 多态是一种泛型编程思想，即同样的代码，实现不同的功能。 父类的指针，调用子类的函数 虚函数是实现这个思想的语法基础 特点： 父类指针指向子类空间，CFather* p = new CSon。但是不能调用子类的函数。 形式 virtual void fun() 。 子类的函数 要和这个函数一样。 多个子类，换子类就调用子类的。 多态针对于指针对象，即父类的一个指针，可以有多种执行状态，即多态。 #include &lt;iostream> using namespace std; class CFather { public: // 重写 virtual void Show() { cout &lt;&lt; \"class CFather\" &lt;&lt; endl; } }; class CSon : public CFather { public: int aa; void Show() { cout &lt;&lt; \"class CSon\" &lt;&lt; endl; } }; class CSon1 : public CFather { public: int aa; void Show() { cout &lt;&lt; \"class CSon1\" &lt;&lt; endl; } }; int main() { // 创建对象 CFather* fa = new CSon1; //普通的只能调用属于父类的成员 fa->Show(); return 0; } 虚函数的特点 父类和子类相同，父类是虚函数。叫做重写 虚函数只是针对于函数成员。 子类重写的函数，默认是虚函数，可以显示加virtual，也可以不加。 名字参数相同。 返回值类型相同，重写。 返回值类型不同(只能是当前所在类)，协变。 虚函数不是内联函数。 构造函数不能是虚函数。 #include &lt;iostream> using namespace std; class CFather { public virtual void fun() { cout &lt;&lt; \"hello\" &lt;&lt; endl; } virtual CFather&amp; Show() { cout &lt;&lt; \"class CFather\" &lt;&lt; endl; return (*this); } }; class CSon : public CFather { public: int aa; //虚函数针对于函数成员 virtual CSon&amp; Show() { cout &lt;&lt; \"class CSon\"&lt;&lt; endl; return (*this); } }; int main() { CFather* fa = new CSon; //普通的只能调用属于父类的成员 fa->Show(); return 0; } 虚表 对象空间的最开始四字节内容，就是虚表（虚函数列表）的地址，叫虚指针。 取虚表地址： 取到的是函数地址，想要调用，要转换成对应类型的函数指针 #include &lt;iostream> using namespace std; class CFather { public: virtual void fun() { cout &lt;&lt; \"fun\" &lt;&lt; endl; } virtual void Show(int a) { cout &lt;&lt; \"class CFather\\n\"; } }; class CSon : public CFather { public: virtual void Show(int a) { cout &lt;&lt; \"class CSon\\n\"; } }; int main() { CFather* fa = new CSon; // 申明函数指针 typedef void (*p)(); typedef void (__stdcall *p1)(int); ((p)(*((int*)*(int*)fa + 0)))(); ((p1)(*((int*)*(int*)fa + 1)))(12); int* pp = (int*)*((int*)*(int*)fa + 2); return 0; } 虚析构 delete哪个类型的指针，就调用谁的析构函数。多态中，如果释放父类指针，只会调用父类的析构函数，所以加了虚析构，就会子类父类都调用了。 #include &lt;iostream> using namespace std; class CFather { public: ~CFather() { cout &lt;&lt; \"CFather\" &lt;&lt; endl; } }; class CSon : public CFather { public: ~CSon() { cout &lt;&lt; \"CSon\" &lt;&lt; endl; } }; class CXiaoMing { public: ~CXiaoMing() { cout &lt;&lt; \"CXiaoMing\" &lt;&lt; endl; } }; int main() { CFather* fa = new CSon; delete (CXiaoMing*)fa; system(\"pause\"); return 0; } 纯虚函数纯虚函数形式: &gt; virtual void fun() = 0；特点 可以没有函数实现 继承这个基类的子类必须实现它，才能定义对象 抽象类 有纯虚函数的就是抽象类. 接口类 全是纯虚函数的，叫接口类. 可以有构造函数，和成员什么的 #include &lt;iostream> using namespace std; class CFather { public: int a; CFather(){}; virtual void fun() = 0; //有纯虚函数的类，必须用子类重写该纯虚函数，才能实例化对象， //有纯虚函数的类 不能够创建对象 virtual void guu() = 0; virtual ~CFather() = 0; }; class CSon : public CFather { public: void fun() { cout &lt;&lt; \"CSOn\" &lt;&lt; endl; } }; int main() { //CSon pf; return 0; } 虚继承 虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。 父类叫做虚基类。 解决多继承中访问不明确的问题。 不建议用，结构复杂，内存开销比较大。 代码实现： #include &lt;iostream> using namespace std; class CA { public: int a; }; class CB : virtual public CA { public: }; class CC : virtual pubc CA { public: }; class CD : public CB, public CC { public: }; int main() { CD d; d.a; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"C语言之函数","slug":"C语言/C语言之函数","date":"2019-11-02T07:46:24.000Z","updated":"2020-05-17T06:17:55.953Z","comments":true,"path":"2019/11/02/c-yu-yan/c-yu-yan-zhi-han-shu/","link":"","permalink":"http://yoursite.com/2019/11/02/c-yu-yan/c-yu-yan-zhi-han-shu/","excerpt":"","text":"函数的定义1.逻辑上：能够完成特定功能的独立的代码块。 2.物理上：能够接收数据【也可以不接收数据】，能够对接收的数据进行处理【也可以不对数据进行处理】，能够将数据处理的结果返【也可以没有返回值】。 3.函数定义的本质：详细描述函数之所以能够实现某个特定功能的具体方法。 语法 返回值类型 函数名（形式参数列表） { 函数体； } 返回值类型：用户需要函数返回的数据类型。函数名：代表的是函数的入口地址。形式参数列表：就是用户将函数外部数据传入函数内部的 局部变量。函数体：函数的具体功能代码。 代码示例 void max() { printf(\"最大值是:%d\\n\") } 形式参数列表（形参）形参在函数定义的时候没有空间,只有在调用函数的时候形参才有空间。函数调用完形参自动释放。 代码示例 void max(int a, int b) 注意：在定义函数的时候，不要给形参赋值 函数存在的意义 避免了重复性操作。 有利于程序的模块化 代码实现# include &lt;stdio.h> // 函数声明 void max(int i, int j) { //max是函数的名字, i和j是形式参数，简称形参 void表示函数没有返回值 if (i > j){ printf(\"%d\\n\", i); }else{ printf(\"%d\\n\", j); } } int main(void) { // 1.定义变量 int a, b, c, d, e, f; a = 1, b = 2; c = 3, d = 9, e = -5, f = 100; // 调用函数 max(a, b); max(c, d); max(e, f); /* if (a > b) printf(\"%d\\n\", a); else printf(\"%d\\n\", b); if (c > d) printf(\"%d\\n\", c); else printf(\"%d\\n\", d); if (e > f) printf(\"%d\\n\", e); else printf(\"%d\\n\", f); */ return 0; } return 表达式含义return是终止被调函数，向主调函数返回表达式的值，如果表达式为空，则只终止函数，不向被主函数返回任何值。 代码示例 # include &lt;stdio.h> int f() { //因为函数的返回值类型是int 所以最终f返回的是10而不是10.5 return 10.5; } int main(void) { int i = 99; double x = 6.6; x = f(); printf(\"%lf\\n\", x); return 0; } Break语句 是用来终止（就近的）循环和switch语句。而return是用来终止被调函数的。 # include &lt;stdio.h> void fmin(void) { int i; for (i=0; i&lt;5; ++i) { printf(\"大家辛苦了!\\n\"); return; //return是终止函数的 } printf(\"同志们好!\\n\"); } int main(void) { fmin(); return 0; } 函数的分类 有参函数和无参函数。 有返回值和无返回值。 库函数和用户自定义函数。 普通函数和主函数（main函数) 注意事项1.一个程序有且只有一个主函数。 2.主函数可以调用普通函数，普通不能调用主函数。 3.普通函数可以相互调用。 4.主函数是程序的入口，也是函数的出口。值传递函数和地址传递函数。 代码示例 # include &lt;stdio.h> //max是函数的名字, i和j是形式参数，简称形参 void表示函数没有返回值 void max1(int i, int j) { if (i > j) printf(\"%d\\n\", i); else printf(\"%d\\n\", j); } int max2(int i, int j) { if (i > j) return i; else return j; } int main(void) { int a, b, c, d, e, f; a = 1, b = 2; c = 3, d = 9, e = -5, f = 100; printf(\"%d\\n\", max2(a, b)); printf(\"%d\\n\", max2(c, d)); printf(\"%d\\n\", max2(e, f)); /* max1(a, b); max1(c, d); max1(e, f); */ return 0; } 例子声明//判断一个数是否素数，该数只能被1和本身整除 # include &lt;stdio.h> bool IsPrime(int val) { // 1.定义变量 int i; // 2.变量循环 for (i=2; i&lt;val; ++i) { if (val%i == 0) break; } if (i == val) return true; else return false; } int main(void) { int m; scanf(\"%d\", &amp;m); if ( IsPrime(m) ) printf(\"Yes!\\n\"); else printf(\"No!\\n\"); return 0; } 函数的声明# include &lt;stdio.h> void fmax(void); //函数声明， 分号不能丢掉 int main(void) { fmax(); return 0; } void fmax(void) { printf(\"哈哈!\\n\"); } 注意 当函数没有返回值时，那么规范的写法是要在函数中写明void的。如果函数调用写在了函数定义的前面，则必须加函数前置声明。 代码示例 # include &lt;stdio.h> //void fmin(void); //9行 void gmin(void) { fmin(); //因为函数f的定义放在了调用f语句的后面，所有语法出错 } void fmin(void) { printf(\"哈哈!\\n\"); } int main(void) { gmin(); return 0; } 形参和实参的关系 形参和实参个数是一一对应的。 形参和实参的位置也是一一对应的。 形参和实参的数据类型需要相互兼容。 # include &lt;stdio.h> void f(int i, float x) //形参 { printf(\"%d\\n\", i); } int main(void) { f(9.9, 6.6); //实际参数 return 0; } 案列1判断一个数是否是素数 代码示例 # include &lt;stdio.h> // 判断一个数是否是素数 int main(void) { int val; int i; scanf(\"%d\", &amp;val); for (i=2; i&lt;val; ++i) { if (0 == val%i) break; } if (i == val) printf(\"Yes!\\n\"); else printf(\"No!\\n\"); return 0; } 函数版代码示例 # include &lt;stdio.h> // 判断一个数是否是素数，函数实现 bool IsPrime(int val) { int i; for (i=2; i&lt;val; ++i) { if (0 == val%i) break; } if (i == val) return true; else return false; } int main(void) { int val; int i; scanf(\"%d\", &amp;val); if ( IsPrime(val) ) printf(\"Yes!\\n\"); else printf(\"No!\\n\"); return 0; } 案例2求1到某个数字之间(包括该数字)所有的素数。 代码示例 /* 求1到某个数字之间(包括该数字)所有的素数，并将其输出 只用main函数实现，有局限性： 1. 代码的重用性不高 2. 代码不容易理解 */ # include &lt;stdio.h> int main(void) { int val; int i; int j; scanf(\"%d\", &amp;val); for (i=2; i&lt;=val; ++i) { //判断i是否是素数，是输出，不是不输出 for (j=2; j&lt;i; ++j) { if (0 == i%j) break; } if (j == i) printf(\"%d\\n\", i); } return 0; } 函数代码示例 /* 用两个函数来实现求1到某个数字之间所有的素数，并将其输出 代码量更少，可重用性更高 */ # include &lt;stdio.h> //本函数的功能是: 判断m是否是素数，是返回true，不是返回false bool IsPrime(int m) { int i; for (i=2; i&lt;m; ++i) { if (0 == m%i) break; } if (i == m) return true; else return false; } //本函数的功能是把1到n之间所有的素数在显示器上输出 void TraverseVal(int n) { int i; for (i=2; i&lt;=n; ++i) { if ( IsPrime(i) ) printf(\"%d\\n\", i); } } int main(void) { int val; scanf(\"%d\", &amp;val); TraverseVal(val); return 0; } 变量的作用域局部变量局部变量 在一个函数内部定义的变量或者函数的形参，都统称为局部变量。 void f(int i) { int j = 20; } i和j都是局部变量 局部变量的使用范围只能在本函数内部使用 全局变量在所有函数外部定义的变量叫做全局变量。 全局变量使用范围:从定义位置开始到整个程序结束。 代码示例# include &lt;stdio.h> /* 一定要明白该程序为什么是错的， 也要明白把9到12行代码放在14行后面，为什么程序就OK了 */ void gmin() //9 { printf(\"k = %d\\n\", k); } //12 int k = 1000; //14行 void fmax(void) { gmin(); printf(\"k = %d\\n\", k); } int main(void) { fmax(); return 0; } 变量命名冲突 在同一个范围之内不能定义两个一样的局部变量 /* 在一个函数内部，如果定义的局部函数的名字和全局变量名一样时， 局部变量会屏蔽掉全局变量，上例中最终的输出结果是8。 因为局部变量把全局变量给屏蔽掉了 */ # include &lt;stdio.h> int i = 99; void fmax(int i) { printf(\"i = %d\\n\", i); } int main(void) { fmax(8); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}]},{"title":"C语言变量属性","slug":"C语言/C语言之变量属性","date":"2019-05-12T03:06:02.000Z","updated":"2020-05-12T03:21:59.640Z","comments":true,"path":"2019/05/12/c-yu-yan/c-yu-yan-zhi-bian-liang-shu-xing/","link":"","permalink":"http://yoursite.com/2019/05/12/c-yu-yan/c-yu-yan-zhi-bian-liang-shu-xing/","excerpt":"","text":"变量属性C语言中的变量可以有自己的属性，在定义变量的时候可以加上“属性“关键字。 属性关键字指明变量的特殊意义。 auto关键字 auto是C语言中局部变量的默认属性。 auto表明将被修饰的变量存储于栈上。 编译器默认所有的局部变量都是auto的。 代码示例 void f() { int i; // 局部变量默认属性为auto auto int j; // 显示声明auto属性 } register关键字 register关键字指明将局部变量存储于寄存器中。 register只是请求寄存器变量，但是不一定请求成功。 register变量必须是CPU寄存器可以接受的值。 不能用&amp;运算符获取register变量的地址。 代码示例 #include &lt;stdio.h> register int g_v; // error int main() { register char var; print(\"8x%88x\", &amp;var) // error return 0； } static关键字1、static关键字指明变量的静态属性。 static修饰的局部变量存储在程序静态区。 2、static关键字同时具有作用域限定符的意义。 static修饰的全局变量作用域只是声明的文件中。 static修饰的函数作用域只是声明的文件中。 代码示例 #include &lt;stdio.h> int g_v; // 全局变量，程序的任意地方均能访问 static int g_vs; // 静态全局变量，只有当前文件中可以访问。 int main() { int var; // 局部变量，在栈上分配空间。 static int var; // 静态局部变量，在静态数据区分配空间。 return 0; } 实例分析#include &lt;stdio.h> // 定义f1函数 int f1() { int r = 0; r++; return r; } // 定义f2函数 int f2() { static int r = 0; r++; return r; } int main() { auto int i = 0; // 显示声明 auto 属性，i 为栈变量 static int k = 0; // 局部变量 k 的存储区位于静态区，作用域位于 main 中 register int j = 0; // 向编译器申请将 j 存储于寄存器中 printf(\"%p\\n\", &amp;i); printf(\"%p\\n\", &amp;k); printf(\"%p\\n\", &amp;j); // error for(i=0; i&lt;5; i++) { printf(\"%d\\n\", f1()); } for(i=0; i&lt;5; i++) { printf(\"%d\\n\", f2()); } return 0; } 图示： extern关键字extern用于声明“外部”定义的变量和函数。 extern变量在文件的其他地方分配空间。 extern函数在文件的其他地方定义。 代码示例 #include &lt;stdio.h> extern int getI(); int main() { printf(\"%d\\n\", getI()); return 0; } static int g_i; int getI() { return g_i; } const关键字const只读变量 const修饰变量是只读的，本质上还是变量。 const修饰的局部变量在栈上分配空间。 const修饰的全局变量在全局数据区分配空间。 const只是在编译期有用,在运行其无效果。 注意： const修饰的变量不是真正的常量，他只是告诉编译器该变量不能出现在赋值符号的左边。 const全局变量的分歧1、在现代C语言编译器中，修改const全局变量将导致程序崩溃。 2、标准C语言编译器不会将const修饰的全局变量存储于只读存储区中，而是存储于可修改的全局数据区，其值依然可以改变。 代码示例 #include &lt;stdio.h> // 定义全局变量 const int g_cc = 2; int main() { const int cc = 1; printf(\"cc = %d\\n\", cc); // 通过指针修改内存空间的地址 int* p = (int*)&amp;cc; *p = 3; printf(\"cc = %d\\n\", cc); p = (int*)&amp;g_cc; printf(\"g_cc = %d\\n\", g_cc); // 修改内存空间 *p = 4; printf(\"g_cc = %d\\n\", g_cc); return 0; } const的本质 C语言中的const使得变量具有只读属性。 现代C编译器中的const将具有全局生命周期的变量存储于只读存储区。 const不能定义真正意义上的常量。 代码示例 #include &lt;stdio.h> // 定义一个const类型的全局数组 const int g_array[5] = {0}; // 定义modify函数 void modify(int* p, int v) { *p = v; } int main() { int const i = 0; const static int j = 0; int const array[5] = {0}; modify((int*)&amp;i, 1); // ok modify((int*)&amp;j, 2); // error modify((int*)&amp;array[0], 3); // ok modify((int*)&amp;g_array[0], 4); // error printf(\"i = %d\\n\", i); printf(\"j = %d\\n\", j); printf(\"array[0] = %d\\n\", array[0]); printf(\"g_array[0] = %d\\n\", g_array[0]); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}]},{"title":"C语言之结构体类型","slug":"C语言/C语言之结构体类型","date":"2019-05-12T03:06:02.000Z","updated":"2020-05-27T17:03:12.716Z","comments":true,"path":"2019/05/12/c-yu-yan/c-yu-yan-zhi-jie-gou-ti-lei-xing/","link":"","permalink":"http://yoursite.com/2019/05/12/c-yu-yan/c-yu-yan-zhi-jie-gou-ti-lei-xing/","excerpt":"","text":"为什么需要结构体为了表示一些复杂的事物，而普通的基本类型无法满足实际要求。 代码示例 # include &lt;stdio.h> struct Student { int age; float score; char sex; }; int main(void) { struct Student st = {80, 66.6, 'F'}; /* int age; float score; char sex; int age2; float score2; char sex2; */ return 0; } 结构体定义结构体方式 # include &lt;stdio.h> //第一种方式 struct Student { int age; float score; char sex; }; //第二种方式 struct Student2 { int age; float score; char sex; } st2; //第三种方式 struct { int age; float score; char sex; } st3; int main(void) { struct Student st = {80, 66.6, 'F'}; return 0; } 使用结构体1、赋值和初始化 定义的同时可以整体赋值。 如果定义完之后，则只能单个赋初值。 2.如果取出结构体变量中的每一个成员 结构体变量名.成员名 指针变量名-&gt;成员名 （更常用） 它会在计算机内部转化成 (* 指针变量名).成员名 的方式来执行，所以两者是等价的。 取出结构体变量成员# include &lt;stdio.h> //第一种方式 struct Student { int age; float score; char sex; }; int main(void) { /* 1、 pst->age 会在计算机内部转化成 (*pst).age的方式来执行,这就是->的含义。 2、 所以 pst->age 等价于 (*pst).age 也等价于 st.age 3、 pst->的含义：pst 所指向的那个结构体变量中的age这个成员。 */ struct Student st = {80, 66.6F, 'F'}; //初始化 定义的同时赋初值 struct Student * pst = &amp;st; //&amp;st不能改成st st.score = 66.6f; //如果希望一个实数是float类型，则必须在末尾加f或F. pst->age = 88;//第二种方式 printf(\"%d %f\\n\", st.age, pst->score); return 0; } 注意 结构体变量的大小略大于其内部成员类型所占字节数之和。 若想通过函数对主函数结构体变量进行修改，则主函数必须发送地址，外函数定义指针结构体变量，通过外函数内部语句完成对变量的修改。而仅想输出、读取操作，则不用传地址，定义指针过程。 发送地址/* 发送地址还是发送内容 目的:指针的优点之一:快速的传递数据，耗用内存小执行速度快 */ # include &lt;stdio.h> # include &lt;string.h> struct Student { int age; char sex; char name[100]; }; //分号不能省 void InputStudent(struct Student *); void OutputStudent(struct Student *); int main(void) { struct Student st ; //printf(\"%d\\n\", sizeof(st)); InputStudent(&amp;st); //对结构体变量输入 必须发送st的地址 OutputStudent(&amp;st); //对结构体变量输出 return 0; } void OutputStudent(struct Student *pst) { printf(\"%d %c %s\\n\", pst->age, pst->sex, pst->name); } void InputStudent(struct Student * pstu) //pstu只占4个字节 { (*pstu).age = 10; strcpy(pstu->name, \"张三\"); pstu->sex = 'F'; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}]},{"title":"C语言之内存管理","slug":"C语言/C语言之内存管理","date":"2019-05-12T03:06:02.000Z","updated":"2020-05-15T19:11:19.791Z","comments":true,"path":"2019/05/12/c-yu-yan/c-yu-yan-zhi-nei-cun-guan-li/","link":"","permalink":"http://yoursite.com/2019/05/12/c-yu-yan/c-yu-yan-zhi-nei-cun-guan-li/","excerpt":"","text":"动态内存分配传统数组的缺点 1.数组长度必须事先指定，而且只能是常整数，不能是变量。 代码示例 例子int a[5]; //必须事先指定，而且只能是常整数int len = 5; int a[len];//error 2.传统形式定义的数组，该数组的内存程序员无法手动释放数组一旦定义，系统为数组分配的内存空间就会一直存在，除非数组所在的函数运行终止，数组的空间才会被系统自动释放（不是清零)。。 void f(void) { //数组a 占20个字节的内存空间，无法手动编程释放它，数组a只能在f()函数结束被系统释放 int a[5]={1,2,3,4,5}; } 3、数组的长度一旦定义，数组长度就不能再更改。 数组的长度不能在函数运行的过程中动态的扩充或缩小。 4、传统方式定义的数组不能跨函数使用 。 A函数定义的数组，只有在A函数运行期间才可以被其他函数使用。 但A函数运行完毕后，A函数中的数组将无法在被其他函数使用。 代码示例# include &lt;stdio.h> void gmin(int * pArr, int len) { pArr[2] = 88; //pArr[2] == a[2] } void fmax(void) { /* 20个字节的存储空间程序员无法手动编程释放它，它只能在本函数运行完毕时由系统自动释放 */ int a[5] = {1,2,3,4,5}; gmin(a, 5); printf(\"%d\\n\", a[2]); } int main(void) { fmax(); return 0; } 动态内存分配 很好的解决的了传统数组的4个缺陷 ( malloc的使用 ) 代码示例 # include &lt;stdio.h> # include &lt;malloc.h> #include &lt;string.h> void test() { int * p = NULL; p = (int *)malloc(sizeof(int)); if(p == NULL){ perror(\"malloc\"); return ; } //清空空间 memset(p, 0, sizeof(int)); *p = 10; printf(\"*p=%d\\n\", *p); free(p); // 释放 } int main() { // 调用函数 test(); return 0; } malloc实现图解图示： 代码示例# include &lt;stdio.h> # include &lt;malloc.h> void fmin(int * q) { //*p = 200; //error //q = 200; //200不是整型变量的地址，q只能存放整型变量的地址 //**q = 200; //error *q = 200; //free(q); //把q所指向的内存释放掉 本语句必须的注释掉，否则会导致第20行的代码出错 } int main(void) { int * p = (int *)malloc(sizeof(int)); //sizeof(int)返回值是int所占的字节数 *p = 10; printf(\"%d\\n\", *p); //10 fmin(p); //p是int *类型 printf(\"%d\\n\", *p); //200 第20行 return 0; } 图解 动态一维数组示例代码示例# include &lt;stdio.h> # include &lt;malloc.h> int main(void) { //如果int占4个字节的话，则本数组总共包含有20个字节，每四个字节被当做了一个int变量来使用 int a[5]; int len; int * pArr; int i; //动态的构造一维数组 printf(\"请输入你要存放的元素的个数: \"); scanf(\"%d\", &amp;len); /* 本行动态的构造了一个一维数组, 该一维数组的产度是len, 该数组的数组名是pArr. 该数组的每个元素是int类型 类似于 int pArr[len]; */ pArr = (int *)malloc(4 * len); //对一维数组进行操作， 如：对动态一维数组进行赋值 for (i=0; i&lt;len; ++i) scanf(\"%d\", &amp;pArr[i]); //对位一维数组进行输出 printf(\"一维数组的内容是:\\n\"); for (i=0; i&lt;len; ++i){ printf(\"%d\\n\", pArr[i]); } free(pArr); //释放掉动态分配的数组 return 0; 图解动态一维数组 动态数组的优点1.动态数组长度不需要事先给定； 2.内存空间可以手动释放。 3.在程序运行中，动态内存空间大小可以通过realloc函数手动扩充或缩小 静态内存和动态内存的比较- 静态内存是由系统自动分配，有系统自动释放 - 静态内存是在栈分配的 - 动态内存是由程序员手动分配、手动释放 - 动态内存是在堆分配的 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}]},{"title":"指针强化","slug":"C语言/指针强化","date":"2019-05-12T03:06:02.000Z","updated":"2020-05-17T04:08:01.503Z","comments":true,"path":"2019/05/12/c-yu-yan/zhi-zhen-qiang-hua/","link":"","permalink":"http://yoursite.com/2019/05/12/c-yu-yan/zhi-zhen-qiang-hua/","excerpt":"","text":"多级指针多级指针案例1# include &lt;stdio.h> int main(void) { int i = 10; int * p = &amp;i; //p只能存放int类型变量的地址 int ** q = &amp;p; //q是int **类型，所谓int**类型就是指q只能存放int*类型变量的地址， int *** r = &amp;q; //r是int***类型, 所谓int***类型就是指r只能存放int ** 类型变量的地址 //r = &amp;p; //error 因为r是int *** 类型，r只能存放int **类型变量的地址 //输出结果是10 只有 ***r才表示的是i, *r或 **r或 ****r代表的都不是i printf(\"i = %d\\n\", ***r); return 0; } 多级指针案列2#include &lt;stdio.h> //多级指针在函数中的应用 void fmax(int ** q) { **q = 100; //*q就是p } void gmin() { int i = 10; int * p = &amp;i; printf(\"i = %d *p = %d\\n\", i, *p); fmax(&amp;p); //p是int *类型 &amp;p就是int ** 类型 printf(\"i = %d *p = %d\\n\", i, *p); } int main(void) { gmin(); return 0; } 静态变量不能跨函数使用 内存越界：程序访问了一个不该被访问的内存,函数内的静态空间，不能被其他函数调用访问。 函数中的内存空间，随函数终止而被释放。内存空间释放后的内容不属于其他函数，其他函数无权限访问。但释放后的内存空间的地址是可以被其他函数读取的。 但指针变量可以存贮任何函数中静态内存空间的地址，p都能存垃圾，p想存谁存谁。只是它此时已经没有权限读取（访问）i这个地址的数据了，出错。 代码示例 # include &lt;stdio.h> void fmin(int ** q) //q是个指针变量，无论q是什么类型的指针变量，都只占4个字节 { int i = 5; //*q等价于p q和**q都不等价于p //*q = i; //error 因为*q = i; 等价于 p = i; 这样写是错误的 *q = &amp;i; // p = &amp;i; } int main(void) { int *p; fmin(&amp;p); printf(\"%d\\n\", *p); // 本语句语法没有问题，但逻辑上有问题 return 0; } 动态内存可以跨函数使用案例# include &lt;stdio.h> # include &lt;malloc.h> void fmax(int ** q) //*q等价p 已经声明了q的类型为int ** { *q = (int *)malloc(sizeof(int)); //sizeof(数据类型) 返回值是该数据类型所占的字节数 //等价于 p = (int *)malloc(sizeof(int)); //q = 5; //error //*q = 5; //p = 5; **q = 5; //*p = 5; } int main(void) { int * p; fmax(&amp;p); //只有调用变量的地址，才能改变变量的值 printf(\"%d\\n\", *p); //fmax函数中，没有free(q);所以动态空间仍然保留，动态空间中的内容可以被访问 return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}]},{"title":"C语言之指针函数","slug":"C语言/C语言之指针函数","date":"2019-05-12T03:06:02.000Z","updated":"2020-05-17T03:16:57.938Z","comments":true,"path":"2019/05/12/c-yu-yan/c-yu-yan-zhi-zhi-zhen-han-shu/","link":"","permalink":"http://yoursite.com/2019/05/12/c-yu-yan/c-yu-yan-zhi-zhi-zhen-han-shu/","excerpt":"","text":"函数参数普通变量作为函数的参数代码示例 #include &lt;stdio.h> // 声明函数 void ChangeNumValue(int a) { a = 10000; } int main() { // 定义变量 int num = 10; // 调用函数 ChangeNumValue(num); printf(\"num = %d\\n\", num); return 0; } 图示 程序运行结果 num = 10 指针变量作为函数的形参代码示例 #include &lt;stdio.h> // 声明函数 void ChangeNumValue(int *p) { *p = 10000; } int main() { // 定义变量 int num = 10; // 调用函数 ChangeNumValue(&amp;num); printf(\"num = %d\\n\", num); return 0; } 程序运行结果 num = 10000 图示 重点： 如果想在函数内部修改外部变量的值，请传外部变量的地址。 经典案例互换数字 # include &lt;stdio.h> void swap1(int , int); void swap2(int *, int *); void swap3(int *, int *); int main(void) { int a = 3; int b = 5; huhuan_3(&amp;a, &amp;b); //swap2(*p, *q); 是错误的, swap2(a, b);也是错误的 printf(\"a = %d, b = %d\\n\", a, b); return 0; } //不能完成互换功能 void swap1(int a, int b) { int t; t = a; a = b; b = t; return; } //不能完成互换功能 void swap2(int * p, int * q) { int * t;//如果要互换p和q的值，则t必须是int *,不能是int,否则会出错 t = p; p = q; q = t; } //可以完成互换功能 void swap3(int * p, int * q) { int t; //如果要互换*p和*q的值, 则t必须定义成int,不能定义成int *, 否则语法出错 t = *p; //p是int *, *p是int *p = *q; *q = t; } 数组名作为函数的参数代码示例 #include &lt;stdio.h> #include &lt;ntdef.h> // 声明函数 void PrintIntArray(int *arr, int n) { // 遍历数组 for (int i = 0; i &lt; n; i++) { printf(\"%d \", arr[i]);//arr[i] == *(arr+i) } printf(\"\\n\"); } //定义一个函数给arr元素获取键盘输入 void InputIntArray(int *arr, int n) { printf(\"请输入%d个int数据\\n\",n); for (int i = 0; i &lt; n; i++) { scanf(\"%d\", arr+i);//&amp;arr[i] == &amp;*(arr+i) == arr+i } } //定义一个函数 求出arr数组的最大值 void MaxInt(int *arr, int n, int *p_max)//p_max = &amp;max { int tmp_max = arr[0]; for (size_t i = 0; i &lt; n; i++) { if (tmp_max &lt; arr[i]) { tmp_max = arr[i]; } } //将tmp_max值 通过p_max 间接赋值给外部变量max //*p_max == max *p_max = tmp_max;//max = tmp_max } int main() { // 定义数组 int arr[5] = {1,2,3,4,8}; int n = sizeof(arr) / sizeof(arr[0]); printf(\"数组的总大小n=%d\\n\", sizeof(arr));//数组的总大小 20 // 调用函数 InputIntArray(arr, n); int max = 0; //调用函数 MaxInt(arr,n, &amp;max); printf(\"max = %d\\n\", max); // 调用函数 PrintIntArray(arr, n); //函数内部 操作（读/写)外部数组元素,请将外部数组名传递给函数的形参 return 0; } 程序运行结果 数组的总大小n=20 请输入5个int数据 8 9 44 33 30 max = 44 8 9 44 33 30 *号的三种含义 乘法 定义指针变量。Int * p，定义了一个名字叫p的变量，int *表示p只能存放int变量的地址。 指针运算符。该运算符是放在已经定义好的指针变量的前面。如果p是一个已经定义好的指针变量，则*P表示以p的内容为地址的变量。注意理解形参，实参，和局部变量的关系。 基本类型指针# include &lt;stdio.h> int main(void) { int * p;//等价于 int *p; 也等价于 int* p; int i = 5; char ch = 'A'; p = &amp;i; // *p 以p的内容为地址的变量 *p = 99; printf(\"i = %d, *p = %d\\n\", i, *p); //p = &amp;ch; //p = ch; //error //p = 5; //error return 0; } 程序运行结果 i=99 *p=99 函数类型指针指针可以是函数返回一个以上的值 # include &lt;stdio.h> void swap1(int i, int j) { int t; t = i; i = j; j = t; } void swap2(int * p, int * q) { int * t; t = p; p = q; q = t; } void swap3(int * p, int * q) //形参名字是p和q，接收实参数据的是p和q，而不是*p和*q { int t; t = *p; *p = *q; *q = t; } int main(void) { int a = 3; int b = 5; swap_3(&amp;a, &amp;b); printf(\"a = %d, b = %d\\n\", a, b); return 0; } 通过被调函数修改主调函数的值 1.实参必须是该普通变量的地址。 2.形参必须是指针变量。 3.在被调中通过*形参名的方式就可以修改主调函数相关变量的值。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}]},{"title":"C语言之指针数组","slug":"C语言/C语言之指针数组","date":"2019-05-12T03:06:02.000Z","updated":"2020-05-15T08:47:23.939Z","comments":true,"path":"2019/05/12/c-yu-yan/c-yu-yan-zhi-zhi-zhen-shu-zu/","link":"","permalink":"http://yoursite.com/2019/05/12/c-yu-yan/c-yu-yan-zhi-zhi-zhen-shu-zu/","excerpt":"","text":"指针数组 本质是数组 只是每个元素的类型是指针。 图示 代码示例 #include &lt;stdio.h> int main() { int num1 = 10; int num2 = 20; int num3 = 30; int num4 = 40; int *arr[4] = {&amp;num1, &amp;num2,&amp;num3,&amp;num4}; int n = sizeof(arr) / sizeof(arr[0]); for (size_t i = 0; i &lt; n; i++) { printf(\"%d \", *arr[i]); } return 0; } 一维数组代码示例 #include &lt;stdio.h> int main() { // 1.定义数组 int arr[5] = { 10,20,30,40,50 }; //arr作为类型 printf(\"sizeof(arr) = %d\\n\",sizeof(arr));//数组的总大小 //arr作为地址 代表首元素的地址 printf(\"arr = %u\\n\", arr);//int * printf(\"arr+1 = %u\\n\", arr+1); printf(\"arr[1] = %d\\n\", arr[1]);//20 printf(\"*(arr+1) = %d\\n\", *(arr+1));//20 printf(\"---------------------\\n\"); //arr[1]展开成*（arr+1）:[]外边的值 在+的左边 []里面的值在+的右边 printf(\"*(1+arr) = %d\\n\", *(1 + arr));//20 printf(\"1[arr] = %d\\n\", 1[arr]);//20 //[] 是 *() 的缩写(重要) for (int i = 0; i &lt; sizeof(arr)/sizeof(arr[0]); i++) { //printf(\"%d \", arr[i]); printf(\"%d \", i[arr]); } printf(\"\\n\"); //arr 作为地址 是首元素的地址 //&amp;arr[0] == &amp;*(arr+0) == arr+0 == arr return 0; } 程序运行结果 一维数组名一维数组名是个指针常量，他存放的是一维数组第一个元素的地址 。 代码示例 #include &lt;stdio.h> int main(void) { int a[5]; //a是数组名 5是数组元素的个数 元素就是变量 a[0] -- a[4] //int a[3][4]; //3行4列 a[0][0]是第一个元素 a[i][j]第i+1行j+1列 int b[5]; //a = b;//error a是常量 printf(\"%#X\\n\", &amp;a[0]); printf(\"%#X\\n\", a); return 0; } 程序运行结果 总结 一维数组名是个指针常量。 它存放的是一维数组第一个元素的地址。 常量是不能被改变的，也就是说，一维数组名是不能被改变的。 数组名a存放的是一维数组第一个元素的地址，也就是a = &amp;a。 下标和指针的关系如果p是个指针变量，则p[i]永远等价于*(p+i) # include &lt;stdio.h> int main(void) { int a[5] = {1,2,3,4,5}; int i; for (i=0; i&lt;5; ++i) printf(\"%d\\n\", a[i]); //a[i] == *(a+i) return 0; } 数组元素指针代码示例 #include &lt;stdio.h> int main() { /** * 需求：定义一个指针变量 保存arr数组元素的地址 */ // 声明一个数组 int arr[5] = { 10,20,30,40,50 }; int *p = arr;//int *p; p=arr; for (int i = 0; i &lt; sizeof(arr)/sizeof(arr[0]); i++) { //printf(\"%d \", *(p + i)); printf(\"%d \", p[i]); } printf(\"\\n\"); printf(\"sizeof(arr) = %d\\n\", sizeof(arr));//20 printf(\"sizeof(p) = %d\\n\", sizeof(p));//4 /** *不要认为p只能保存首元素地址 * 指针变量 起始指向哪儿？ p[x] == *(p+x) */ int *p1 = &amp;arr[2]; printf(\"p1[1] = %d\\n\", p1[1]);//40 printf(\"p1[-1] = %d\\n\", p1[-1]);//20 return 0; } 程序运行结果 案例说明#include &lt;stdio.h> int main() { int arr[5] = { 10,20,30,40,50 }; int *p = arr; printf(\"%d\\n\", *p++);//10;; *p; p++ printf(\"%d\\n\", (*p)++);//20 ; *p; (*p) = (*p) +1 printf(\"%d\\n\", *(p++));//21 printf(\"\\n\"); return 0; } 程序运行结果 10 20 21 同一数组的两个元素指针的关系 指向同一数组的两个元素指针变量相减,是两指针变量间元素的个数。 指向同一数组的两个元素指针变量相加，无意义。 指向同一数组的两个元素指针变量 p1 = p2(p1和p2指向同一处)。 一维数组需要几个参数代码示例# include &lt;stdio.h> /* a是个指针变量，所以上面局部函数f的pArr则要定义成指针函数才可以，而len则是int类型。 代表接收的是整型的数字。fmin函数可以输出任何一个一维数组的内容 */ // 声明函数 void fmax(int * pArr, int len) { int i; for (i=0; i&lt;len; ++i) printf(\"%d \", pArr[i] ); //*pArr *(pArr+1) *(pArr+2) printf(\"\\n\"); } int main(void) { int a[5] = {1,2,3,4,5}; int b[6] = {-1,-2,-3,4,5,-6}; // 调用函数 fmax(a, 5); //a是 int * fmax(b, 6); return 0; } 总结： 因为数组a的名称代表的是a的第一个元素的地址，所以在函数fmax中所定义的指针变量pArr和a是相同的，因为a也是指针变量类型。 也就是说pArr=a=a[0],pArr[1]=a[1]=*(pArr+1)=*(a+1),pArr[2]=a[2]=*(pArr+2) =*(a+2). 二级指针图示 代码示例 #include &lt;stdio.h> int main() { int num = 10; int *p = &amp;num; int **q = &amp;p; printf(\"&amp;num = %u\\n\", &amp;num); printf(\"p = %u\\n\", p); printf(\"&amp;p = %u\\n\", &amp;p); printf(\"q = %u\\n\", q); printf(\"*q = %u\\n\", *q); printf(\"**q = %u\\n\", **q); return 0; } 程序运行结果 &amp;num = 6422036 p = 6422036 &amp;p = 6422024 q = 6422024 *q = 6422036 **q = 10 地址变量1、Sizeof(变量名/数据类型) 其返回值就是该变量或数据类型所占字节数 2、一个指针变量无论其指向变量占几个字节，其本身所占大小都是4字节。 3、*p具体指向几个字节，要靠前面类型确定，如果为int则为4字节，如果double则占8字节。 4、CPU与内存交互时有32根线，每根线只能是1或0两个状态，所有总共有232个状态。1 个状态对应 一个单元。 5、所有每个地址（硬件所能访问）的用4个字节保存（而不是一 位bit） 代码示例# include &lt;stdio.h> int main(void) { char ch = 'A'; int i = 99; double x = 66.6; char * p = &amp;ch; int * q = &amp;i; double * r = &amp;x; printf(\"%d %d %d\\n\", sizeof(p), sizeof(q), sizeof(r)); return 0; } 总结 一个变量的地址—用该变量首字节的地址表示。这也就是为什么指针变量始终只占4字节的原因。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}]},{"title":"C语言之数组","slug":"C语言/C语言之数组","date":"2019-05-12T03:06:02.000Z","updated":"2020-05-12T07:29:05.282Z","comments":true,"path":"2019/05/12/c-yu-yan/c-yu-yan-zhi-shu-zu/","link":"","permalink":"http://yoursite.com/2019/05/12/c-yu-yan/c-yu-yan-zhi-shu-zu/","excerpt":"","text":"数组定义同一类型的变量——元素(element)集中在一起,在内存上排列成一条直线，这就是数组。 元素的类型既可以是int类型，也可以是double类型。 数组的声明数组的声明通过指定的元素类型，变量名，元素个数。另外[ ]中的元素个数必须是常量。 图示： 数组的特点类型相同的元素组成的集合。 空间连续 取元素的个数数组的总大小=元素的个数 * 每个元素的大小 数组名arr作为类型时候，数组的总大小 == sizeof(arr) 每个元素的大小 == sizeof(arr[0]) 元素的个数 = sizeof(arr)/sizeof(arr[0]); 代码示例 #include &lt;stdio.h> int main() { // 定义数组 int arr[5]; int n = sizeof(arr) / sizeof(arr[0]);//元素的个数 printf(\"元素个数:%d\\n\", n); //数组的下标：0~4 arr[0] arr[1] ...arr[4] printf(\"sizeof(arr) = %u\\n\",sizeof(arr));//20 printf(\"sizeof(arr[0]) = %u\\n\",sizeof(arr[0]));//4 // 2.遍历数组 for (int i = 0; i &lt; n; i++) { printf(\"%d \", arr[i]); } printf(\"\\n\"); return 0; } 数组初始化初始化全部元素 #include &lt;stdio.h> int main() { // 数组初始化 int a[5] = {1,2,3,4,5}; int b[5] = {1,2,3}; return 0; } 初始化部分元素 int a[10] = {1, 2, 4, 5} 定义的时候不加元素个数 int a[] = {1,2,3,4,5,6} 注意： 数组一定要初始化。 最终数组的元素个数由初始化的数据个数决定。 元素访问遍历数组代码示例 #include &lt;stdio.h> int main() { // 1.数组初始化 int arr[] = {10,20,30,40,50}; // 2.元素的个数 int n = sizeof(arr) / sizeof(arr[0]); printf(\"n = %d\\n\",n); // 遍历数组 for (int i = 0; i &lt; n; i++) { printf(\"%d \", arr[i]); } printf(\"\\n\"); return 0; } 一维数组案例定义数组，获取键盘录入，求出数组的平均值 最大 最小 值 #include &lt;stdio.h> int main() { // 定义数组 int arr[5] = {0}; // 元素的个数 int n = sizeof(arr) / sizeof(arr[0]); //获取键盘输入 printf(\"请输入%d个整数\\n\", n); for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;arr[i]); } //求平均值 int sum = 0; for (int i = 0; i &lt; n; i++) { //累加每个元素的值 sum += arr[i]; } printf(\"arr数组的平均值:%d\\n\", sum/n); //求最大值 int max = arr[0]; for (int i = 0; i &lt; n; i++) { if (max &lt; arr[i]) { max = arr[i]; } } printf(\"max= %d\\n\", max); //求最小值 int min = arr[0]; for (int i = 0; i &lt; n; i++) { if (min > arr[i]) { min = arr[i]; } } printf(\"min= %d\\n\", min); return 0; } 元素互换一位数值数组 逆置 （前后元素交换位置） 图示 代码示例#include &lt;stdio.h> int main() { int arr[5] = { 0 }; int n = sizeof(arr) / sizeof(arr[0]); //获取键盘输入 printf(\"请输入%d个int数据:\\n\", n); for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;arr[i]); } //交换 for (int i = 0, j = n-1 ; i &lt; j; i++, j--) { int tmp = 0; tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } //遍历 for (int i = 0; i &lt; n; i++) { printf(\"%d \", arr[i]); } printf(\"\\n\"); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}]},{"title":"C语言之指针基础","slug":"C语言/C语言之指针基础","date":"2019-05-12T03:06:02.000Z","updated":"2020-05-17T03:24:34.209Z","comments":true,"path":"2019/05/12/c-yu-yan/c-yu-yan-zhi-zhi-zhen-ji-chu/","link":"","permalink":"http://yoursite.com/2019/05/12/c-yu-yan/c-yu-yan-zhi-zhi-zhen-ji-chu/","excerpt":"","text":"内存的存储1、是以一个字节为一个编号，也就是8位合在一起给一个编号，不是0,1就给编号。内存分为很多个单元，每个单元就会分配一个编号。 地址 内存单元的一个编号。而指针和地址一个概念的。也就是说指针就是地址。 - 内存单元的编号，是一个从0开始的非负整数 - 范围：cpu对内存是通过控制、数据、地址三条总线来进行控制的。 控制总线： cup会先把内存中的数据读入，进行处理后，在返回给内存，然后内存在把数据写入硬盘。 数据总线： 用于数据的传输，不管是把内存中的数据发送给cpu，还是把cpu的数据写如内存条，都是由数据线来完成的，但是数据传输的方向则是由控制线来控制的。 地址总线： 地址线则是确定数据要写入内存中的那个单元。==所谓的一个单元就是一个字节==。 一条地址总线能控制2的1次方，一般的机器有32个地址线，最终能够控制2的32个单元，而每个单元是八位，而最终我们的内存能够存储2的32次方*8位。 变量1、普通变量：只能存放一个值。 2、指针变量：同样是一个变量，但是指针变量存放其他变量的地址 代码示例 #include &lt;stdio.h> int main() { int num = 10; //需求：定义一个指针变量p 保存num的地址编号 //定义中：*修饰p为指针变量 指针变量名为p 而不是*p int *p; //将指针变量p 与num建立关系 p = &amp;num; char ch = 'a'; //需求：定义一个指针变量p1 保存ch的地址编号 char *p1; //ch与p1建立关系 p1 = &amp;ch; return 0; } 图示： 指针变量的使用代码示例1 # include &lt;stdio.h> int main(void) { int * p; //p是变量的名字, int * 表示p变量存放的是int类型变量的地址 /* int * p; 不表示定义了一个名字叫做*p的变量 int * p; 应该这样理解: p是变量名, p变量的数据类型是 int *类型 所谓int * 类型 实际就是存放int变量地址的类型 */ int i = 3; int j; /* 1. p保存了i的地址, 因此p指向i 2. p不是i，i也不是p，更准确的说： 修改p的值不影响i的值，修改i的值也不会影响p的值. 3. 如果一个指针变量指向了某个普通变量, 则*指针变量就完全等同于普通变量 例子: 如果p是个指针变量，并且p存放了普通变量i的地址,则p指向了普通变量i。 *p 就完全等同于i，或者说:在所有出现*p的地方都可以替换成i。 在所有出现i的地方都可以替换成*p，*p 就是以p的内容为地址的变量。 */ p = &amp;i; j = *p; //等价于 j = i; printf(\"i = %d, j = %d\\n\", i, j); return 0; } 解析 p的内容是一个地址，在代码中，p的内容就是i的地址，*p其指向的变量当然就是i变量了。 注意1、*p代表的是p所指向的那个变量。在上代码中*p和i是同一个东西，但是*p和p不是同一个东西。 2、int* p是一个声明，开头的int*是他的数据类型。P是变量的名字。不能理解我定义了一个整形变量，这个整形变量的名字叫做*p。所谓int*类型，实际就是存放int变量地址的类型。 3、*p代表的是以p的内容为地址的变量。 代码示例2 # include &lt;stdio.h> int main(void) { // 1.定义num变量 int num = 10; // 2.定义指针变量 int *p; // 指针变量指向num的地址 p = &amp;num; //p的值 与 &amp;num是同一个值 printf(\"p = %p\\n\", p); printf(\"&amp;num = %p\\n\", &amp;num); // *p 代表的是 取p所保存的地址编号 对应空间的内容 // *p == num *p = 100;//*p == num, *p = 100 --> num = 100 printf(\"num = %d\\n\", num); printf(\"*p = %d\\n\", *p);//*p == num == 100 /* *p = *p +1 *p = num，所有(*p)++等价于num++ */ (*p)++; printf(\"*p = %d\\n\", *p); scanf(\"%d\", p); printf(\"*p = %d\\n\", *p);//*p == num return 0; } 程序运行结果 指针的定义 指针就是地址，地址就是指针。 地址就是内存单元的编号。 区别 指针变量：就是存放内存单元编号的变量。而指针只是一个值，这个值是内存单元的一个编号。指针变量才是一个变量，他里面才可以存放数据。 指针变量初始化代码示例 #include &lt;stdio.h> int main() { int num = 0; int *p = NULL; // int *p; p = NULL; int *p1 = &amp;num; // int *p1; p1 = &amp;num; return 0; } 指针的本质就是一个操作受限的非负整数。指针不能进行算术运算-相加 乘 除。但是能相减。 指针和指针变量是两个不同的概念，但是需要注意的是，通常叙述时会把指针变量简称为指针，实际他们含义并不一样。 代码示例1 # include &lt;stdio.h> /* int *p：p只能存放int类型的地址。 P = &amp; i：把i的地址赋给p。然后p就指向了i，*p就等于i。其实就是 1：该语句保存了i的地址。 2：p保存了i的地址，所以p指向i。 3：p既然指向i，*p就是i。 */ int main(void) { int * p; //*p 表示以p的内容为地址的变量。 int i = 5; /* *p:表示以p的内容为地址的变量。p是有指向的，p里面是个垃圾值， *p则是说以p的内容为地址的变量。因为不知道p的值是多少，所以不知道*p到底代表的是那个变量。 而*p = i，i=5，最终的结果就是把5赋给了一个所不知道的单元。 */ *p = i; printf(\"%d\\n\", *p); return 0; } 代码示例2 # include &lt;stdio.h> /* 1、q的空间是属于本程序的，所以本程序可以读写q的内容， 但是如果q内部是垃圾值，则本程序不能读写*q的内容。 2、因为此时*q所代表的内存单元的控制权限并没有分配给本程序所以本程序运行到13行时就会立即出错 */ int main(void) { int i = 5; int * p; int * q; p = &amp;i; //*q = p; //error 语法编译会出错 //*q = *p; //error p = q; //q是垃圾值，q赋给p, p也变成垃圾值 printf(\"%d\\n\", *q); //13行 return 0; } 注意 第一个error是数据类型不符合，不能相互转换。*q代表的是整形，因为*q代表的是以q的地址为内容的变量。 而p是地址（int *）类型。第二个error同样有错，因为q没有赋值。 *与&amp;的关系代码示例 #include &lt;stdio.h> int main() { /* num 是int类型 &amp;num 是int *类型 对变量取地址 &amp; 整个表达式类型 + * */ int num = 0; int *p; /* p 是int *类型 *p==num 是 int 类型 总结：在使用中 对指针变量取* 整个表达式 -* */ p = &amp;num; /* 注意：在使用中，当*与&amp;同时出现的时候 从右往左 依次抵消 &amp;*&amp;*&amp;num == &amp;num &amp;*&amp;*&amp;*p == p *p = *&amp;num == num; */ *p == num; return 0; } 指针变量的类型 指针变量自身类型 指针变量所指向的类型 #include &lt;stdio.h> int main() { /* 自身的类型:只将变量名拖黑，剩下什么类型，指针变量自身就是什么类型。 p自身的类型就是int * */ int *p; /* 指针变量指向的类型:将变量名以及离它最近的一个*一起拖黑，剩下的是什么类型。 指针变量指向就是什么类型。 p指向的类型是int */ return 0; } 指针变量取值宽度指针变量取值宽度由指向的类型长度决定。 代码示例 #include &lt;stdio.h> int main() { // 定义变量 int num = 0x01020304; // 定义指针变量 int *p = &amp;num; printf(\"*p=%#x\\n\", *p); short *p1 = &amp;num; printf(\"*p1=%#x\\n\", *p1); char *p2 = &amp;num; printf(\"*p2=%#x\\n\", *p2); return 0; } 图示 指针变量的跨度指针变量的跨度由指向类型的大小确定。 #include &lt;stdio.h> int main() { // 定义char*类型的指针变量 char *p1 = NULL; // 0 printf(\"p1=%d\\n\", p1); printf(\"p1+1=%d\\n\", p1+1); // 定义char*类型的指针变量 short *p2 = NULL; // 0 printf(\"p2=%d\\n\", p2); printf(\"p2+1=%d\\n\", p2+1); // 定义char*类型的指针变量 int *p3 = NULL; // 0 printf(\"p3=%d\\n\", p3); printf(\"p3+1=%d\\n\", p3+1); return 0; } 图示 void修饰指针变量#include &lt;stdio.h> int main() { /* 不允许void定义普通变量(系统不能通过void判断i的大小) */ // void i = 10; /* 可以使用void *定义指针变量 */ void *p; int i = 10; p = &amp;i; /* 对于void *指针变量,不要取*。 p指向的类型为void,判断不出宽度 */ // printf(\"*p=%d\\n\", *p); // 要想通过void *p取出空间内容,必须对p做强制类型转换 printf(\"*p = %d\\n\", *(int *)p); return 0; } 注意： void *p 可以保存任意类型的地址。(万能指针) void 主要作为函数的形参(让函数通过) const修饰指针变量#include &lt;stdio.h> int main() { int num = 10; // 第一种:const在*的左边 修饰的是* (*p1只读,p1可读可写) const int *p1 = &amp;num; // *p1 = 100; // error *p1只可读 int data = 30; p1 = &amp;data; printf(\"*p1=%d\\n\", *p1); // 第二种:const在*的右边，修饰的是p2 (*p2可读可写， p2只读) int * const p2 = &amp;num; *p2 = 100; printf(\"num=%d\\n\", num); // p2 = &amp;data; // error p2只读 // 第三种:const在*的左右两边,即修饰*也是指针变量。(*p3只读, p3只读) const int* const p3 = &amp;num; /** * *p3 只读操作 * p3只读 */ // *p3 = 200; // p3 = &amp;data; return 0; } 总结当const出现在*号左边时候，指针指向的数据为常量。当const出现在*后右边的时候指针本身为常量。 指针操作注意点void test1() { // 不要操作未初始化的指针变量(野指针) int *p; *p = 100； // 段错误 // 不要操作NULL指针 int *p1 = NULL; *p1 = 100; // 不要操作自定义地址 int *p3 = 2000; *p3 = 100; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}]},{"title":"函数的重载","slug":"c++/函数的重载","date":"2019-01-15T13:21:02.000Z","updated":"2020-05-21T02:59:03.853Z","comments":true,"path":"2019/01/15/c/han-shu-de-chong-zai/","link":"","permalink":"http://yoursite.com/2019/01/15/c/han-shu-de-chong-zai/","excerpt":"","text":"函数的默认参数C++在声明函数原型的时可为一个或者多个参数指定默认的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。 代码示例 #include &lt;iostream> /** * 默认参数 */ using namespace std; /** * 1、默认参数 ,可以给形参加默认值，如果传入值，就用用户传的实参，如果没有就用默认值 */ //如果某个位置已经有了默认参数，那么从这个位置起，后面的参数都必须有默认参数。 int function(int a, int b = 20, int c =20){ return a + b + c; } // 声明函数 void test01(){ // 定义变量 int a = 10; int b = 100; // 输出结果 cout &lt;&lt; function(a,b) &lt;&lt; endl; } // 函数的声明和实现,只能有一个有默认参数 int function2(int a = 10, int b =10); int function2(int a, int b){ return a + b; } void test02(){ function2(); } int main() { cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl; // 调用函数 // test01(); test02(); return 0; 注意点：1、函数的默认参数从左向右，如果一个参数设置了默认参数，那么这个参数之后的参数都必须设置默认参数。 2、如果函数声明和函数定义分开写，函数声明和函数定义不能同时设置默认参数。 函数的占位参数C++在声明函数时，可以设置占位参数。==占位参数只有参数类型声明，而没有参数名声明。==一般情况下，在函数体内部无法使用占位参数。 代码示例 #include &lt;iostream> /* 函数的占位参数 */ using namespace std; void TestFunc01(int a,int b,int){ //函数内部无法使用占位参数 cout &lt;&lt; \"a + b = \" &lt;&lt; a + b &lt;&lt; endl; } //占位参数也可以设置默认值 void TestFunc02(int a, int b, int = 20){ //函数内部依旧无法使用占位参数 cout &lt;&lt; \"a + b = \" &lt;&lt; a + b &lt;&lt; endl; } int main() { cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl; //错误调用，占位参数也是参数，必须传参数 //TestFunc01(10,20); //正确调用 TestFunc01(10,20,30); //正确调用 TestFunc02(10,20); //正确调用 TestFunc02(10, 20, 30); return 0; } 函数重载函数重载：C++下允许函数名称相同。 实现函数重载的条件： 同一个作用域。 参数个数不同。 参数类型不同。 参数顺序不同。 代码示例 #include &lt;iostream> /** * 函数重载：C++下允许函数名称相同 */ using namespace std; // 声明函数 void function() { cout &lt;&lt; \"function()调用\" &lt;&lt; endl; } void function(int a) { cout &lt;&lt; \"function(int a)调用\" &lt;&lt; endl; } void function(int a, double b) { cout &lt;&lt; \"function(int a, double b)调用\" &lt;&lt; endl; } void test(){ function(3.23, 10); } int main() { cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl; // 调用函数 test(); return 0; } 参数const和无const的区别代码示例 #include &lt;iostream> /** * 函数重载:引用的两个版本，参数加const和不加const的区别 */ using namespace std; // 声明函数 void myFunction(int &amp; a){ cout &lt;&lt; \"myFunction(int &amp;a)的调用\" &lt;&lt; endl; } void myFunction(const int &amp; a){ cout &lt;&lt; \"myFunction(const int &amp;a)的调用\"&lt;&lt; endl; } void test(){ // myFunction(10); // myFunction(const int &amp;a)的调用 int a = 10; myFunction(a); // myFunction(int &amp;a)的调用 } int main() { cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl; // 调用函数 test(); return 0; } 注意问题 函数重载和默认参数一起使用，需要额外注意二义性问题的产生。 代码示例 #include &lt;iostream> using namespace std; // 定义函数 void myFunction(int a, int b=100){ cout &lt;&lt; \"myFunction(int a, int b)的调用\" &lt;&lt; endl; } void myFunction(int a){ cout &lt;&lt; \"myFunction(int a )的调用\" &lt;&lt; endl; } // 声明函数 void test(){ // myFunction(10); 二义性出现 } int main() { cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl; test(); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"从C到C++","slug":"c++/从C到C++","date":"2019-01-15T13:21:02.000Z","updated":"2020-05-23T03:48:55.749Z","comments":true,"path":"2019/01/15/c/cong-c-dao-c/","link":"","permalink":"http://yoursite.com/2019/01/15/c/cong-c-dao-c/","excerpt":"","text":"C++的概述C++语言在c语言的基础上添加了面向对象编程和泛型编程的支持。c++继承了c语言高效，简洁，快速和可移植的传统。c++语言融合了3种不同的编程方式: c语言代表的过程性语言. c++在c语言基础上添加的类代表的面向对象语言. c++模板支持的泛型编程。 C语言和C++语言的联系C++语言是在C语言的基础上，添加了面向对象、模板等现代程序设计语言的特性而发展起来的。两者无论是从语法规则上，还是从运算符的数量和使用上，都非常相似。 初识C++代码示例 #include &lt;iostream> // 预编译指令，引入头文件iostream /** * c++第一个源程序 */ // 命名空间 using namespace std; int main() { // cout:标准输出流对象。 // endl:刷新缓存区，并且换行 cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl; return 0; } C++对C的扩展::作用域运算符代码示例 #include &lt;iostream> /** * 双冒号作用域运算符。 */ using namespace std; // 定义全局变量 int a = 100; // 声明函数 void test01() { // 定义局部变量 int a = 200; cout &lt;&lt; \"局部变量:\" &lt;&lt; a &lt;&lt; endl; // 如果::前面没有任何内容,表示代表全局作用域。 cout &lt;&lt; \"全局变量:\" &lt;&lt; ::a &lt;&lt; endl; } int main() { // 调用函数 test01(); return 0; } 注意： 如果::前面没有任何内容,表示代表全局作用域。 C++命名空间在c++中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象等等。工程越大，名称互相冲突性的可能性越大。标准C++引入关键字namespace（命名空间/名字空间/名称空间），可以更好地控制标识符的作用域。 代码示例 #include &lt;iostream> /** * 创建命名空间 * @return */ namespace A{ // 定义变量 int a = 10; } namespace B{ // 定义变量 int a = 20; } int main() { std::cout &lt;&lt; \"A::a : \" &lt;&lt; A::a &lt;&lt; std::endl; std::cout &lt;&lt; \"B::a : \" &lt;&lt; B::a &lt;&lt; std::endl; return 0; } using声明和使用代码示例 #include &lt;iostream> /** * 使用命名空间 */ using namespace std; // 创建命名空间stu namespace stu { void sort() { cout &lt;&lt; \"stu\" &lt;&lt; std::endl; } } // 使用命名空间stu using namespace stu; // 创建命名空间stu1 namespace stu1 { void sort() { std::cout &lt;&lt; \"stu1\" &lt;&lt; std::endl; } } // 使用命名空间stu1 using namespace stu1; int main() { stu::sort(); stu1::sort(); cout &lt;&lt; \"kobe is mvp\" &lt;&lt;endl; return 0; } 全局变量检测增强int a; // int a = 10; a重定义 函数检查增强// 获取长方形的面积 int getArea(int w, int l){ return w * l; } /** * 函数检测增强 返回值检测增强 形参类型检测增强 调用时候参数数量检测增强 */ // 声明test01()函数 void test1(){ // getArea(10, 12, 13); 参数传入过多 } 类型转换检测加强/** * 类型转换检测加强 * @return */ // 声明test02()函数 void test2(){ // 指针左右类型必须一样，才能赋值 int * str = (int *)malloc(sizeof(int)* 8); } 结构体的简化/** * struct增强 * @return */ // 在C++语言下,可以在结构体中放函数 struct Student{ int age; void function(){ age++; } }; // 声明test03()函数 void test03(){ // 在C++下面 创建结构体变量的时候,可以简化关键字struct Student st; st.age = 17; st.function(); cout &lt;&lt; \"学生的年龄是:\" &lt;&lt; st.age &lt;&lt; endl; } bool数据类型的扩展/** * bool数据类型的扩展,C++语言下有bool数据类型,代表真和假 * @return */ bool flag; void test04(){ // bool类型占用一个字节 cout &lt;&lt; \"bool类型占用\"&lt;&lt; sizeof(bool) &lt;&lt; \"字节\" &lt;&lt; endl; // 真 true(1) 假 false(0) flag = true; cout &lt;&lt; flag &lt;&lt; endl; } 三目运算符增强/* * 三目运算符增强 * C++语言下 三目运算符返回的是变量，可以继续赋值 * @return */ void test05(){ // 定义变量 int a = 10; int b = 20; // printf(\"a > b ? a : b = %d\\n\", a > b ? a : b); (a > b ? a : b) =100; // b = 100 加上括号 保证运算完整性 cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; // 10 cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; // 100 } const关键字C语言中的const的特征 const修饰的变量是只读的, 本质还是变量，不是常量。const修饰的局部变量在栈上分配空间。 const修饰的全局变量在只读存储区分配空间，const只在编译期有用,在运行期无用。 const修饰的变量不是真的常量,它只是告诉编译器该变量不能出现在赋值符号的左边。 代码示例 #include &lt;stdio.h> int main() { // 定义普通变量 const int c = 0; // 定义指针变量 int* p = (int*)&amp;c; printf(\"hello world...\\n\"); *p = 5; printf(\"c = %d\\n\", c); return 0; } 程序运行结果 结论C语言中的const使得变量具有只读属性。 const将具有全局生命周期的变量存储于只读存储区。 const不能定义真正意义上的常量! C++语言中的const的特征C++在C的基础上的const进行了进化处理。 当碰见const声明时在符号表中放入常量,编译过程中若发现使用常量则直接以符号表中的值替换。 编译过程中若发现下述情况则给对应的常量分配存储空间 对const常量使用了extern，对const常量使用&amp;操作符。 注意： C+ +编译器虽然可能为const常量分配空间,但不会使用其存储空间中的值（兼容C语言)。 C++中的const常量可能分配存储空间 - 当const常量为全局,并且需要在其它文件中使用。 - 当使用&amp;操作符对const常量取地址。 C++中的const常量类似于宏定义。 constintc= 5; ≈ #define C 5 C++中的const常量在与宏定义的区别 const常量是由编译器处理。 编译器对const常量进行类型检查和作用域检查. 宏定义由预处理器处理，单纯的文本替换。 代码示例 #include &lt;stdio.h> void fax() { // 定义宏 #define a 3 } // 声明函数 void gax() { printf(\"a = %d\\n\", a); } int main() { // 定义变量 const int A = 1; const int B = 2; // 定义数组 int array[A + B] = {0}; int i = 0; // 遍历循环 for(i=0; i&lt;(A + B); i++) { printf(\"array[%d] = %d\\n\", i, array[i]); } // 调用函数 fax(); gax(); return 0; } 程序运行结果 修改const的值代码示例 #include &lt;cstdlib> #include &lt;iostream> using namespace std; // 定义全局变量 const int const_A = 10; // 声明函数 void test01(){ /** * 全局变量受到常量区的保护,无法修改 */ // const_A = 1000; /* int* p = (int *)&amp;const_A; *p = 100; cout &lt;&lt; \"const_A的值:\"&lt;&lt; const_A&lt;&lt; endl; */ // 定义局部变量 const int const_B = 20; /* 当对const_B取地址的时候，创建临时内存空间,临时空间是看不到的。 int temp = const_B; int *p = (int*)&amp;temp */ int *p = (int*)&amp;const_B; *p = 200; // 输出结果 cout &lt;&lt; \"const_B的值是\"&lt;&lt; const_B &lt;&lt; endl; } int main() { printf(\"hello world!!!\\n\"); // 调用函数 test01(); return 0; } 程序运行结果 const分配内存代码示例 #include &lt;iostream> /** * const在C++下分配内存的情况 */ using namespace std; // 1.对const修饰的局部变量取地址,会分配临时空间 void test01(){ // 01.定义变量 const int const_A = 10; int *p = (int *)&amp;const_A; } // 2.使用变量，初始化const修饰的局部变量 void test02(){ // 定义变量 int a = 10; // 会分配内存,可以通过间接修改,修改成功. const int const_B = a; int * p = (int *)&amp;const_B; *p = 30; // 输出结果 cout &lt;&lt; \"const_B的值:\" &lt;&lt; const_B &lt;&lt; endl; } // 3.对于自定义数据类型，也会分配内存 struct Person{ // 定义变量 string name; int age; }; // 声明函数 void test03(){ const Person p1{}; Person * p = (Person *)&amp;p1; p->age = 18; p->name = \"常山赵子龙\"; // 输出结果 cout &lt;&lt; \"姓名:\" &lt;&lt; p->name &lt;&lt;endl &lt;&lt; \"年龄:\" &lt;&lt; p->age &lt;&lt; endl; } int main() { // 1.调用函数 // test02(); test03(); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"C++引用","slug":"c++/C++引用","date":"2019-01-15T13:21:02.000Z","updated":"2020-05-21T02:59:11.559Z","comments":true,"path":"2019/01/15/c/c-yin-yong/","link":"","permalink":"http://yoursite.com/2019/01/15/c/c-yin-yong/","excerpt":"","text":"引用引用的特点引用是c++对c的重要扩充。在c/c++中指针的作用基本都是一样的，但是c++增加了另外一种给函数传递地址的途径，这就是按引用传递。 变量名实质上是一段连续内存空间的别名，是一个标号。 程序中通过变量来申请并命名内存空间 通过变量的名字可以使用存储空间 基本语法 数据类型 &amp; 别名 = 原名 重点注意 &amp;在此不是求地址运算，而是起标识作用。 类型标识符是指目标变量的类型。 必须在声明引用变量时进行初始化。 引用初始化之后不能改变。 不能有NULL引用。必须确保引用是和一块合法的存储单元关联。可以建立对数组的引用。 图示 引用基本语法代码示例#include &lt;iostream> /** * 基本引用语法 */ using namespace std; // 1.基本语法, //语法 数据类型 &amp; 别名 = 原名 void test01(){ // 定义变量 int a = 10; int &amp;b = a; b = 100; // 输出a , b的值 cout &lt;&lt;\"a=\" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt;\"b=\" &lt;&lt; b &lt;&lt; endl; } int main() { // 调用函数 test01(); return 0; } 程序运行结果 a = 100 b = 100 注意事项代码说明 void test02() { //引用必须初始化 int a = 10; //int &amp;b; error 必须给引初始化 int &amp;b = a; //引用一旦初始化后，就不可以引向别的位置 int c = 20; b = c; //赋值 并不是修改引用指向 } 数组引用代码示例 #include &lt;iostream> /** * 基本引用语法 */ using namespace std; // 数组引用 void test01(){ // 定义数组 int arr[5] = {1, 2,3,4,5}; // 1.直接建立引用 int(&amp;pArr)[5] = arr; // 遍历数组 /* for (int i = 0; i &lt; 5; ++i) { cout &lt;&lt; pArr[i] &lt;&lt; endl; } */ // 2.先定义数组类型,再通过类型。 typedef int(array_type)[5]; // 数据类型 &amp;别名 = 原名 array_type &amp; pArr2 = arr; // 遍历数组 /* for (int i = 0; i &lt; 5; ++i) { cout &lt;&lt; pArr2[i] &lt;&lt; endl; }*/ // 3.先定义数组引用类型，再通过类型定义引用 typedef int(&amp;array_type1)[5]; array_type1 pArr3 = arr; // 遍历数组 for (int i = 0; i &lt; 5; ++i) { // 输出数组元素 cout &lt;&lt; pArr3[i] &lt;&lt; endl; } } int main() { // 调用函数 test01(); return 0; } 传递方式地址传递void Swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; } void test01() { int a = 10; int b = 20; Swap(&amp;a, &amp;b); cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; } 引用传递void Swap01(int &amp;a ,int &amp;b ) { int temp = a; a = b; b = temp; } void test02() { int a = 10; int b = 20; Swap01(a, b); cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; // 20 cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; // 10 } 注意: 1、引用必须引合法的内存空间。 2、不要返回局部变量的引用。 3、当函数返回值是引用时候，那么函数的调用可以作为左值存在。 引用的本质引用的本质在c++内部实现是一个指针常量。 代码示例 Type&amp; ref = val; // Type* const ref = &amp;val 注意 c++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同，只是这个过程是编译器内部实现，用户不可见。 指针的引用代码示例 #include &lt;iostream> /** * 指针的引用 */ using namespace std; // 定义Person结构体类型 struct Person{ // 姓名 string name; // 年龄 int age; }; // 传统方法 void mallocMethod(Person ** person){ // 分配内存空间 Person *p = (Person *)malloc(sizeof(Person)); p->age = 21; p->name = \"Curry\"; *person = p; } // 调用函数 void test01(){ // 初始化 Person *p = NULL; mallocMethod(&amp;p); // 输出结果 // cout &lt;&lt; \"姓名是:\"&lt;&lt; p->name &lt;&lt;endl &lt;&lt; \"年龄是:\"&lt;&lt; p->age &lt;&lt; endl; cout &lt;&lt; \"p的年龄： \" &lt;&lt; p->age &lt;&lt; endl; cout &lt;&lt; \"p的姓名： \" &lt;&lt; p->name &lt;&lt; endl; } // 指针引用 void mallocMethods(Person * &amp;p){ // 分配内存空间 p = (Person *)malloc(sizeof(Person)); p->age = 22; p->name = \"kobe\"; } // 释放方法 void freeMethods(Person * &amp;p){ free(p); p = NULL; } // 调用函数 void test02(){ // 初始化 Person *p = NULL; mallocMethods(p); // 输出结果 cout &lt;&lt; \"p的年龄： \" &lt;&lt; p->age &lt;&lt; endl; cout &lt;&lt; \"p的姓名： \" &lt;&lt; p->name &lt;&lt; endl; // 调用freeMethods() freeMethods(p); } int main() { // 调用函数 // test01(); test02(); return 0; } 常量的引用特点： 1、字面量不能赋给引用，但是可以赋给const引用 2、const修饰的引用，不能修改。 代码示例 #include &lt;iostream> /** * 常量的引用 */ using namespace std; //加const修饰形参，为了防止在代码中误操作，修改数据 void constValue( const int &amp;a){ // 输出a的大小 cout &lt;&lt; \"a的大小是:\" &lt;&lt; a &lt;&lt; endl; } // 声明函数 void test01(){ // 定义变量 int a = 200; constValue(a); } int main() { cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl; // 调用函数 test01(); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"类和对象","slug":"c++/类和对象","date":"2019-01-15T13:21:02.000Z","updated":"2020-05-21T02:43:19.315Z","comments":true,"path":"2019/01/15/c/lei-he-dui-xiang/","link":"","permalink":"http://yoursite.com/2019/01/15/c/lei-he-dui-xiang/","excerpt":"","text":"C++类和对象C++是一门面向对象的编程语言，理解 C++，首先要理解类（Class）和对象（Object）这两个概念 C++ 中的类（Class）可以看做C语言中结构体（Struct）的升级。结构体是一种构造类型，可以包含若干成员变量，每个成员变量的类型可以不同，可以通过结构体来定义结构体变量，每个变量拥有相同的性质。 代码示例 #include &lt;stdio.h> //定义结构体 Student struct Student{ //结构体包含的成员变量 char *name; int age; int score; }; // 声明函数 void show(struct Student *); int main(){ struct Student stu; //为成员变量赋值 stu.name = \"curry\"; stu.age = 10; stu.score = 98; //调用函数 show(&amp;stu); return 0; } //结构体的成员变量 void show(struct Student *pst){ printf(\"%s的年龄是 %d\\n，成绩是 %d\\n\", pst->name, pst->age, pst->score); } 代码运行结果 curry的年龄是10，成绩是98 C++ 中的类也是一种构造类型，但是进行了一些扩展，类的成员不但可以是变量，还可以是函数；通过类定义出来的变量叫做“对象”。 代码示例 #include &lt;iostream> /** * 类和对象 */ using namespace std; //通过class关键字定义学生类 class Student{ public: // 定义变量 char *name; int age; float score; // 声明函数 void say(){ // 输出结果 cout &lt;&lt; name &lt;&lt; \"的年龄是:\" &lt;&lt; age &lt;&lt;\", 成绩是:\" &lt;&lt; score &lt;&lt; endl; } }; int main() { //创建对象 Student stu; //为类的成员变量赋值 stu.name = \"curry\"; stu.age = 10; stu.score = 92.5f; //调用函数 stu.say(); return 0; } 类的封装 把变量（属性）和函数（操作）合成一个整体，封装在一个类中。 对变量和函数进行访问控制。 访问权限 在类的内部(作用域范围内)，没有访问权限之分，所有成员可以相互访问。 在类的外部(作用域范围外)，访问权限才有意义：public，private，protected。 在类的外部，只有public修饰的成员才能被访问，在没有涉及继承与派生时， private和protected是同等级的，外部不允许访问。 访问属性 属性 对象内部 对象外部 public 公有 可访问 可访问 protected 保护 可访问 不可访问 private 私有 可访问 不可访问 代码示例 #include &lt;iostream> /** * 类的封装 */ using namespace std; // 创建类Person class Person{ public: // 公共权限 string name; // 姓名 protected: // 保护权限 string car; private: // 私有权限 int password; public: void function(){ /** * 所有权限类内都可以访问 */ name = \"curry\"; car = \"小学生跑车\"; password = 123446; } }; // 声明函数 void test(){ // 创建对象 Person p; p.name = 'kobe'; // p.car = \"法拉第\"; 保护权限,在类外不可以访问 // p.password = 134566; 私有权限，在类外不可以访问 } int main() { cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl; // 调用函数 test(); return 0; } 成员属性设置使用成员函数可使得我们对变量的控制处理更加精细。 代码示例 #include &lt;iostream> /** * 将成员属性设置成私有属性 */ using namespace std; // 创建Person类 class Person{ public: // 设置姓名 void setName(string name){ myName = name; } // 获取姓名 string getName(){ return myName; } // 设置年龄 void setAge(int age){ // 检测年龄 if(age &lt; 0 || age > 30){ cout &lt;&lt; \"不好意思,你不是学生了\" &lt;&lt; endl; return; } myAge = age; } // 获取年龄 int getAge() { return myAge; } private: string myName; // 姓名 int myAge = 18; }; // 声明函数 void test(){ // 创建对象 Person p1; // 对于姓名,可以设置也可以获取 p1.setName(\"curry\"); cout &lt;&lt; \"p1的姓名是:\" &lt;&lt; p1.getName() &lt;&lt; endl; // 年龄的是只读状态,不可以设置 p1.setAge(55); cout &lt;&lt; \"p1的年龄为:\" &lt;&lt; p1.getAge() &lt;&lt;endl; } int main() { // 调用函数 test(); return 0; } 程序运行结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"CSS基础","slug":"前端/CSS/CSS基础","date":"2018-12-23T13:59:49.000Z","updated":"2019-12-24T03:20:32.802Z","comments":true,"path":"2018/12/23/qian-duan/css/css-ji-chu/","link":"","permalink":"http://yoursite.com/2018/12/23/qian-duan/css/css-ji-chu/","excerpt":"","text":"CSS样式规则css规则由两部分构成: 选择器 声明 图片说明 CSS引用写在head标签内： &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css样式&lt;/title> &lt;style type=\"text/css\"> CSS样式… &lt;/style> &lt;/head> CSS注释CSS注释：/*注释语句*/ CSS样式行内样式（内联样式） 在开始标签内添加style样式属性 &lt;h1 style=\"color:red;font-size:20px;\">css使用方法&lt;/h1> 内部样式表（嵌入样式） 内部样式（嵌入样式），把css样式代码写在: &lt;style type=\"text/css\"> 样式… &lt;/style> 说明：&lt;style>要放在&lt;head>标签之间 代码实现： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css使用方法&lt;/title> &lt;style type=\"text/css\"> p{color:blue;} h2{color:red;} &lt;/style> &lt;/head> &lt;body> &lt;!-- 行内样式 --> &lt;h1 style=\"color:red;font-size:20px;\">css使用方法&lt;/h1> &lt;!--嵌入样式--> &lt;h2>css使用方法&lt;/h2> &lt;p>行内样式&lt;/p> &lt;p>嵌入样式&lt;/p> &lt;p>外部样式&lt;/p> &lt;p>导入样式&lt;/p> &lt;/body> &lt;/html> 外部样式表（Link链入） 外部样式表，把CSS样式代码写在独立的一个文件中 扩展名： CSS文件名.CSS 引入外部文件：&lt;link href=“XX.css” rel=”stylesheet” type=”text/css” /&gt; 说明：link要放在head标签之间 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css使用方法&lt;/title> &lt;link href=\"css.css\" rel=\"stylesheet\" type=\"text/css\"/> &lt;/head> &lt;body> &lt;!-- 行内样式 --> &lt;h1 style=\"color:red;font-size:20px;\">css使用方法&lt;/h1> &lt;h2>css使用方法&lt;/h2> &lt;p>行内样式&lt;/p> &lt;p>嵌入样式&lt;/p> &lt;p>外部样式&lt;/p> &lt;p>导入样式&lt;/p> &lt;/body> &lt;/html> 外部文件 p{color:blue; font-size: 30px;} h2{color:red;} 导入式 @import “外部CSS样式” 说明：@import写在style标签内最开始 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css使用方法&lt;/title> &lt;style type=\"text/css\"> &lt;!-- 导入式 --> @import url(css.css); &lt;/style> &lt;/head> &lt;body> &lt;!-- 行内样式 --> &lt;h1 style=\"color:red;font-size:20px;\">css使用方法&lt;/h1> &lt;h2>css使用方法&lt;/h2> &lt;p>行内样式&lt;/p> &lt;p>嵌入样式&lt;/p> &lt;p>外部样式&lt;/p> &lt;p>导入样式&lt;/p> &lt;/body> &lt;/html> 外部文件 p{color:blue; font-size: 30px;} h2{color:red;} CSS使用方法区别 类别 引入方法 位置 加载 行内样式 开始标签内style html文件内 同时加载 内部样式 head中style内 html文件内 同时加载 外部样式 head中link内 CSS样式文件与html文件分离 页面加载时，同时加载CSS样式 导入式(@import) 在样式代码最开始处 CSS样式文件与html文件分离 在读取完html文件之后加载 使用外部样式的好处 CSS与Html分离 多个文件可以使用同一个样式文件 多文件引用同一个css文件，CSS只是需要下载一次。 CSS选择器1-标签选择器以HTML标签作为选择器 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css选择器&lt;/title> &lt;style type=\"text/css\"> /*标签选择器*/ p{ color: red; } &lt;/style> &lt;/head> &lt;body> &lt;p>&lt;em>CSS&lt;/em>层叠样式&lt;/p> &lt;p>&lt;em>CSS&lt;/em>样式由选择器和声明组成&lt;/p> &lt;/body> &lt;/html> 2-类选择器 为HTML标签添加class属性 h1 class=\"red\">内容1&lt;/h1> &lt;p>内容2&lt;/p> &lt;p class=\"red\">内容3&lt;/p> 通过类选择器来为具有此class属性的元素设置CSS样式 .red{color:red;} 通过对不同元素的同一名称的类选择器设置不同的样式规则 p.red{font-size:50px;} h1.red{font-size:20px;} 同一个元素可以设置多个类，之间有空格隔开 &lt;h1 class=\"red\">内容1&lt;/h1> &lt;p class=\"red fsize\">内容2&lt;/p> &lt;p class=\"red\">内容3&lt;/p> 代码实现 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css选择器&lt;/title> &lt;style type=\"text/css\"> /*标签选择器*/ p{ color: red; } /*类选择器*/ .special{ color: blue; } p.special{ font-size: 50px; } .one{ text-decoration: underline; } &lt;/style> &lt;/head> &lt;body> &lt;h1 class=\"special\">CSS是什么&lt;/h1> &lt;p>&lt;em>CSS&lt;/em>层叠样式&lt;/p> &lt;p class=\"special one\">用于定义HTML内容在浏览器中的显示样式&lt;/p> &lt;p>&lt;em>CSS&lt;/em>样式由选择器和声明组成&lt;/p> &lt;div> &lt;h1>css&lt;/em>使用方法&lt;/h1> &lt;ul> &lt;li>行内样式&lt;/li> &lt;li>内部样式&lt;/li> &lt;li>外部样式&lt;/li> &lt;li>导入式&lt;/li> &lt;/ul> &lt;h1>&lt;em>css&lt;/em>选择器&lt;/h1> &lt;ul> &lt;li>标签选择器&lt;/li> &lt;li>ID选择器&lt;/li> &lt;li>类选择器&lt;/li> &lt;li>后代选择器&lt;/li> &lt;/ul> &lt;/div> &lt;/body> &lt;/html> 3-ID选择器 为HTML标签添加ID属性 &lt;h1>内容1&lt;/h1> &lt;p id=\"p1\">内容2&lt;/p> &lt;p id=\"p2\">内容3&lt;/p> 通过ID选择器来为具有此ID的元素设置CSS规则 #p1{color:red;} #p2{color:blue;} 代码实现 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css选择器&lt;/title> &lt;style type=\"text/css\"> /*ID选择器*/ #two{ color: green; } &lt;/style> &lt;/head> &lt;body> &lt;div> &lt;h1 id=\"two\">css&lt;/em>使用方法&lt;/h1> &lt;/div> &lt;/body> &lt;/html> 4-全局选择器 所有标签设置样式 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css选择器&lt;/title> &lt;style type=\"text/css\"> /*全局选择器*/ *{font-size:50px; color:blue;} &lt;/style> &lt;/head> &lt;body> &lt;h1 class=\"special\">&lt;em>CSS&lt;/em>是什么&lt;/h1> &lt;p>&lt;em>CSS&lt;/em>层叠样式&lt;/p> &lt;p class=\"special one\">用于定义HTML内容在浏览器中的显示样式&lt;/p> &lt;p>&lt;em>CSS&lt;/em>样式由选择器和声明组成&lt;/p> &lt;/body> &lt;/html> 5-群组选择器 集体统一设置样式 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css选择器&lt;/title> &lt;style type=\"text/css\"> /*群组选择器*/ p.special,#three,h1{font-size:50px;} p{color:red;} .special{color:blue;} .one{text-decoration: underline;} #two{color:green;} &lt;/style> &lt;/head> &lt;body> &lt;h1 class=\"special\">&lt;em>CSS&lt;/em>是什么&lt;/h1> &lt;p>&lt;em>CSS&lt;/em>层叠样式&lt;/p> &lt;p class=\"special one\">用于定义HTML内容在浏览器中的显示样式&lt;/p> &lt;p>&lt;em>CSS&lt;/em>样式由选择器和声明组成&lt;/p> &lt;div> &lt;h1 id=\"two\">&lt;em class=\"classred\">css&lt;/em>使用方法&lt;/h1> &lt;ul id=\"three\"> &lt;li>行内样式&lt;/li> &lt;li>内部样式&lt;/li> &lt;li>外部样式&lt;/li> &lt;li>导入式&lt;/li> &lt;/ul> &lt;h1>&lt;em>css&lt;/em>选择器&lt;/h1> &lt;ul> &lt;li>标签选择器&lt;/li> &lt;li>ID选择器&lt;/li> &lt;li>类选择器&lt;/li> &lt;li>后代选择器&lt;/li> &lt;/ul> &lt;/div> &lt;/body> &lt;/html> 6-后代选择器 使用后代选择器设置，之间用空格隔开 p em{font-size:40px} /*p标签中a标签中的em*/ p a em{.....} /*id为p1的标签中的em*/ #p1 em{....} /*class为red的p标签中的a标签中的em*/ p.red a em{.....} 代码实现： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css选择器&lt;/title> &lt;style type=\"text/css\"> &lt;!--后代选择器--> .classred{color:red;} p em{color:blue;} h1.special em{color:orange;} em{color:red;} &lt;/style> &lt;/head> &lt;body> &lt;h1 class=\"special\">&lt;em>CSS&lt;/em>是什么&lt;/h1> &lt;p>&lt;em>CSS&lt;/em>层叠样式&lt;/p> &lt;p class=\"special\">用于定义HTML内容在浏览器中的显示样式&lt;/p> &lt;p>&lt;em>CSS&lt;/em>样式由选择器和声明组成&lt;/p> &lt;div> &lt;h1>&lt;em class=\"classred\">css&lt;/em>使用方法&lt;/h1> &lt;ul> &lt;li>行内样式&lt;/li> &lt;li>内部样式&lt;/li> &lt;li>外部样式&lt;/li> &lt;li>导入式&lt;/li> &lt;/ul> &lt;h1>&lt;em>css&lt;/em>选择器&lt;/h1> &lt;ul> &lt;li>标签选择器&lt;/li> &lt;li>ID选择器&lt;/li> &lt;li>类选择器&lt;/li> &lt;li>后代选择器&lt;/li> &lt;/ul> &lt;/div> &lt;/body> &lt;/html> 伪类选择器链接的4中状态 激活状态，已访问状态，未访问状态，和鼠标悬停状态。 伪类 说明 :link 未访问的链接 :visited 已访问的链接 :hover 鼠标悬停状态 :active 激活的链接 伪类:hover和:active :hover用于访问的鼠标经过某个元素时 :active用于一个元素被激活时（即按下鼠标之后放开鼠标之前的时间） 链接伪类的顺序 ：Link &gt; :Visited &gt; :Hover &gt; :Active 注意： a:hover 必须置于 a:link 和 a:visited 之后，才有效。 a:active 必须置于 a:hover 之后，才有效。 伪类名称对大小写不敏感。 代码实现&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css选择器&lt;/title> &lt;style type=\"text/css\"> p a:link{color:blue;} p a:visited{color:green;} p a:hover{color:red;} p a:active{color:gray;} div a:link{color:green;} div a:visited{color:blue;} div a:hover{color:gray;} div a:active{color:red;} &lt;/style> &lt;/head> &lt;body> &lt;p>&lt;a href=\"http://www.baidu.com\" target=\"_blank\">css使用方法&lt;/a>&lt;/p> &lt;br/> &lt;div>&lt;a href=\"http://www.zhihu.com\" target=\"_blank\">css选择器&lt;/a>&lt;/div> &lt;p>度娘&lt;/p> &lt;/body> &lt;/html> CSS继承和层叠 从父元素那继承部分CSS属性。 继承的好处 父元素设置样式，子元素可以继承部分属性。 减少CSS代码 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>CSS继承和层叠&lt;/title> &lt;style type=\"text/css\"> p{color:red;} &lt;/style> &lt;/head> &lt;body> &lt;div> &lt;p>CSS&lt;span>继承&lt;/span>&lt;/p> &lt;div>CSS层叠&lt;/div> &lt;/div> &lt;p>CSS继承和层叠&lt;/p> &lt;h1>CSS继承和层叠&lt;/h1> &lt;/body> &lt;/html> CSS层叠 可以定义多个样式 不冲突时，多个样式可层叠为一个 冲突时，按不同样式规则优先级来应用样式 代码实现： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>CSS继承和层叠&lt;/title> &lt;style type=\"text/css\"> h1{color:red;} h1{color: blue} &lt;/style> &lt;/head> &lt;body> &lt;h1>CSS继承和层叠&lt;/h1> &lt;/body> &lt;/html> CSS优先级总结!important声明高 可调整样式规则的优先级 添加在样式规则之后，中间用空格隔开 div{color:red !important} CSS使用方法的优先级行内样式&gt;内部样式&gt;外部样式注意: 链入外部样式表与内部样式表之间的优先级取决于所处位置的先后 最后定义的优先级最高（就近原则）。 样式表中优先级选择器权值 标签选择器：权值为1 类选择器和伪类：权值为10 ID选择器：权值为100 通配符选择器：权值为0 行内样式：权值为1000 同一样式表中权值相同： 就近原则（离被设置元素越近优先级越高)。 权值不同： 根据权值来判断CSS样式，哪种CSS样式权值高，就使用哪种样式。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}]},{"title":"CSS定位","slug":"前端/CSS/CSS定位","date":"2018-12-23T13:48:50.000Z","updated":"2019-12-23T13:54:10.706Z","comments":true,"path":"2018/12/23/qian-duan/css/css-ding-wei/","link":"","permalink":"http://yoursite.com/2018/12/23/qian-duan/css/css-ding-wei/","excerpt":"","text":"定位模型position之static 静态定位 /常规定位/自然定位 ——定位中的一股清流-回归本真 特点 作用 使元素定位与 常规/自然流中（块、行垂直排列下去、行内水平从左到右） 特点 (1)忽略top,bottom,left,right或者z-index声明(2)两个相邻的元素如果都设置了外边距，那么最终外边距=两者外边距中最大的(3)具有固定width和height值的元素，如果把左右外边距设置为auto，则左右外边距会自动扩大占满剩余宽度。造成的效果就是这个块水平居中。 代码实现/*简单reset.css*/ html, body { background: #f5f5f5; } html, body, div,p,img { margin: 0; padding: 0; box-sizing: border-box; } .flex-container { background: purple; /*padding:10px;*/ } .flex-item { color:purple; text-align: center; } .red { background: red; } .blue { background: lightblue; } .orange { background: darkorange; } .green { background: darkslategray; } &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>change-to-flex&lt;/title> &lt;link rel=\"stylesheet\" href=\"./reset.css\"> &lt;style> .block { position: static; top: 10px; width: 50px; height: 50px; line-height: 50px; text-align: center; border: 2px solid blue; box-sizing: border-box; } .block:nth-child(1) { border: 2px solid green; margin-left: auto; margin-right: auto; /*margin: 30px;*/ } .block:nth-child(2) { /*position: static;*/ /*border-color: red;*/ /*margin: 20px;*/ border: 2px solid red; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"block\"> A &lt;/div> &lt;div class=\"block\"> B &lt;/div> &lt;div class=\"block\"> C &lt;/div> &lt;div class=\"block\"> D &lt;/div> &lt;/body> &lt;/html> position之relative 相对定位 特点 作用 使元素称为containing-block-官话是可定位的祖先元素 特点 (1)可以使用top/right/bottom/left/z-index进行相对定位——？相对的是谁(2)相对定位的元素不会离开常规流——心念家乡(3)任何元素都可以设置为relative，它的绝对定位的后代都可以相对于它进行绝对定位——超好用(4)可以使用浮动元素发生偏移，并控制它们的堆叠顺序。 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>position-relative&lt;/title> &lt;link rel=\"stylesheet\" href=\"./reset.css\"> &lt;style> .block { position: relative; top: 0; left: 0; width: 80px; height: 80px; line-height: 80px; border: 2px solid black; text-align: center; float: left; z-index: 9; } .block:nth-child(2) { position: relative; top: 0; left: -80px; border-color: red; z-index: 1; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"block\">A&lt;/div> &lt;div class=\"block\">B&lt;/div> &lt;/body> &lt;/html> position之absolute 绝对定位 特点 作用 使元素脱离常规流 特点 (1)脱离常规流(2)lrtb如果为0 它将对齐到最近定位祖先元素的各边——衍生出(3)lrtb如果设置为auto 它将被打回原形。(4)如果没有最近定位祖先元素 会认做父元素（通俗的说）如果元素没有已定位（除static 定位以外）的祖先元素，那么它的位置相对于最初的包含块。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}]},{"title":"float浮动","slug":"前端/CSS/float浮动","date":"2018-12-23T13:48:24.000Z","updated":"2019-12-23T13:54:31.256Z","comments":true,"path":"2018/12/23/qian-duan/css/float-fu-dong/","link":"","permalink":"http://yoursite.com/2018/12/23/qian-duan/css/float-fu-dong/","excerpt":"","text":"css定位机制普通流(标准流) 块元素：元素从上往下的排列 行内元素:元素自动从左往右排列。 块元素 独占一行 可以设置宽、高 如果不设置宽度，宽度默认为容器的100% 主要有div、p、h1~h6、ul、ol、li、dl、dt、dd 行内元素 与其它元素同行显示 不可以设置宽、高 宽高就是文字或图片的宽高 主要有span、a、b、i、u、em…… 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>block、inline&lt;/title> &lt;style type=\"text/css\"> div{ width:300px; height:200px; background:blue; } span{ width:300px; height:200px; background:red; } &lt;/style> &lt;/head> &lt;body> &lt;div>这个是块级元素1&lt;/div> &lt;div>这个是块级元素2&lt;/div> &lt;span>这个是行内元素1&lt;/span> &lt;span>这个是行内元素2&lt;/span> &lt;/body> &lt;/html> Float（浮动） 会使元素向左或向右移动，只能左右，不能上下。 浮动元素碰到包含框或另一个浮动框，浮动停止。 浮动元素之后的元素将围绕它，之前的不受影响。 浮动元素会脱离标准流。 浮动的基本语法 float:left 靠左浮动 float:right 靠右浮动 float:none 不使用浮动 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>text_around&lt;/title> &lt;style type=\"text/css\"> .container{ width:800px; height:600px; border:2px solid #333; } .container img{ float:left; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"container\"> &lt;img src=\"./img/1.jpg\"> &lt;p>前言 目前Mock技术已经比较成熟，在日常的工作中Mock也可以给我们带来很大的遍历，本篇文章将会使用 Moco框架，一步一步搭建一套Mock Server，使得接口的自动化测试更加的提前，也能够使得前后端分离。 共识与痛点 目前，在软件行业内，大家已经达成的共识就是，测试的工作应该从需求阶段就开始，但在实际 工作落地的时候，我们也仅仅能够根据需求写一些测试用例。 &lt;/p> &lt;/div> &lt;/body> &lt;/html> 使用浮动后产生的问题 元素使用浮动后会脱离普通流，出现“高度塌陷” 浮动溢出 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>float&lt;/title> &lt;style type=\"text/css\"> .container{ width:500px; height:500px; border:2px solid #333; float: left; } .box01{ width:100px; height:100px; background:blue; color:#fff; float: left; } .box02{ width:100px; height:100px; background:red; color:#fff; float: left; } .box03{ width:100px; height:100px; background:orange; color:#fff; float: left; } .box04{ width:500px; height:200px; background:green; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"container\"> &lt;div class=\"box01\">11111&lt;/div> &lt;div class=\"box02\">22222&lt;/div> &lt;div class=\"box03\">33333&lt;/div> &lt;/div> &lt;div class=\"box04\">44444&lt;/div> &lt;/body> &lt;/html> 清除浮动语法：clear : none | left | right | both; 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>float清除浮动语法&lt;/title> &lt;style type=\"text/css\"> .container{ width:500px; height:500px; border:2px solid #333; float: left; clear: both; } .box01{ width:100px; height:100px; background:blue; color:#fff; float: left; clear: both; } .box02{ width:100px; height:100px; background:red; color:#fff; float: left; clear: both; } .box03{ width:100px; height:100px; background:orange; color:#fff; float: left; clear: both; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"container\"> &lt;div class=\"box01\">11111&lt;/div> &lt;div class=\"box02\">22222&lt;/div> &lt;div class=\"box03\">33333&lt;/div> &lt;/div> &lt;/body> &lt;/html> 清除浮动常用方法方法一：在浮动元素后使用一个空元素。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>float清除浮动方法一&lt;/title> &lt;style type=\"text/css\"> .container{ width:500px; height:500px; border:2px solid #333; float: left; clear: both; } .box01{ width:100px; height:100px; background:blue; color:#fff; float: left; clear: both; } .box02{ width:100px; height:100px; background:red; color:#fff; float: left; clear: both; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"container\"> &lt;div class=\"box01\">11111&lt;/div> &lt;div class=\"box02\">22222&lt;/div> &lt;div class=\"clear\">&lt;/div> &lt;/body> &lt;/html> 方法二：给浮动元素的容器添加 overflow:hidden; &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>float&lt;/title> &lt;style type=\"text/css\"> .container{ width:500px; border:2px solid #333; overflow: hidden; } .box01{ width:100px; height:100px; background:blue; color:#fff; float: left; } .box02{ width:100px; height:100px; background:red; color:#fff; float: left; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"container\"> &lt;div class=\"box01\">11111&lt;/div> &lt;div class=\"box02\">22222&lt;/div> &lt;/div> &lt;/body> &lt;/html> 方案三:&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>float&lt;/title> &lt;style type=\"text/css\"> .container{ width:500px; border:2px solid #333; } .clearfix:after{ content:\".\"; display: block; height:0; visibility: hidden; clear:both; } .clearfix{ zoom: 1; } .box01{ width:100px; height:100px; background:blue; color:#fff; float: left; } .box02{ width:100px; height:100px; background:red; color:#fff; float: left; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"container clearfix\"> &lt;div class=\"box01\">11111&lt;/div> &lt;div class=\"box02\">22222&lt;/div> &lt;/div> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}]},{"title":"CSS背景和列表","slug":"前端/CSS/CSS背景和列表","date":"2018-12-23T13:48:00.000Z","updated":"2019-12-23T13:53:58.421Z","comments":true,"path":"2018/12/23/qian-duan/css/css-bei-jing-he-lie-biao/","link":"","permalink":"http://yoursite.com/2018/12/23/qian-duan/css/css-bei-jing-he-lie-biao/","excerpt":"","text":"背景背景颜色(background-color) 设置元素的背景的颜色，background-color: 颜色｜ transparent 注意 transparent是全透明黑色(black)的速记法，类似rgba(0,0,0,0)这样的值。 颜色值（颜色名｜RGB｜十六进制｜)。 背景区包括内容、内边距（padding）和边框、不包含外边距（margin）。 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> div{ width: 300px; height: 300px; background-color: rgb(255,0,0); /*padding: 10px;*/ /*margin: 10px;*/ border: 20px dashed; } &lt;/style> &lt;/head> &lt;body> &lt;div>background-color&lt;/div> &lt;/body> &lt;/html> 背景图片(background-image)设置元素的背景图片 background-image : URL｜ none 注意： url地址可以是相对地址也可以是绝对地址 元素的背景占据了元素的全部尺寸，包括内边距和边框，但不包括外边距。 默认地，背景图像位于元素的左上角，并在水平和垂直方向上重复。 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> div{ width: 300px; height: 300px; background-color: #ff0000; background-image: url(img/bg-little.png); /*padding: 20px;*/ /*margin: 20px;*/ /*border: 20px dashed; */ } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;/body> &lt;/html> 背景图片重复background-repeat repeat ：默认值，背景图片水平方向和垂直方向重复。 repeat-x：背景图片水平方向重复。 repeat-y : 背景图片垂直方向重复。 no-repeat : 背景图片不重复。 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> div{ width: 300px; height: 300px; background-image: url(img/bg-little.png); background-repeat: no-repeat; /*background-repeat:repeat;*/ /*background-repeat:repeat-x;*/ /*background-repeat:repeat-y;*/ border: 1px solid #ff0000; } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;/body> &lt;/html> 图片显示方式设置元素的背景图片的显示方式 background-attachment: scroll ｜fixed 注意： scroll ：默认值，背景图片随滚动条滚动 fixed ：当页面的其余部分滚动时，背景图片不会移动 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> div{ width: 300px; height: 1500px; background-image: url(img/bg-little.png); background-repeat: no-repeat; border: 1px solid #ff0000; /*background-attachment: fixed;*/ background-attachment: scroll; } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;/body> &lt;/html> 图片定位设置元素的背景图片的起始位置 background-position : 百分比 ｜值 top ｜right ｜ bottom ｜ left ｜ center 值 说明 注意 长度值（x y） 第一个值水平位置，第二个值垂直位置左上角0 0 只写一个参数的话，第二个默认为居中 百分比（x% y%） 第一个值水平位置的百分比，第二个值垂直位置的百分比左上角0% 0%，有下角100% 100%，如果仅规定了一个值，另一个值将是 50%。 只写一个参数的话，第二个默认为居中 top 顶部显示，相当于垂直方向0 只写一个参数的话，第二个默认为居中 right 右边显示，相当于水平方向100% 只写一个参数的话，第二个默认为居中 left 左边显示，相当于水平方向0 只写一个参数的话，第二个默认为居中 bottom 底部显示，相当于垂直方向100% 只写一个参数的话，第二个默认为居中 center 居中显示，相当于水平方向50%垂直方向50% 水平、垂直方向都居中 背景图片定位 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> div{ width: 300px; height: 1500px; background-image: url(img/bg-little.png); background-repeat: no-repeat; border: 1px solid #ff0000; background-position: bottom left; } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;/body> &lt;/html> 背景缩写background：- [background-color] - [background-image] - [background-repeat] - [background-attachment] - [background-position] [] 注意 各值之间用空格分割 ，不分先后顺序。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> div{ width: 100%; height: 1500px; border: 1px solid #ff0000; background: #000000 url(img/bg-little.png) no-repeat right fixed; } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;/body> &lt;/html> 列表列表项标记样式设置列表项的标记样式类型 list-style-type : 关键字 ｜none 无序列表 值 说明 none 无标记 disc 实心的圆点 circle 空心的圆点 square 实心的方法 有序列表 值 说明 none 无标记 decimal 从1开始的整数 lower-roman 小写罗马数字 upper-roman 大写罗马数字 lower-alpha 小写英文字母 upper-alpha 大写英文字母 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> ul li { /*无序列表*/ /*list-style-type: circle;*/ /*list-style-type: square;*/ /*有序列表*/ /*list-style-type: decimal;*/ /*list-style-type: upper-roman;*/ list-style-type: upper-alpha; } &lt;/style> &lt;/head> &lt;body> &lt;ul> &lt;li>家用电器&lt;/li> &lt;li>电脑&lt;/li> &lt;li>手机&lt;/li> &lt;/ul> &lt;/body> &lt;/html> 图片列表项的标记 list-style-image : URL ｜none 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> ul li { list-style-image: url(img/remind.png); } &lt;/style> &lt;/head> &lt;body> &lt;ul> &lt;li>家用电器&lt;/li> &lt;li>电脑&lt;/li> &lt;li>手机&lt;/li> &lt;/ul> &lt;/body> &lt;/html> 列表项标记的位置设置列表项标记的位置list-style-position : inside ｜outside inside :列表项目标记放置在文本以内，且环绕文本根据标记对齐 outside :默认值，列表项目标记放置在文本以外，且环绕文本不根据标记对齐 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> ul li { list-style-image: url(img/remind.png); list-style-position: inside; } &lt;/style> &lt;/head> &lt;body> &lt;ul> &lt;li>家用电器家用电器家用电器家用电器家用电器家用电器 家用电器家用电器家用电器家用电器家用电器家用电器 &lt;/li> &lt;li>电脑&lt;/li> &lt;li>手机&lt;/li> &lt;/ul> &lt;/body> &lt;/html> 列表样式缩写list-style : list-style-type list-style-position list-style-image 注意: 值之间用空格分隔割 顺序不固定 list-style-image 会覆盖 list-style-type的设置 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> ul li { list-style: url(img/remind.png) inside square ; } &lt;/style> &lt;/head> &lt;body> &lt;ul> &lt;li>家用电器家用电器家用电器家用电器家用电器 家用电器家用电器家用电器家用电器家用电器家用电器家&lt;/li> &lt;li>电脑&lt;/li> &lt;li>手机&lt;/li> &lt;/ul> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}]},{"title":"盒子模型","slug":"前端/CSS/盒子模型","date":"2018-12-23T13:47:28.000Z","updated":"2019-12-23T13:51:44.395Z","comments":true,"path":"2018/12/23/qian-duan/css/he-zi-mo-xing/","link":"","permalink":"http://yoursite.com/2018/12/23/qian-duan/css/he-zi-mo-xing/","excerpt":"","text":"盒子模型概述任何一个网页元素包含由这些属性组成：内容(content)、内边距(padding)、边框(border)、外边距(margin)， 这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模型。 内容（content）就是盒子里装的东西 内边距(padding)就是怕盒子里装的东西（贵重的）损坏而添加的泡沫或者其它抗震的辅料； 边框(border)就是盒子本身了； 外边界(margin)则说明盒子摆放的时候的不能全部堆在一起，要留一定空隙保持通风，同时也为了方便取出。 盒子模型的属性两种盒子模型： 标准盒子模型content-box：宽和高会被内边距，边框撑大。设置的是内容的宽和高 怪异盒子模型border-box：设置了固定的宽和高，设置内边距和边框，网页元素会被挤压。 如何计算盒子的尺寸 在盒子模型中，最重要的还是如何理解元素的实际尺寸。 盒子模型分为两种，分别是：标准盒模型 和 怪异盒模型。绝大多数元素的尺寸默认是按照标准盒模型计算的 标准盒子模型 怪异盒子模型 计算方式标准盒子： 实际宽度=内容宽度+内边距+边框宽度 实际高度=内容高度+内边距+边框高度 怪异盒子： 实际宽度=宽度 实际高度=高度 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>盒子模型&lt;/title> &lt;style> .test1 { width: 200px; height: 200px; /*粗细 线型 颜色*/ border: 15px solid #eee; padding: 10px; /*标准盒子模型，以内容为准，默认*/ box-sizing: content-box; } .test2 { width: 200px; height: 200px; /*粗细 线型 颜色*/ border: 15px solid #eee; padding: 10px; /*怪异盒子，以边框为准 */ box-sizing:border-box; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"test1\"> &lt;/div> &lt;br/> &lt;div class=\"test2\"> &lt;/div> &lt;/body> &lt;/html> 宽度属性宽度 width：长度值 | 百分比 | auto 最大宽度 max-width：长度值 | 百分比 | auto 最小宽度 min-width：长度值 | 百分比 | auto 高度属性高度 height：长度值 | 百分比 | auto 最大高度 max- height ：长度值 | 百分比 | auto 最小高度 min- height ：长度值 | 百分比 | auto 可设置高和宽属性 块级元素 &lt;p>、&lt;div> 、 &lt;h1> ~ &lt;h6> 、&lt;ul> 、&lt;li> 、&lt;ol> &lt;dl> 、&lt;dt> 、&lt;dd>等 替换元素 &lt;img>、&lt;input>、&lt;textarea>等 标签分类 块级标签：占据一行，换行。 &lt;div>、&lt;ul>、&lt;ol>、&lt;li>、&lt;dl>、&lt;dt>、&lt;dd> &lt;h1>~&lt;h6>、&lt;p>、&lt;form>、&lt;hr>..... 行内标签：在一行，不换行。 非替换元素：&lt;b>、&lt;em>、&lt;a>、&lt;span>..... 替换元素：&lt;img>、&lt;input>、&lt;textarea>..... 代码实现:&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>高宽属性&lt;/title> &lt;style type=\"text/css\"> .one{min-width:500px;max-width: 300px;} .three{max-height:200px;min-height: 100px;background-color: #acacac;} p{background-color: #ececec;height:auto;width:200px;} span{ background-color: #acacac;width:200px;height:100px; } img{width:200px;height: 100px;} &lt;/style> &lt;/head> &lt;body> &lt;div> &lt;p>盒子模型高度height宽度width&lt;/p> &lt;span>盒子模型高度height宽度width&lt;/span> &lt;!-- 高宽属性适用块元素和替换元素 --> &lt;img src=\"img/html.jpg\" width=\"200px\"/>&lt;img src=\"img/css.jpg\" height=\"100px\"/> &lt;!-- 高度属性height --> &lt;p class=\"one\">盒子模型最大小高度度min-height和max-height;&lt;/p> &lt;!--宽度属性--> &lt;p class=\"three\">盒子模型最大小宽度min-width和max-width;&lt;/p> &lt;/div> &lt;/body> &lt;/html> 边框属性(border) 设置元素边框宽度 border-width : thin | medium | thick | 长度值 设置元素边框颜色 border-color ： 颜色 | transparent 设置元素边框样式 border-style : 值 | none | hidden 边框属性不同方向表示border-top : [宽度] | [样式] | [颜色] border-left : [宽度] | [样式] | [颜色] border-right : [宽度] | [样式] | [颜色] border-bottom ：[宽度] | [样式] | [颜色] 代码实现：&lt;!DOCTYPE HTML> &lt;html> &lt;head> &lt;title>边框属性&lt;/title> &lt;meta charset=\"utf-8\"/> &lt;/head> &lt;style type=\"text/css\"> p{width: 150px;height:100px;background-color: #ececec;line-height: 100px;} .one{border:10px #0099ee solid;} .two{border-top:5px red solid; border-left:10px blue dotted; border-right:10px blue dotted; border-bottom:5px red solid;} &lt;/style> &lt;body> &lt;!-- border属性不同方向设置 --> &lt;p class=\"one\">边框属性border&lt;/p> &lt;p class=\"two\">边框属性border&lt;/p> &lt;/body> &lt;/html> 内边距属性(padding) 设置元素的内容与边框之间的距离（内边距或填充）,分4个方向(上、右、下、左)。 – padding-top : 长度值 | 百分比 – padding-right :长度值 | 百分比 – padding-bottom :长度值 | 百分比 – padding-left :长度值 | 百分比 注意：说明：值不能为负值 内边距属性缩写padding : 值1； //4个方向都为值1 padding : 值1 值2 ; // 上下=值1，左右=值2 padding : 值1 值2 值3；// 上=值1，左右=值2，下=值3 padding : 值1 值2 值3 值4； // 上=值1，右=值2，下=值3,左=值2 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>padding属性相关设置&lt;/title> &lt;/head> &lt;style type=\"text/css\"> .one{width:300px;height:300px;background-color: #acacac; padding:20px 10px 5px 8px;} .content{width:100%;height:100%;background-color: #ececec;padding-top: 10px; padding-left: 5px;} &lt;/style> &lt;body> &lt;div class=\"one\">&lt;div class=\"content\">padding属性&lt;/div>&lt;/div> &lt;/body> &lt;/html> 结果显示 外边距属性 设置元素与元素之间的距离（外边距）, 4个方向（上、右、下、左） – margin-top : 长度值 | 百分比 | auto – margin-right : 长度值 | 百分比 | auto – margin-bottom : 长度值 | 百分比 | auto – margin-left : 长度值 | 百分比 | auto 注意：值可为负值 外边距属性缩写 设置元素与元素之间的距离（外边距）, 4个方向（上、右、下、左） margin : 值1； //4个方向都为值1 margin : 值1 值2 ; // 上下=值1，左右=值2 margin : 值1 值2 值3；// 上=值1，左右=值2，下=值3 margin : 值1 值2 值3 值4； // 上=值1，右=值2，下=值3,左=值2 块级元素 默认情况下，相应HTML块级元素存在外边距body、h1~h6、p….. 声明margin属性，覆盖默认样式 body,h1~h6,p{margin:0;} 水平居中 margin值为auto , 实现水平方向居中显示效果。 由浏览器计算外边距 外边距合并 垂直方向，两个相邻元素都设置外边距，外边距会发生合并 合并后外边距高度=两个发生合并外边距的高度中最大值 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>margin外边距&lt;/title> &lt;/head> &lt;style type=\"text/css\"> body,p{margin:0;} .content{width:100px;height:100px;background-color: #ececec;margin:auto;} .one{width:300px;height:300px;background-color: #acacac;margin-bottom: 20px;} .two{width:300px;height:300px;background-color: #acacac;margin-top:30px;} &lt;/style> &lt;body> &lt;div class=\"one\">&lt;div class=\"content\">margin属性&lt;/div>&lt;/div> &lt;div class=\"two\">&lt;div class=\"content\">margin属性&lt;/div>&lt;/div> &lt;/body> &lt;/html> display属性inline 元素将显示为内联元素，元素前后没有换行符。 block 元素将显示为块级元素 , 元素前后会带有换行符。 inline-block 行内块元素，元素呈现为inline，具有block相应特性。 none 此元素不会被显示。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>display属性&lt;/title> &lt;style type=\"text/css\"> div,span{background-color: #00aaee; border:1px #666 solid;} .one{font-size: 0px;} div{display:inline-block; font-size:16px; width:100px; height:30px; padding:5px; margin:10px;} span{display:none;} a:hover span{display:inline;} &lt;/style> &lt;/head> &lt;body> &lt;!--块级元素--> &lt;div>display属性-div&lt;/div> &lt;div>display属性-div&lt;/div> &lt;div>display属性-div&lt;/div> &lt;div>display属性-div&lt;/div> &lt;div>display属性-div&lt;/div> &lt;div>display属性-div&lt;/div> &lt;hr/> &lt;!--内联元素--> &lt;span>display属性-sapn&lt;/span>&lt;span>display属性-sapn&lt;/span>&lt;span>display属性-sapn&lt;/span> &lt;hr/> &lt;a href=\"#\">点我...&lt;span>和你玩游戏&lt;/span>&lt;/a> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}]},{"title":"CSS字体和文本样式","slug":"前端/CSS/CSS字体和文本样式","date":"2018-12-23T13:46:51.000Z","updated":"2019-12-23T13:51:00.472Z","comments":true,"path":"2018/12/23/qian-duan/css/css-zi-ti-he-wen-ben-yang-shi/","link":"","permalink":"http://yoursite.com/2018/12/23/qian-duan/css/css-zi-ti-he-wen-ben-yang-shi/","excerpt":"","text":"字体属性 定义元素内文字以什么字体来显示。 语法：font-family:[字体1][,字体2][,…] 注意: 含空格字体名和中文，用英文引号(‘ ‘)括起。 多个字体，用英文逗号“，”隔开。 引号嵌套，外使用双引号，内使用单引号。 代码示例:&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>文字样式&lt;/title> &lt;style type=\"text/css\"> h1{font-family:\"Times New Roman\";} p{font-family:\"微软雅黑\",\"宋体\",\"黑体\",sans-serif;} &lt;/style> &lt;/head> &lt;body> &lt;h1 style=\"font-family:'宋体';\">CSS层叠样式表（Cascading Style Sheets）&lt;/h1> &lt;p>CSS目前最新版本为CSS3，是能够真正做到网页表现与内容分离的一种样式设计语言。&lt;/p> &lt;/body> &lt;/html> 字体大小属性font-size: 绝对单位|相对单位 px 像素 em/% 属性值 CCS2缩放系数1.2 xx-small 9px x-small 11px small 13px medium 16px large 19px x-large 23px xx-large 28px 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>字体样式&lt;/title> &lt;style type=\"text/css\"> .larger{font-size:larger;} .smaller{font-size:smaller;} #fontSize{font-size: 20px;} .percent{font-size: 150%;} &lt;/style> &lt;/head> &lt;body> &lt;!-- 相对单位 --> &lt;p>文字大小px,受显示器分辨率影响&lt;/p> &lt;p>文字大小&lt;span class=\"larger\">相对父元素的文字大小变大&lt;/span>&lt;/p> &lt;p>文字大小&lt;span class=\"smaller\">相对父元素的文字大小变小&lt;/span>&lt;/p> &lt;div id=\"fontSize\"> &lt;p>文字大小&lt;span class=\"em\">相对值em&lt;/span>&lt;/p> &lt;p class=\"percent\">文字大小&lt;span class=\"percent\">相对值%&lt;/span>&lt;/p> &lt;/div> &lt;/body> &lt;/html> 文字颜色 定义元素内文字颜色 语法：color: 颜色名|十六进制|RGB 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>文字样式&lt;/title> &lt;style type=\"text/css\"> h1{color:red;}/*具体颜色名称*/ p{color:rgb(0%,100%,0%);}/*数字：0~255；百分比：0%~100%*/ div{color:#00880a;}/*十六进制：#开头，六位，0~F*/ &lt;/style> &lt;/head> &lt;body> &lt;h1>CSS层叠样式表（Cascading Style Sheets）&lt;/h1> &lt;p>CSS能够根据不同使用者的理解能力，简化或者优化写法，针对各类人群，有较强的易读性。&lt;/p> &lt;div>CSS目前最新版本为CSS3，是能够真正做到网页表现与内容分离的一种样式设计语言。&lt;/div> &lt;/body> &lt;/html> 文字粗细语法：font-weight: normal | bold | bolder | lighter | 100~900 注意: 默认值：normal。 400 等同于 normal，而 700 等同于 bold。 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>文字样式&lt;/title> &lt;style type=\"text/css\"> p{font-family: \"黑体\";} .normal{font-weight:normal;} .bold{font-weight:bold;} .bolder{font-weight:bolder;} .lighter{font-weight:lighter;} .f100{font-weight:100;} .f200{font-weight:200;} &lt;/style> &lt;/head> &lt;body> &lt;!-- HTML中加粗 --> &lt;p>字体粗细&lt;b>font-weight&lt;/b>&lt;/p> &lt;p>字体粗细&lt;strong>font-weight&lt;/strong>&lt;/p> &lt;!-- CSS样式加粗 --> &lt;p class=\"normal\">字体粗细font-weight：normal&lt;/p> &lt;p class=\"bolder\">字体粗细font-weight：bolder&lt;/p> &lt;p class=\"bold\">字体粗细font-weight：bold&lt;/p> &lt;p class=\"lighter\">字体粗细font-weight：lighter&lt;/p> &lt;!-- 数值 --> &lt;p class=\"f100\">字体粗细font-weight：100&lt;/p> &lt;p class=\"f200\">字体粗细font-weight：200&lt;/p> &lt;/body> &lt;/html> 文字样式 为元素内文字设置样式 语法:font-style: normal|italic|oblique 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>文字样式&lt;/title> &lt;style type=\"text/css\"> .normal{font-style:normal;} .italic{font-style:italic;} .oblique{font-style:oblique;} &lt;/style> &lt;/head> &lt;body> &lt;!-- HTMl中斜体 --> &lt;p>正常的字体&lt;/p> &lt;p>&lt;em>斜体&lt;/em>&lt;/p> &lt;p>&lt;i>斜体&lt;/i>&lt;/p> &lt;!-- CSS样式中斜体 --> &lt;p class=\"normal\">正常的字体&lt;/p> &lt;p class=\"italic\">斜体&lt;/p> &lt;p class=\"oblique\">倾斜&lt;/p> &lt;/body> &lt;/html> 字体变形 设置元素中文本为小型大写字母。 语法：font-variant: normal | small-caps 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>文字样式&lt;/title> &lt;style type=\"text/css\"> .fontVariant{font-variant:small-caps;} &lt;/style> &lt;/head> &lt;body> &lt;p>CSS层叠样式表（Cascading Style Sheets）&lt;/p> &lt;p class=\"fontVariant\">CSS层叠样式表（Cascading Style Sheets）&lt;/p> &lt;/body> &lt;/html> font属性(简写)语法：font : font-style font-variant font-weight font-size/line-height font-family 注意: 值之间空格隔开 注意书写顺序 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>文字样式&lt;/title> &lt;style type=\"text/css\"> P{ /*font-size:20px; font-family:\"黑体\",\"宋体\"; font-style:italic; font-weight:bold; font-variant: small-caps;*/ font:italic bold small-caps 50px/1.5em \"黑体\",\"宋体\"; } &lt;/style> &lt;/head> &lt;body> &lt;p>CSS层叠样式表（Cascading Style Sheets）&lt;/p> &lt;/body> &lt;/html> text-align 设置元素内文本的水平对齐方式。 语法：text-align: left | right | center | justify 代码实现注意：该属性对块级元素设置有效，如不是块级元素，可用块级元素对其进行封装。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> &lt;title>文本属性&lt;/title> &lt;style type=\"text/css\"> .text1{text-align:left;} .text2{text-align:center;} .text3{text-align:right;} .text4{text-align:justify;} .textAlign{text-align:center;} .textAlign p{width:50%;margin:0 auto;} &lt;/style> &lt;/head> &lt;body> &lt;div class=\"textAlign\"> &lt;P>指定宽度HTML 指的是超文本标记语言 (Hyper Text Markup Language), HTML 不是一种编程语言，而是一种标记语言 (markup language)。&lt;/P> &lt;/div> &lt;P class=\"text1\">文本左对齐：HTML 指的是超文本标记语言 (Hyper Text Markup Language), HTML 不是一种编程语言，而是一种标记语言 (markup language)。 &lt;/P> &lt;P class=\"text2\">文本居中对齐：HTML 指的是超文本标记语言 (Hyper Text Markup Language), HTML 不是一种编程语言，而是一种标记语言 (markup language),标记语言是一套标记标签。 &lt;/P> &lt;P class=\"text3\">文本右对齐：HTML 指的是超文本标记语言 (Hyper Text Markup Language), HTML 不是一种编程语言，而是一种标记语言 (markup language),标记语言是一套标记标签。 &lt;/P> &lt;P class=\"text4\">文本两端对齐：HTML 指的是超文本标记语言 (Hyper Text Markup Language), HTML 不是一种编程语言，而是一种标记语言 (markup language),标记语言是一套标记标签 。 &lt;/P> &lt;/body> &lt;/html> line-height属性 设置元素中文本行高。 语法：line-height: 长度值 | 百分比 注意： 一行文字的高度。 行高指文本行的基线间的距离。 代码实现：&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> &lt;title>文本属性&lt;/title> &lt;style type=\"text/css\"> .text1{background-color:#ececec;font-size:16px;} .text4{font-size:30px;line-height:35px;} .text4 span{line-height:50px;} h1{height:50px;background-color:#ececec;line-height:50px;} &lt;/style> &lt;/head> &lt;body> &lt;h1>HTML\\CSS\\JS关系&lt;/h1> &lt;div class=\"content\"> &lt;p class=\"text1\">网页必备技术，&lt;span style=\"line-height:20px;\">结构:HTML&lt;/span> ,&lt;span style=\"line-height:40px;\">样式:CSS ,&lt;span style=\"line-height:50px;\">动作:JavaScript。 &lt;/span>&lt;/p> &lt;p class=\"text2\">HTML（Hyper Text Markup Language）“超级文本标记语言”， 是Internet上用于设计网页的主要语言。使用标签将内容展示在网页中。 &lt;/p> &lt;p class=\"text3\">CSS（Cascading Style Sheets）译为“层叠样式表”，简称样式表。顾名思义就是设 计网页样式的。“样式”就是网页的文字、颜色、图片位置等格式；“层叠”的意思是当HTML中引用了多个样 式时，当样式文件中的样式发生冲突时，浏览器将依据层叠顺序处理。 &lt;/p> &lt;p class=\"text4\"> JavaScript在一定程度上弥补了HTML和CSS的缺陷，HTML和CSS的配合使用，提供给用户的只是一种静太 页面，缺少交互性。 &lt;/p> &lt;/div> &lt;/body> &lt;/html> vertical-align属性 设置元素内容的垂直方式。 语法:vertical-align: baseline | sub | super | top | text-top|middle | bottom | text-bottom 长度 | 百分比 文字基线 vertical-align垂直对齐 文本样式属性 字体属性 说明 word-spacing 设置元素内单词之间间距 letter-spacing 设置元素内字母之间间距 text-transform 设置元素内文本的大小写 text-decoration 设置元素内文本的装饰 text-transform capitalize |uppercase | lowercase | none text-decoration underline | overline | line-through | blink | none 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>文本样式&lt;/title> &lt;style type=\"text/css\"> .one{word-spacing: 1em;} .two{letter-spacing: -0.5em;} .one2{text-transform: capitalize;} .one3{text-transform: uppercase;} .one4{text-transform: lowercase;} .one5{text-transform: none;} &lt;/style> &lt;/head> &lt;body> &lt;p>CSS层叠样式表（Cascading Style Sheets）&lt;/p> &lt;p class=\"one\">CSS层叠样式表（Cascading Style Sheets）&lt;/p> &lt;p class=\"two\">CSS层叠样式表（Cascading Style Sheets）&lt;/p> &lt;!--文本大小写问题--> &lt;p class=\"one2\">CSS层叠样式表（Cascading style sheets）,text-align&lt;/p> &lt;p class=\"one3\">CSS层叠样式表（Cascading style sheets）&lt;/p> &lt;p class=\"one4\">CSS层叠样式表（Cascading style sheets）&lt;/p> &lt;p class=\"one5\">CSS层叠样式表（Cascading style sheets）&lt;/p> &lt;/body> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}]},{"title":"网页布局","slug":"前端/HTML/网页布局","date":"2018-12-18T13:39:07.000Z","updated":"2020-05-12T13:04:43.879Z","comments":true,"path":"2018/12/18/qian-duan/html/wang-ye-bu-ju/","link":"","permalink":"http://yoursite.com/2018/12/18/qian-duan/html/wang-ye-bu-ju/","excerpt":"","text":"div标签 是一个区块容器标记，之间是一个容器，可以包含段落、表格、图片等各种HTML元素。 span标签 没有实际意义，为了应用样式. HTML标签分类 块级标签:占据一行，换行 &lt;div>、&lt;ul>、&lt;ol>、&lt;li>、&lt;dl>、&lt;dt>、&lt;dd> &lt;h1>~&lt;h6>、&lt;p>、&lt;form>、&lt;hr>..... 行内标签:在一行，不换行 &lt;b>、&lt;em>、&lt;img>、&lt;input>、&lt;a>、&lt;sup>、 &lt;sub>、&lt;textarea>、&lt;span/> 标签嵌套规则 块级元素可包含行内元素和某些块级元素 行内元素不能包含块元素，只能包含其他行内元素 块级元素不能放在标签内 特殊块级元素只能包含行内元素，不能在包含块级元素如：h1、h2、h3、h4、h5、h6、p、dt。 块级元素与块元素并列，行内元素和行内元素并列 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;!--div标签--> &lt;div>&lt;img src=\"img\\html.jpg\"/>html课程&lt;/div> &lt;div>&lt;img src=\"img\\js1.jpg\"/>JS入门课程&lt;/div> &lt;div>&lt;img src=\"img\\js2.jpg\"/>JS进阶课程&lt;/div> &lt;!--span标签--> &lt;span>&lt;img src=\"img\\html.jpg\"/>html课程&lt;/span> &lt;span>&lt;img src=\"img\\js1.jpg\"/>JS入门课程&lt;/span> &lt;span>&lt;img src=\"img\\js2.jpg\"/>JS进阶课程&lt;/span> &lt;!--标签嵌套规则--> &lt;!--块级元素可包含行内元素和某些块级元素--> &lt;div>&lt;h1>&lt;/h1>&lt;a href=\"\">&lt;/a>&lt;/div> &lt;!--行内元素不能包含块元素，只能包含其他行内元素--> &lt;a href=\"\">&lt;h1>&lt;/h1>&lt;div>&lt;/div>&lt;/a>&lt;!--错误--> &lt;span>&lt;em>&lt;/em>&lt;/span>&lt;!--正确--> &lt;!--块级元素不能放在&lt;p>标签内--> &lt;p>&lt;div>1111&lt;/div>&lt;h1>2222&lt;/h1>&lt;/p>&lt;!--错误--> &lt;!--特殊块级元素只能包含行内元素，不能再包含块级元素 如：h1、h2、h3、h4、h5、h6、p、dt--> &lt;!--块级元素与块元素并列，行内元素和行内元素并列--> &lt;div>&lt;h1>&lt;/h1>&lt;p>&lt;/p>&lt;/div>&lt;!--正确--> &lt;div>&lt;span>&lt;/span>&lt;a href=\"\">&lt;/a>&lt;/div>&lt;!--正确--> &lt;div>&lt;h1>666&lt;/h1>&lt;span>888&lt;/span>&lt;/div>&lt;!--错误--> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/categories/Html/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/tags/Html/"}],"keywords":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/categories/Html/"}]},{"title":"Html表单","slug":"前端/HTML/表单","date":"2018-12-18T02:45:42.000Z","updated":"2020-05-12T13:04:46.443Z","comments":true,"path":"2018/12/18/qian-duan/html/biao-dan/","link":"","permalink":"http://yoursite.com/2018/12/18/qian-duan/html/biao-dan/","excerpt":"","text":"form表单语法&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> &lt;title>基础表单&lt;/title> &lt;/head> &lt;body> &lt;form action=\"\" method=\"\" name=\"\"> 表单元素.. &lt;/form> &lt;/body> &lt;/html> form标签属性： 属性 值 描述 action URL 提交表单时向何处发送表单数据 method get、post 设置表单以何种方式发送到指定页面 name form_name 表单的名称 form_name 表单的名称 target _blank、_self_parent、_top 在何处打开 action URL post和get区别GET： 使用URL传递参数 对所发送信息的数量也有限制 一般用于信息获取。 POST： 表单数据作为HTTP请求体的一部分对所发送信息的数量无限制 一般用于修改服务器上的资源。 表单元素标签 标签 描述 input 表单输入标签 select 菜单和列表标签 option 菜单和列表项目标签 textarea 文字域标签 optgroup 菜单和列表项目分组标签 输入标签语法&lt;input type=“类型属性” name=“名称 ” …… /> type属性值 Type属性值 描述 text 文字域 password 密码域 file 文件域 checkbox 复选域 radio 单选域 Button 按钮 Submit 提交按钮 Reset 重置按钮 Hidden 隐藏域 image 图像域 单行文本域(text)&lt;form> &lt;input type=\"text\" name=\"\".... /> &lt;/form> 单行文本域(属性) 属性 描述 Name 文字域的名称 Maxlength 指用户输入的最大字符长度。 Size 指定文本框的宽度，以字符个数为单位；文本框的缺省宽度是20个字符。 value 指定文本框的默认值 placeholder 规定用户填写输入字段的提示 代码示例 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> &lt;title>基础表单&lt;/title> &lt;/head> &lt;body> &lt;form> 姓名：&lt;input type=\"text\" name=\"username\"/> 密码：&lt;input type=\"password\" name=\"paw\"/> &lt;input type=\"submit\"/> &lt;/form> &lt;/body> &lt;/html> 密码框&lt;form> &lt;input type=\" password \" name=““ ….. /> &lt;/form> 文件域&lt;form> &lt;input type=\" file \" name=“…“ /> &lt;/form> 单选框注意：同一组的name值要相同。 &lt;form> &lt;input type=“radio” name=“…“ value=“…” checked /> &lt;/form> 复选框&lt;form> &lt;input type=“checkbox” name=“…“value=“…” checked /> &lt;/form> 按钮&lt;input type=“button” name=\"...\" value=“…” /> &lt;!-- 提交按钮 --> &lt;input type=“submit” name=\"...\" value=“…” /> &lt;!--重置按钮--> &lt;input type=“reset” name=\"...\" value=“…” /> 图像域（图像提交按钮）&lt;input type=“image” name=“…“ src=“imageurl” /> 隐藏域&lt;input type=“hidden” name=“…“ value=“…” /> 多行文本域textarea&lt;textarea name=“..”rows=“..” cols=“..” …> 内容..... &lt;/ textarea > 属性： 属性 描述 name 设置文本区的名称。 placeholder 设置描述文本区域预期值的简短提示。 rows 设置文本区内的可见行数。 cols 设置文本区内的可见宽度。 表单元素添加 标签 描述 描述 input 表单输入标签 select 下拉菜单和列表标签 option 下拉菜单和列表项目标签 optgroup 下拉菜单和列表项目分组标签 textarea 文字域标签 select标签属性 属性 描述 name 设置下拉菜单和列表的名称 multiple 设置可选择多个选项 size 设置列表中可见选项的数目 option标签属性 属性 描述 描述 selected 设置选项初始选中状态。 value 定义送往服务器的选项值。 语法描述： &lt;select > &lt;option value =“…“ >选项&lt;/option> &lt;option value=“…“ >选项&lt;/option> &lt;/select> 分组下拉菜单和列表标签&lt;select name=“”> &lt;optgroup label=“组1”> &lt;option value =“…“ >选项&lt;/option> &lt;option value=“…“ >选项&lt;/option> &lt;/optgroup> &lt;optgroup label=“组2”> &lt;option value =“…“ >选项&lt;/option> &lt;option value=“…“ >选项&lt;/option> &lt;/optgroup> &lt;/select> 代码实现&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> &lt;title>表单select&lt;/title> &lt;/head> &lt;body> &lt;h1 align=\"center\">注册信息&lt;/h1> &lt;hr color=\"#336699\"/> &lt;form action=\"action.jsp\" method=\"post\" target=\"_blank\"> &lt;table width=\"600px\" bgcolor=\"#f2f2f2\" align=\"center\" > &lt;tr> &lt;td align=\"right\">姓名：&lt;/td> &lt;td align=\"left\">&lt;input type=\"text\" name=\"username\" size=\"25\" maxlength=\"6\" placeholder=\"请输入姓名\"/>&lt;/td> &lt;/tr> &lt;tr> &lt;td align=\"right\">邮箱：&lt;/td> &lt;td align=\"left\">&lt;input type=\"text\" name=\"email\" value=\"@163.com\"/>&lt;/td> &lt;/tr> &lt;tr> &lt;td align=\"right\">密码：&lt;/td> &lt;td align=\"left\">&lt;input type=\"password\" name=\"paw\" size=\"25\" maxlength=\"6\" placeholder=\"请输入密码\"/>&lt;/td> &lt;/tr> &lt;tr> &lt;td align=\"right\">确认密码：&lt;/td> &lt;td align=\"left\">&lt;input type=\"password\" name=\"paw_confirm\" size=\"25\" maxlength=\"6\" placeholder=\"请再输入密码\"/>&lt;/td> &lt;/tr> &lt;tr> &lt;td align=\"right\">上传照片：&lt;/td> &lt;td align=\"left\">&lt;input type=\"file\" name=\"file\"/>&lt;/td> &lt;/tr> &lt;tr> &lt;td align=\"right\">性别：&lt;/td> &lt;td align=\"left\">男&lt;input type=\"radio\" name=\"sex\" value=\"man\"/> 女&lt;input type=\"radio\" name=\"sex\" value=\"woman\"/> 保密&lt;input type=\"radio\" name=\"sex\" value=\"bm\" checked/> &lt;/td> &lt;/tr> &lt;tr> &lt;td align=\"right\">爱好：&lt;/td> &lt;td align=\"left\">读书&lt;input type=\"checkbox\" name=\"dx1\" value=\"read\" checked/> 跳舞&lt;input type=\"checkbox\" name=\"dx1\" value=\"dance\"/> 唱歌&lt;input type=\"checkbox\" name=\"dx1\" value=\"sing\"/>&lt;/td> &lt;/tr> &lt;tr> &lt;td align=\"right\">爱好的运动：&lt;/td> &lt;td align=\"left\">跑步&lt;input type=\"checkbox\" name=\"dx2\" value=\"1\" checked/> 篮球&lt;input type=\"checkbox\" name=\"dx2\" value=\"2\"/> 跳绳&lt;input type=\"checkbox\" name=\"dx2\" value=\"3\"/>&lt;/td> &lt;/tr> &lt;tr> &lt;td align=\"right\">城市：&lt;/td> &lt;td align=\"left\"> &lt;select name=\"city\"> &lt;option value=\"xz\">--请选择--&lt;/option> &lt;option value=\"bj\" selected>北京&lt;/option> &lt;option value=\"tj\">天津&lt;/option> &lt;option value=\"hb\">河北&lt;/option> &lt;option value=\"sh\">上海&lt;/option> &lt;option value=\"fj\">福建&lt;/option> &lt;option value=\"xm\">厦门&lt;/option> &lt;/select> &lt;select name=\"city\" size=\"6\" multiple> &lt;option value=\"bj\">北京&lt;/option> &lt;option value=\"tj\">天津&lt;/option> &lt;option value=\"hb\">河北&lt;/option> &lt;option value=\"sh\">上海&lt;/option> &lt;option value=\"fj\">福建&lt;/option> &lt;option value=\"xm\">厦门&lt;/option> &lt;/select> &lt;select name=\"city\"> &lt;option>--请选择--&lt;/option> &lt;optgroup label=\"华北\"> &lt;option value=\"bj\" selected>北京&lt;/option> &lt;option value=\"tj\">天津&lt;/option> &lt;option value=\"hb\">河北&lt;/option> &lt;/optgroup> &lt;optgroup label=\"华东\"> &lt;option value=\"sh\">上海&lt;/option> &lt;option value=\"fj\">福建&lt;/option> &lt;option value=\"xm\">厦门&lt;/option> &lt;/optgroup> &lt;/select> &lt;select name=\"city\" size=\"5\" multiple> &lt;option>--请选择--&lt;/option> &lt;optgroup label=\"华北\"> &lt;option value=\"bj\" selected>北京&lt;/option> &lt;option value=\"tj\">天津&lt;/option> &lt;option value=\"hb\">河北&lt;/option> &lt;/optgroup> &lt;optgroup label=\"华东\"> &lt;option value=\"sh\">上海&lt;/option> &lt;option value=\"fj\">福建&lt;/option> &lt;option value=\"xm\">厦门&lt;/option> &lt;/optgroup> &lt;/select> &lt;/td> &lt;/tr> &lt;tr> &lt;td align=\"right\">简介:&lt;/td> &lt;td align=\"left\">&lt;textarea name=\"jj\" rows=\"6\" cols=\"50\" placeholder=\"请输入个人介绍\">&lt;/textarea>&lt;/td> &lt;/tr> &lt;tr > &lt;td colspan=\"2\" align=\"center\">&lt;input type=\"button\" value=\"来点我\" name=\"button\"/> &lt;input type=\"submit\" value=\"submit\" name=\"submit\"/> &lt;input type=\"reset\" value=\"reset\" name=\"reset\"/> &lt;input type=\"image\" name=\"image_button\" src=\"image/image-button.png\"/> &lt;/td> &lt;/tr> &lt;tr> &lt;td>&lt;input type=\"hidden\" name=\"hidden\" value=\"这是一个用户注册信息\"/>&lt;/td> &lt;td>&lt;/td> &lt;/tr> &lt;/table> &lt;/form> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/categories/Html/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/tags/Html/"}],"keywords":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/categories/Html/"}]},{"title":"Html表格","slug":"前端/HTML/Html表格","date":"2018-12-17T17:19:15.000Z","updated":"2020-05-12T13:04:41.105Z","comments":true,"path":"2018/12/18/qian-duan/html/html-biao-ge/","link":"","permalink":"http://yoursite.com/2018/12/18/qian-duan/html/html-biao-ge/","excerpt":"","text":"Html表格表格基本结构• &lt;table> 表格 • &lt;tr> 行 • &lt;td> 单元格 • &lt;th>&lt;/th> 表格头，内容居中，加粗显示 • &lt;caption>&lt;/caption> 表格标题，居中显示 表格基本语法&lt;!– 表格开始 --> &lt;table> &lt;!– tr 行标签 --> &lt;tr> &lt;!– td 单元格 --> &lt;td>……&lt;/td> &lt;/tr> &lt;tr> &lt;td>……&lt;/td> &lt;/tr> &lt;!– 表格结束 --> &lt;/table> 代码示例(两行三列的表格) &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>表格&lt;/title> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> &lt;/head> &lt;body> &lt;!--创建2行3列表格 --> &lt;table border=\"1\"> &lt;tr> &lt;td>科比&lt;/td> &lt;td>欧文&lt;/td> &lt;td>老詹&lt;/td> &lt;/tr> &lt;tr> &lt;td>8&lt;/td> &lt;td>2&lt;/td> &lt;td>23&lt;/td> &lt;/tr> &lt;/table> &lt;/body> &lt;/html> 表格划分表格划分三部分：表头、主体、脚注。 thead：表格的头 （放表格的表头） tbody：表格的主体 （放数据本体） tfoot：表格的脚 （放表格的脚注） &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>表格2&lt;/title> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> &lt;/head> &lt;body> &lt;table> &lt;caption>&lt;/caption> &lt;thead> &lt;tr> &lt;th>表头&lt;/th> &lt;/tr> &lt;/thead> &lt;tbody> &lt;tr> &lt;td>主体&lt;/td> &lt;/tr> &lt;/tbody> &lt;tfoot> &lt;tr> &lt;td>脚注&lt;/td> &lt;/tr> &lt;/tfoot> &lt;/table> &lt;/body> &lt;/html> 表格属性 属性 值 描述 width pixels、% 规定表格的宽度 align left、center、right 表格相对周围元素的对齐方式 border pixels 规定表格边框的宽度 bgcolor rgb(x,x,x)、#xxxxxx、colorname 表格的背景颜色 cellpadding pixels、% 单元边沿与其内容之间的空白 cellspacing pixels、% 单元格之间的空白 frame 属性值 规定外侧边框的那个部分是可见的 rules 属性值 规定内侧边框的哪个部分是可见的 标签属性 属性 值 描述 align align、Left、center、right、justify、char 行内容的水平对齐 valign top、middle、bottom、baseline 行内容的垂直对齐 bgcolor •rgb(x,x,x)•#xxxxxx• colorname 行的背景颜色。 和标签属性 属性 值 描述 align Left、center、right、justify、char 单元格内容的水平对齐 valign top、middle、bottom、baseline 单元格内容的垂直对齐 bgcolor • rgb(x,x,x)• #xxxxxx• colorname 单元格的背景颜色 width • %• pixels 单元格的宽度 height %• pixels 单元格的高度 、和标签属性 、和 内容的水平对齐、和 内容的垂直对齐 属性 值 描述 align Left、center、right、justify、char valign top、middle、bottom、baseline 跨列属性colspan&lt;table> &lt;tr> &lt;td colspan=“2”>…&lt;/td> &lt;td>…&lt;/td> &lt;/tr> &lt;tr> &lt;td>…&lt;/td> &lt;td>…&lt;/td> &lt;td>…&lt;/td> &lt;/tr> &lt;/table> 跨行属性rowspan&lt;table> &lt;tr> &lt;td>…&lt;/td> &lt;td rowspan=“2”>…&lt;/td> &lt;td>…&lt;/td> &lt;/tr> &lt;tr> &lt;td>…&lt;/td> &lt;td>…&lt;/td> &lt;/tr> &lt;/table> 表格嵌套嵌入表格说明: 完整表格结构. 放到标签中 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>表格嵌套&lt;/title> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> &lt;/head> &lt;body> &lt;!--创建2行3列表格 --> &lt;table border=\"1\" cellspacing=\"0\"> &lt;tr> &lt;td>2017年&lt;/td> &lt;td>2018年&lt;/td> &lt;td>2019年&lt;/td> &lt;/tr> &lt;tr> &lt;td> &lt;table border=\"1px\" cellspacing=\"0\"> &lt;tr> &lt;td>上半年&lt;/td> &lt;td>下半年&lt;/td> &lt;/tr> &lt;tr> &lt;td>800&lt;/td> &lt;td>900&lt;/td> &lt;/tr> &lt;/table> &lt;/td> &lt;td>10000&lt;/td> &lt;td>12000&lt;/td> &lt;/tr> &lt;/table> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/categories/Html/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/tags/Html/"}],"keywords":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/categories/Html/"}]},{"title":"Html基础","slug":"前端/HTML/Html基础","date":"2018-12-17T12:25:29.000Z","updated":"2020-05-12T13:04:37.947Z","comments":true,"path":"2018/12/17/qian-duan/html/html-ji-chu/","link":"","permalink":"http://yoursite.com/2018/12/17/qian-duan/html/html-ji-chu/","excerpt":"","text":"HTML基础html基本结构&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;!--头部信息--> &lt;head> &lt;!--页面编码设置--> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;/head> &lt;!--网页主体内容--> &lt;body> &lt;p>hello world&lt;/p> &lt;/body> &lt;/html> html注释&lt;!-- 要注释的内容 --> 注释在网页中不显示 文字和段落标签标题标签：~ 段落标签:&lt;p> &lt;/p> align是对齐属性值 值 描述 left 左对齐内容。 right 右对齐内容。 center 居中对齐内容。 justify 对行进行伸展，这样每行都可以有相等的长度。 换行标签: 水平线: &lt;hr/> 属性： 属性 描述 width 设置水平线宽度，可以像素或百分比 color 设置水平线颜色 align 设置水平线居中对齐 noshade 设置水平线无阴影 文字斜体**: 、 加粗： 、 上标和下标- &lt;sub> - &lt;sup> 插入内容和删除内容：- ins - del 特殊符号 属性 显示结果 描述 &amp;lt &lt; 小于号或显示标记 &amp;gt &gt; 大于号或显示标记 &amp;reg ® 已注册 &amp;copy © 版权 &amp;trade ™ 商标 &amp;nbsp Space 不断行的空白 列表标签 有序列表&lt;ol> &lt;li>列表项&lt;/li> &lt;li>列表项&lt;/li> &lt;/ol> type属性值: 值 描述 1 数字1，2…… 数字1，2…… a 小写字母a , b…… 小写字母a , b…… A 大写字母A , B…… 大写字母A , B…… i 小写罗马数字 i 小写罗马数字 i I 大写罗马数字 I 大写罗马数字 I 无序列表&lt;ul> &lt;li>列表项&lt;/li> &lt;li>列表项&lt;/li> &lt;/ul> type属性值: 值 描述 disc 圆点 square 正方形 circle 空心圆 定义列表&lt;dl> &lt;dt>定义列表项&lt;/dt> &lt;dd>列表项描述&lt;/dd> &lt;dt>定义列表项&lt;/dt> &lt;dd>列表项描述&lt;/dd> &lt;/dl> 代码实现： &lt;dl> &lt;dt>什么是 HTML？&lt;/dt> &lt;dd>HTML 是用来描述网页的一种语言。&lt;/dd> &lt;dd> &lt;ul> &lt;li>HTML 指的是超文本标记语言 (Hyper Text Markup Language)&lt;/li> &lt;li>HTML 不是一种编程语言，而是一种标记语言 (markup language)&lt;/li> &lt;li>标记语言是一套标记标签 (markup tag)&lt;/li> &lt;li>HTML 使用标记标签来描述网页&lt;/li> &lt;/ul> &lt;/dd> &lt;dt>HTML 标签&lt;/dt> &lt;dd>HTML 标记标签通常被称为 HTML 标签 (HTML tag)&lt;/dd> &lt;dd> &lt;ol> &lt;li>HTML 标记标签通常被称为 HTML 标签&lt;/li> &lt;li>HTML 标签是由尖括号包围的关键词&lt;/li> &lt;li>HTML 标签通常是成对出&lt;/li> &lt;li>标签对中的第一个标签是开始标签，第二个标签是结束标签&lt;/li> &lt;/ol> &lt;/dd> &lt;/dl> 5- 图像和超链接标签图像标签 img属性： 属性 值 描述 值 描述 Src（必写） URL 显示图像的URL URL 显示图像的URL alt 文字 图像替代文本 文字 图像替代文本 height 数值和百分比 图像的高 数值和百分比 图像的高 width 数值和百分比 图像的宽 数值和百分比 图像的宽 相对路径和绝对路径 1.图像与文件在同一目录下 &lt;img src = \"x.jpg\"/> 2.图像在上一级目录中 &lt;img src = \"../x.jpg\"/> 3.图像在下一级目录中 &lt;img src=\"文件夹名/x.jpg\"> 超链接标签属性: &lt; a href=” “&gt;内容 属性 描述 href 链接地址 arget 链接的目标窗口_self、_blank、_top、_parent title 链接提示文字 name 链接命名 定义锚（同一页面)&lt; a href=“#锚名1”>目录1 &lt;/a> &lt; a href=“#锚名2”>目录2 &lt;/a> &lt; a href=“…”name=“锚名1”>内容&lt;/a> &lt; a href=“…”name=“锚名2”>内容&lt;/a> 定义锚（不同页面）网页1:&lt;a href= \"网页名称#锚名\">...&lt;/a> 网页2:&lt;a name= \"锚名\">&lt;/a> 总结： 定义锚的位置和锚名。 设置寻找锚的链接 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/categories/Html/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/tags/Html/"}],"keywords":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/categories/Html/"}]}]}