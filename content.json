{"meta":{"title":"guardwhy","subtitle":"just do it","description":"专注于技术,热爱生活,分享知识","author":"guardwhy","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2020-04-29T02:21:58.000Z","updated":"2020-04-29T02:22:22.024Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-04-29T02:19:56.000Z","updated":"2020-04-29T02:20:48.288Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"books","date":"2020-05-07T08:39:23.000Z","updated":"2020-05-07T08:43:00.176Z","comments":true,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2020-04-29T02:25:06.000Z","updated":"2020-04-29T02:25:34.464Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-04-29T02:22:38.000Z","updated":"2020-04-29T02:22:59.473Z","comments":true,"path":"contact/index.html","permalink":"http://yoursite.com/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-04-29T02:21:09.000Z","updated":"2020-04-29T02:21:41.505Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"linux之用户管理","slug":"linux/linux之用户管理","date":"2020-04-18T02:05:49.000Z","updated":"2020-04-18T07:01:29.980Z","comments":true,"path":"2020/04/18/linux/linux-zhi-yong-hu-guan-li/","link":"","permalink":"http://yoursite.com/2020/04/18/linux/linux-zhi-yong-hu-guan-li/","excerpt":"","text":"1-添加用户 useradd [选项] 用户名。 也可以通过useradd -d指定目录, 新的用户名，给新创建的用户指定家目录 图示： 给用户修改密码语法： passwd 用户名 图示： 2-删除用户语法userdel 用户名 删除用户 kobe，但是要保留家目录 删除用户 Jmaes 以及用户主目录 图示: 3-切换用户在操作 Linux 中，如果当前用户的权限不够，可以通过 su - 指令，切换到高权限用户，比如 root 语法：su –切换用户名 图示： 4-用户组语法： 添加组: groupadd 组名 删除组：groupdel 组名 增加用户组语法： useradd -g 用户组 用户名 图示： 修改用户组语法： usermod -g 用户组 用户名 图示 配置信息 1./etc/passwd 文件。 用户（user）的配置文件，记录用户的各种信息。 2 . /etc/shadow 文件 口令的配置文件 每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志。 3./etc/group 文件 组(group)的配置文件，记录 Linux 包含的组的信息每行含义：组名:口令:组标识号:组内用户列表 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}]},{"title":"CPP之模板","slug":"c++/CPP之模板","date":"2019-12-16T07:58:05.000Z","updated":"2020-05-06T10:41:14.703Z","comments":true,"path":"2019/12/16/c/cpp-zhi-mo-ban/","link":"","permalink":"http://yoursite.com/2019/12/16/c/cpp-zhi-mo-ban/","excerpt":"","text":"函数模板引出 首先通过函数重载，实现同名函数，根据不同的参数类型，进行智能调用。 对比函数重载，函数模板，只需要一个函数就搞定。 意义: 模板是泛型编程的一种重要思想。stl就是利用模板实现的一个具体实例。 函数模板的写法template &lt;typename T> void fun(T tt) { cout &lt;&lt; tt &lt;&lt; endl; } 格式书写： template template 可以有多个参数 ： template &lt;typename T, typename Y&gt; 作用域： 仅对下边挨着的代码段有效。 代码实现：#include &lt;iostream> using namespace std; // 定义模板 template&lt;typename T, typename Y> void fun(T a, Y y) { // 输出结果 cout &lt;&lt; a &lt;&lt;\" \"&lt;&lt; y &lt;&lt; endl; } template&lt;typename T, typename Y> void fun1(T a, Y y) { // 输出结果 cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl; } int main() { // 调用函数 fun('a', 12); fun1(\"helloworld\", 34); return 0; } 具体化 特点：1- 就是将指定的类型，单独处理。 template void fun(job& j1, job& j2); 要单独写个实现. 调用：fun(结构1， 结构2)； 2-调用顺序 原版函数-&gt;具体化-&gt;模板 代码实现：#include &lt;iostream> using namespace std; struct Node { int a; double b; }; template&lt;class TTT> void fun(TTT a) { cout &lt;&lt; a &lt;&lt; endl; } template&lt;> void fun&lt;Node>(Node no) { cout &lt;&lt; no.a &lt;&lt; \" \" &lt;&lt; no.b &lt;&lt; endl; } int main() { Node no = {12, 12.12}; fun(no); return 0; } 实例化 特点： 生成指定类型的函数定义 template void fun(job&amp; j1, job&amp; j2); 调用：fun(结构1， 结构2)； 没有函数实现 代码实现:#include &lt;iostream> using namespace std; struct Node { int a; double b; }; template&lt;class TTT> void fun(TTT a) { cout &lt;&lt; a &lt;&lt; endl; } /* 代码实例化 */ template void fun&lt;int>(int a); int main() { Node no = {12, 12.12}; fun(12.13); return 0; } 类模板特点 1.可以设定默认值 template &lt;typename T, typename Y = char> 只有类模板可以有默认值 必须从右向左连续赋值默认类型，跟函数参数默认值一样，传递的时候会覆盖掉。 2.创建对象传递模板参数列表 类模板，需要在类型后加模板参数列表 CFather&lt;int, char> fp;有默认值的时候可以不传。但是必须要有&lt;>，CFather&lt;> fp; CFather&lt;int,char>* pf = new CFather&lt;int ,char>;除了类之外，任何位置出现CFather,都要加上模板参数列表. 3.类外实现的函数模板的写法 template &lt;class T,class B , class C> void CA&lt;T, B, C>::fun(T a) { } void CFather&lt;int, char>::Show() { cout &lt;&lt; a &lt;&lt; endl; } 代码实现: #include &lt;iostream> using namespace std; template&lt;typename T, typename Y = int> class CFather { public: T a; CFather(T t) { a = 12; } void Show(); }; template&lt;typename T, typename Y> void CFather&lt;T, Y>::Show() { cout &lt;&lt; a &lt;&lt; endl; } int main() { //模板参数列表 CFather&lt;int,char> pf(1); pf.Show(); CFather&lt;int,char>* fp = new CFather&lt;int, char>(1); fp->Show(); return 0; } 继承的模板特点:模板参数列表的传递: 直接指定固定的类型 通过子类模板参数列表传递 继承的时候要写：public CFather&lt;T> 构造函数传递(父类有参数构造）：CFather&lt;T> 创建对象时候要写 CFather&lt;int, char> fp; 代码实现#include &lt;iostream> using namespace std; template&lt;typename T, typename Y = int> class CFather { public: T a; CFather() { a = 12; } virtual void Show() { cout &lt;&lt; \"SHow\" &lt;&lt; endl; } }; template&lt;typename X, typename Z> class CSon : public CFather&lt;X, Z> { public: CSon() : CFather&lt;X, Z>() { } void Show() { } }; int main() { CFather&lt;int , char>* pf = new CSon&lt;int , char>; system(\"pause\"); return 0; } 多态的模板注意： 子类没模板 CFather&lt;short, char&gt;* pf = new CSon; 子类有模板 CFather&lt;short, char&gt;* pf = new CSon&lt;short, int ,char&gt;; 类型一定要对应上 代码实现：#include &lt;iostream> using namespace std; template&lt;typename T, typename Y = int> class CFather { public: virtual void fun() { cout &lt;&lt; \"CFather\" &lt;&lt; endl; } }; template&lt; typename X, typename W, typename Z> class CSon : public CFather&lt;X, Z> { public: void fun() { cout &lt;&lt; \"CSon\" &lt;&lt; endl; } }; int main() { CFather&lt;short, char>* pf = new CSon&lt;short, int ,char>; pf->fun(); return 0; } ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"CPP之运算符重载","slug":"c++/CPP之运算符重载","date":"2019-12-15T13:34:29.000Z","updated":"2020-05-06T10:41:06.608Z","comments":true,"path":"2019/12/15/c/cpp-zhi-yun-suan-fu-chong-zai/","link":"","permalink":"http://yoursite.com/2019/12/15/c/cpp-zhi-yun-suan-fu-chong-zai/","excerpt":"","text":"运算符重载的需求 C++预定义的运算符，只能用于基本数据类型的运算：整型、实型、字符型、逻辑型.......+、-、*、/、%、^、&amp;、~、!、|、=、&lt;&lt;>>、!=、…… 在数学上，两个复数可以直接进行+、-等运算。但在C++中，直接将+或-用于复数对象是不允许的。 有时会希望，让对象也能通过运算符进行运算。这样代码更简洁，容易理解。 例如： complex_a和complex_b是两个复数对象；求两个复数的和, 希望能直接写： complex_a + complex_b 运算符重载的定义 运算符重载，就是对已有的运算符(C++中预定义的运算符)赋予多重的含义，使同一运算符作用于不同类型的数据时导致不同类型的行为。 运算符重载的目的是：扩展C++中提供的运算符的适用范围，使之能作用于对象。 同一个运算符，对不同类型的操作数，所发生的行为不同。 complex_a + complex_b 生成新的复数对象 5 + 4 = 9 作用：赋予运算符自定义功能。 默认:常数+常数 比如对象+对象，默认情况下是不被允许的，当我们重载了+后，就可以实现对象相加了。 对象+常数，常数+对象重载函数，函数的两个参数在小括号内，运算符的两个参数在两侧。 运算符重载的形式： 运算符重载的实质是函数重载 可以重载为普通函数，也可以重载为成员函数 。 把含运算符的表达式转换成对运算符函数的调用。 把运算符的操作数转换成运算符函数的参数。 运算符被多次重载时，根据实参的类型决定调用哪个运算符函数。 返回值类型 operator 运算符（形参表） { …… } 1-无返回值代码实现#include &lt;iostream> using namespace std; class CStu { public: // 声明两个成员变量 int nAge; double dScore; // 创建构造函数 CStu() { nAge = 12; dScore = 12.12; } }; //运算符重载 void operator+(CStu&amp; st, int a) { cout &lt;&lt; (st.nAge + a) &lt;&lt; endl; } void operator+(int a, CStu&amp; st) { cout &lt;&lt; (st.nAge + a) &lt;&lt; endl; } int main() { // 声明两个对象 CStu st1, st2; // + int a = 13; a + 13; //st1 + st2; st1 + 12; 12 + st2; return 0; } 2-带返回值代码实现#include &lt;iostream> using namespace std; class CStu { public: // 声明两个成员变量 int nAge; double dScore; // 创建构造函数 CStu() { nAge = 12; dScore = 12.12; } }; //运算符重载 int operator+(CStu&amp; st, int a) { return (st.nAge + a); } int main() { // 声明两个对象 CStu st1, st2; cout &lt;&lt; (st1 + 12 + 13) &lt;&lt; endl; return 0; } 3-类外重载 左边是左参数，右边是右参数 #include &lt;iostream> using namespace std; class CStu { public: int nAge; double dScore; CStu() { nAge = 12; dScore = 12.12; } }; //运算符重载 int operator+(CStu&amp; st, int a) { return (st.nAge + a); } int operator+(int a, CStu&amp; st) { return (st.nAge + a); } CStu&amp; operator+(CStu&amp; st1, CStu&amp; st) { st1.nAge += st.nAge; return st1; } CStu&amp; operator::(CStu&amp; st1,int a) { st1.nAge += st.nAge; return st1; } int main() { CStu st1, //对象1 st2; // 输出结果 cout &lt;&lt; (st1 + 12 + 13 + (st2 + st2) + 23); return 0; } 4-类内重载 默认左边是类的类型 #include &lt;iostream> using namespace std; class CStu { public: int nAge; CStu() { nAge = 12; } // 类内重载 int operator+(int a) { return (this->nAge + a); } }; // 类外重载 int operator+(int a, CStu&amp; st) { return (a - st.nAge); } int main() { CStu st; cout &lt;&lt; (st + 12) &lt;&lt; endl; cout &lt;&lt; (13 + st) &lt;&lt; endl; return 0; } 5-二元运算符算术运算符 + ,- ,* ,/ ,% , 关系运算符 >= ,&lt;= ,> ,&lt; ,!= ,== >位运算符 >^ ,&amp; ,I >逻辑运算符 >&amp;&amp;，|| 代码实现： #include &lt;iostream> using namespace std; class CStu { public: int nAge; CStu(int age) { nAge = age; } int operator >= (CStu&amp; st2) { return (nAge >= st2.nAge); } int operator &amp; (CStu&amp; st2) { return (nAge &amp; st2.nAge); } int operator &amp;&amp; ( CStu&amp; st2) { return (nAge &amp;&amp; st2.nAge); } }; int operator += (CStu&amp; st1, CStu&amp; st2) { return (st1.nAge &amp;&amp; st2.nAge); } int main() { CStu st1(14); //st1.nage CStu st2(13); cout &lt;&lt; (st1 >= st2); cout &lt;&lt; (st1 &amp;&amp; st2); system(\"pause\"); return 0; } 6- 一元运算符#include &lt;iostream> using namespace std; class CStu { public: int nAge; CStu(int age) { nAge = age; } // 内重载 int operator-() { return (-nAge); } }; // 外重载 int operator!(CStu&amp; st) { return (!st.nAge); } int main() { CStu st1(14); //st1.nage cout &lt;&lt; (!st1); system(\"pause\"); return 0; } 7- 输出运算符重载特点： cout是一个对象 参数1是ostream引用，参数2是对象的常引用 返回值保证连续输出 必须是类外 类友元 #include &lt;iostream> using namespace std; class CStu { private: int nAge; public: CStu() { nAge = 12; } // 定义友元函数 friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const CStu&amp; st); }; ostream&amp; operator &lt;&lt; (ostream&amp; os, const CStu&amp; st) { os &lt;&lt; st.nAge; return os; } int main() { // 创建对象 CStu st; // 输出对象 cout &lt;&lt; st &lt;&lt; st &lt;&lt; \"kobe\"; return 0; } 8- 输入运算符重载istream& operator>> (istream& is, CStu& st){ // 需要输入检测是否失败 return is; } 代码示例 #include &lt;iostream> using namespace std; class CStu { private: int nAge; double dbHeight; public: CStu() { nAge = 0; dbHeight = 0.0; } void Show() { cout &lt;&lt; nAge &lt;&lt; endl; cout &lt;&lt; dbHeight &lt;&lt; endl; } friend istream&amp; operator >> (istream&amp; ist, CStu&amp; st); }; istream&amp; operator >> (istream&amp; ist, CStu&amp; st) { ist >> st.nAge >> st.dbHeight; // 需要输入检测是否失败 if (ist.fail()) { st.nAge = 0; st.dbHeight = 0; } return ist; } int main() { // 创建st对象 CStu st; cin >> st; st.Show(); return 0; } 9-赋值运算符重载#include &lt;iostream> using namespace std; class CStu { private: int nAge; double dbHeight; public: CStu() { nAge = 0; dbHeight = 0.0; } int operator=(int a) { nAge = a; return nAge; } int&amp; operator+=( int a) { nAge = nAge + a; return nAge; } }; /* // 类外重载 int&amp; operator+=(CStu&amp; st1, int a) { st1.nAge = st1.nAge + a; return st1.nAge; } */ int main() { // 创建对象 CStu st; int a = 111; cout &lt;&lt; (st += a += 113); return 0; } 10- 下标运算符重载下标运算符:[ ] ​ 返回引用 ​ 只能类内 #include &lt;iostream> using namespace std; class CStu { public: int a; int b; int c; double d; int nError; CStu() { a = 12; b = 23; c = 34; d = 45; nError = -1; } //返回指针 int&amp; operator[](int n) { switch(n) { case 0: return &amp;a; case 1: return &amp;d; } return &amp;nError; } }; int main() { CStu st; //st[1] cout &lt;&lt; *(int *)st[0]; cout &lt;&lt; *(double *)st[1]; // void 没有确定的大小 // ==》void* ==》 *(double *)st[1] = 15; cout &lt;&lt; *(double *)st[1]; return 0; } 11- 自加自减运算符重载#include &lt;iostream> using namespace std; class CStu { public: int nAge; CStu() { nAge = 12; } int operator++() { nAge += 1; return nAge; } int operator--() { this->nAge -= 1; return nAge; } int operator++(int n) //int n 理解成一个标记 { n = nAge; // nAge += 1; return n; } }; /* // 类外++ int operator++(CStu&amp; st) { st.nAge += 1; return st.nAge; } */ /* // 类外 -- int operator--(CStu&amp; st) { st.nAge -= 1; return st.nAge; } */ // 后置 ++ int operator++(CStu&amp; st, int n) //int n 理解成一个标记 { n = st.nAge; // st.nAge += 1; return n; } // 后置 -- int operator--(CStu&amp; st, int n) //int n 理解成一个标记 { n = st.nAge; // st.nAge -= 1; return n; } int main() { int a = 12; //int b = ++a; // b == 13 //a++; int b = a++; //b == 12, a == 13 CStu st; //cout &lt;&lt; ++st; //13 // cout &lt;&lt; --st; //12 cout &lt;&lt; st--; cout &lt;&lt; st.nAge; return 0; } 重载类型转换 特点​ 1、没有显示返回类型，但是要写返回值。​ 2、没有参数。​ 3、必须定义成类的成员函数​ 4、不应该改变对象的内容，所以是const函数。​ 5、避免过度使用。 使用时间 #include &lt;iostream> using namespace std; class CStu { public: int a; double b; CStu() { a = 13; b = 12.12; } // 类型转换没有返回值 operator int() const { return a; } operator double() const { return b; } }; int main() { // 创建对象 CStu st; cout &lt;&lt; int(st) &lt;&lt; endl; cout &lt;&lt; (double)st &lt;&lt; st.b &lt;&lt; endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"CPP之异常处理","slug":"c++/CPP之异常处理","date":"2019-12-15T13:33:42.000Z","updated":"2020-05-06T10:41:09.100Z","comments":true,"path":"2019/12/15/c/cpp-zhi-yi-chang-chu-li/","link":"","permalink":"http://yoursite.com/2019/12/15/c/cpp-zhi-yi-chang-chu-li/","excerpt":"","text":"程序的错误分类 语法错误: 语法错误在编译和链接阶段就能发现，只有 100% 符合语法规则的代码才能生成可执行程序。语法错误是最容发现、最容易定位、最容易排除的错误，程序员最不需要担心的就是这种错误。 逻辑错误: 是说我们编写的代码思路有问题，不能够达到最终的目标，这种错误可以通过调试来解决。 运行时错误: 是指程序在运行期间发生的错误，例如除数为 0、内存分配失败、数组越界、文件不存在等。C++ 异（Exception）机制就是为解决运行时错误而引入的。 代码示例： #include &lt;iostream> #include &lt;cstdlib> using namespace std; // 定义fun函数 void fun(int a) { // 条件判断 if (0 == a) { abort(); } // 输出结果 cout &lt;&lt; \"a\" &lt;&lt; a &lt;&lt; endl; } int main() { // 调用函数 fun(0); return 0; } 捕获异常 借助 C++ 异常机制来捕获上面的异常，避免程序崩溃。捕获异常的语法为 ： ry{ // 可能抛出异常的语句 }catch(exceptionType variable){ // 处理异常的语句 } try和catch都是 C++ 中的关键字，后跟语句块，不能省略{ }。try 中包含可能会抛出异常的语句，一旦有异常抛出就会被后面的 catch 捕获。从 try 的意思可以看出，它只是“检测”语句块有没有异常，如果没有发生异常，它就“检测”不到。catch 是“抓住”的意思，用来捕获并处理 try 检测到的异常；如果 try 语句块没有检测到异常（没有异常抛出），那么就不会执行 catch 中的语句。 注意 抛出对象的时候，要用引用或者指针，不然会拷贝备份出来，即拷贝构造函数。 代码实现: #include &lt;iostream> #include &lt;cstdlib> //cstdio using namespace std; class CPeople { public: int b; CPeople() { b = 12; } }; void fun(int a) { if (0 == a) { abort(); } cout &lt;&lt; \"a \" &lt;&lt; a &lt;&lt; endl; } void fun1(int a) { while (a &lt; 10) { if (5 == a) { throw 123.123; } a++; } } void fun2(CPeople&amp; c) { while (c.b &lt; 20) { if (15 == c.b) { throw &amp;c; } c.b++; } } int main() { // 创建对象 CPeople po; try { fun2(po); } catch(CPeople&amp; a) { } catch(CPeople* d) { d->b++; } catch(int b) { try { fun1(b+1); } catch(int a) { } } catch(char c) { cout &lt;&lt; c &lt;&lt; endl; } catch(...) { cout &lt;&lt; \"default \" &lt;&lt; endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"CPP之内联函数","slug":"c++/CPP之内联函数","date":"2019-12-15T13:33:00.000Z","updated":"2020-05-06T10:41:12.252Z","comments":true,"path":"2019/12/15/c/cpp-zhi-nei-lian-han-shu/","link":"","permalink":"http://yoursite.com/2019/12/15/c/cpp-zhi-nei-lian-han-shu/","excerpt":"","text":"常规函数执行过程： 调用时根据函数地址,跳到函数代码空间，执行指令。执行完，再跳转到调用的位置。综合：来回跳跃+记录跳跃的位置==一定的系统开销（资源+时间)。 内联函数声明: 函数声明要加inline。 函数定义要加inline 注意：只在声明位置写inline不管用. 作用： 用相应的代码替换调用 比常规函数稍快 代价是占用更多内存 特点： 内联函数比宏功能更强。 类内定义都是内联函数。 类外定义，有inline 是内联,没有inline不是内联。 内联函数与多文件，内联函数可以有多个定义，多个定义必须完全一致。所以通常内联函数写在头文件里。 代码示例: #include &lt;iostream> using namespace std; #define SUM(x) ((x)*(x)) inline void fun(int i) { cout &lt;&lt; (i*i); } class CStu { public: void fun() //inline { } inline void fun1() //inline { } void fun1(); }; inline void CStu::fun1() { } int main() { cout &lt;&lt; (SUM(2+3)); fun(2+3); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"CPP之拷贝构造","slug":"c++/CPP之拷贝构造","date":"2019-12-15T13:32:28.000Z","updated":"2020-05-06T10:41:17.084Z","comments":true,"path":"2019/12/15/c/cpp-zhi-kao-bei-gou-zao/","link":"","permalink":"http://yoursite.com/2019/12/15/c/cpp-zhi-kao-bei-gou-zao/","excerpt":"","text":"拷贝构造1-调用时间 1、新建一个对象，并将其初始化为同类现有对象 #include &lt;iostream> using namespace std; class CStu { public: CStu(){ } // 拷贝构造 CStu(const CStu&amp; a) { } }; int main() { // 声明对象 CStu st1; CStu stNew(st1); CStu stNew = st1; CStu stNew = CStu(st1); CStu* stNew = new CStu(st1); // 赋值无法实现拷贝构造 /* CStu st2; st2 = st1; CStu(st2); */ return 0; } 2.当程序生成对象副本时 函数参数传递对象的值 函数返回对象 #include &lt;iostream> using namespace std; class CStu { public: CStu() { } }; void fun(CStu a) { } CStu fun() { CStu a; return a; } int main() { CStu st1; fun(); return 0; } 2-默认拷贝构造 默认的复制构造函数，逐个复制非静态成员（成员的复制称为浅复制）值，复制的是成员的值。系统默认的这个又叫浅拷贝 #include &lt;iostream> using namespace std; class CStu { public: int b; char c[4]; CStu() { b = 12; c[0] = 'a'; strcpy_s(c, 4, \"abc\"); // 源 } CStu(const CStu&amp; a) { this->b = a.b; strcpy_s(this->c, 4, a.c); } }; int main() { CStu st; cout &lt;&lt; st.b &lt;&lt; \" \" &lt;&lt; st.c &lt;&lt; endl; CStu st1 = st; cout &lt;&lt; st1.b &lt;&lt; \" \" &lt;&lt; st1.c &lt;&lt; endl; return 0; } ==特点==：同一个类的多个对象，内存排布是一样的，地址不同 3-深拷贝深拷贝：指针成员不能直接赋值，要用内存拷贝，memcpy，strcpyd等。 解决拷贝构造所引发的指针成员二次释放崩溃的问题的方式 深拷贝 传地址 传引用 #include &lt;iostream> using namespace std; class CStu { public: int *a; CStu() { a = new int[2]; a[0] = 12; a[1] = 13; } CStu(const CStu&amp; b) { this->a = new int[2]; memcpy(this->a, b.a, 8); //memory copy } ~CStu() { delete[] a; } }; /* 传递引用 */ CStu&amp; fun(CStu&amp; a) { return a; } /* 传递指针 */ CStu* fun(CStu* a) { return a; } int main() { { CStu at; cout &lt;&lt; at.a[0] &lt;&lt; \" \" &lt;&lt; at.a[1] &lt;&lt; endl; fun(&amp;at); CStu st = at; cout &lt;&lt; st.a[0] &lt;&lt; \" \" &lt;&lt; st.a[1] &lt;&lt; endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"C语言之流程控制","slug":"C语言/C语言之流程控制","date":"2019-12-15T13:23:51.000Z","updated":"2020-05-12T03:26:44.691Z","comments":true,"path":"2019/12/15/c-yu-yan/c-yu-yan-zhi-liu-cheng-kong-zhi/","link":"","permalink":"http://yoursite.com/2019/12/15/c-yu-yan/c-yu-yan-zhi-liu-cheng-kong-zhi/","excerpt":"","text":"条件判断if-else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为 false 时执行。 语法： if(boolean_expression) { /* 如果布尔表达式为真将执行的语句 */ } else { /* 如果布尔表达式为假将执行的语句 */ } 流程图 代码示例 #include &lt;stdio.h> int main() { // 定义变量 short a = 1; short b = 2; int c = a - b; // 条件判断 if( c > 0 ) { printf(\"a > b\\n\"); } else { printf(\"a &lt;= b\\n\"); } return 0; } if- else if-else语句 代码示例 #include &lt;stdio.h> int main() { // 定义且初始化变量 int x = 0; int y = 0; printf(\"请输入两个数：\"); // 请输入两个数 scanf(\"%d%d\", &amp;x, &amp;y); if (x > y) { printf(\"The bigger is: %d\\n\", x); } else if (x &lt; y) { printf(\"The bigger is: %d\\n\", y); } else { printf(\"The 2 integers is equal: x == y\\n\"); } return 0; } switch语句一个 switch 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 switch case 进行检查。 流程图 代码示例 #include &lt;stdio.h> int main() { // 定义num变量 int num = 0; printf(\"Input a number: \"); scanf(\"%d\", &amp;num); // 选择分支 switch( num ) { case 1: printf(\"A\\n\"); break; case 2: printf(\"B\\n\"); break; case 3: printf(\"C\\n\"); break; case 4: printf(\"D\\n\"); break; case 5: printf(\"E\\n\"); break; default: printf(\"Invalid Input\\n\"); } return 0; } 循环判断while 循环只要给定的条件为真，C 语言中的 while 循环语句会重复执行一个目标语句。 语法 while(condition) { statement(s); } 流程图 代码示例 #include &lt;stdio.h> int main() { // 定义sum变量 int sum = 0; // 定义i变量 int i = 1; while( i &lt;= 100 ) { sum = sum + i; i = i + 1; } printf(\"sum = %d\\n\", sum); printf(\"i = %d\\n\", i); return 0; } 编程实战 求2-100以内的所有质数 注意：质数只能被1 和 x整除 #include &lt;stdio.h> int main() { // 定义变量i int i = 2; while( i &lt;= 100 ) { // 定义标记 int flag = 0; int j = 2; while( j &lt; i ) { if( i%j == 0 ) { flag = flag + 1; } j = j + 1; } if( flag == 0 ) { printf(\"%d, \", i); } i = i + 1; } printf(\"\\n\"); return 0; } for 循环for 循环的语法： for ( init; condition; increment ) { statement(s); } 流程图 代码示例 #include &lt;stdio.h> int main() { // 初始化两个sum的值 int esum = 0; int osum = 0; int i = 0; for(i=1; i&lt;=100; i=i+2) { osum = osum + i; esum = esum + (i + 1); } printf(\"osum = %d\\n\", osum); printf(\"esum = %d\\n\", esum); return 0; } do…while 循环 在 C 语言中，do…while 循环是在循环的尾部检查它的条件。 do…while 循环与 while 循环类似，但是 do…while 循环会确保至少执行一次循环。 语法 do { statement(s); }while( condition ); 流程图 代码示例 #include &lt;stdio.h> int main () { /* 局部变量定义 */ int a = 10; /* do 循环执行 */ do { printf(\"a 的值： %d\\n\", a); a = a + 1; }while( a &lt; 20 ); return 0; } breakbreak能够强制结束当前结构，阻止程序向下执行。 代码示例 #include &lt;stdio.h> int main() { int sum = 0; int i = 1; while( 1 ) { sum = sum + i; if( i == 100 ) break; i = i + 1; } printf(\"sum = %d\\n\", sum); printf(\"i = %d\\n\", i); return 0; } continue continue立即结束当前循环体，直接进入下一轮条件判断。 continue与break不同，并不会结束整个循环。 代码示例： #include &lt;stdio.h> int main() { int i = 0; int n = 0; for(i=1; i&lt;1000; i=i+1) { if( i % 7 ) continue; printf(\"%d \", i); n = n + 1; } printf(\"\\n\"); printf(\"Count: %d\\n\", n); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}]},{"title":"CPP之覆盖","slug":"c++/CPP之覆盖","date":"2019-12-15T13:23:51.000Z","updated":"2020-05-06T10:41:23.445Z","comments":true,"path":"2019/12/15/c/cpp-zhi-fu-gai/","link":"","permalink":"http://yoursite.com/2019/12/15/c/cpp-zhi-fu-gai/","excerpt":"","text":"覆盖定义 父类和子类中出现同名的成员时，C++采用的一种处理方式，就叫覆盖 数据成员同名类内: 子类覆盖父类，可以用类名作用域区分 类外: 类名作用域区分 代码实现: #include &lt;iostream> using namespace std; class CFather { public: int a; CFather() { a = 12; } }; class CSon : public CFather { public: int a; CSon() { a = 10; } void fun() //名字像同 就覆盖 { cout &lt;&lt; CFather::a &lt;&lt; endl; } }; int main() { CSon so; // 通过类名作用域调用 cout &lt;&lt; so.CFather::a &lt;&lt; endl; return 0; } 父类子类函数名字相同 子类覆盖父类 使用时可以通过类名作用域区分,父类子类的函数。 没有重载关系。 友元函数不能被继承。 代码实现： #include &lt;iostream> using namespace std; class CFather { private: int b; public: int a; CFather() { a = 12; b = 13; } void fun(int a) { cout &lt;&lt; \"Cfather Fun\" &lt;&lt; endl; } friend void show(); }; class CSon : public CFather { private : int c; public: int a; CSon() { a = 10; c = 14; } //名字相同就覆盖，子类就会覆盖父类 void fun() { cout &lt;&lt; \"CSon Fun\" &lt;&lt; endl; } }; void show() { CSon so; cout &lt;&lt; so.c &lt;&lt; endl; } int main() { CSon so; // 使用类名作用域去调用父类 so.CFather::fun(1); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"C语言之数据类型","slug":"C语言/C语言之数据类型","date":"2019-12-15T13:23:51.000Z","updated":"2020-05-12T03:26:29.587Z","comments":true,"path":"2019/12/15/c-yu-yan/c-yu-yan-zhi-shu-ju-lei-xing/","link":"","permalink":"http://yoursite.com/2019/12/15/c-yu-yan/c-yu-yan-zhi-shu-ju-lei-xing/","excerpt":"","text":"数据类型 数据类型的本质就是一个模子。 数据类型代表需要占用的内存的大小。 图示： 变量 变量的本质是内存中一段连续存储空间的别名。 程序中通过变量来申请并且命名存储空间。 通过变量的的名字可以使用存储空间。 初始化变量 软件在运行前需要向操作系统申请存储空间，在内存空间足够空闲时，操作系统将分配一段内存空间并将该外存中软件拷贝一份存入该内存空间中，并启动该软件运行。 在软件运行期间，该软件所占内存空间不再分配给其他软件。 当该软件运行完毕后，操作系统将回收该内存空间（==注意：操作系统并不清空该内存空间遗留下来的数据==），以便再次分配给其他软件使用。综上所述，一个软件所分配到的空间中极可能存在着以前其他软件使用过后的残留数据，这些数据被称之为垃圾数据。所以通常情况下我们为一个变量，为一个数组，分配好存储空间之前都要对该内存空间初始化。 对应进制数 控制符的操作printf()函数的使用# include &lt;stdio.h> int main(void) { //printf(\"哈哈!\\n\"); // \\n表示换行 // int i = 10; // printf(\"%o\\n\", i); //i是整形，应该是%d int j = 3; int k = 5; //printf(\"%d %d\\n\", j, k); //OK //printf(\"%d\\n\", j, k); //error 输出控制符和输出参数的个数不匹配 printf(\"i = %d, j = %d\\n\", j, k); return 0; } printf()对应的格式化字符 %d int %ld long int %c char %f float %lf double %x int 或者long int 或者 short int %o 同上 %s 字符串 Scanf()函数的用法功能：将从键盘输入的字符转化为输入控制符所规定格式的数据，然后存入以输入参数的值为地址的变量中。 语法 scanf(\"输入控制符\"， 输入参数) 代码示例： # include &lt;stdio.h> int main(void) { // 定义变量i ch int i; char ch; scanf(\"%d\", &amp;i);//&amp;i 表示i的地址 &amp;是一个取地址符 printf(\"i = %d\\n\", i); scanf(\"%c\", &amp;ch); printf(\"ch = %c\\n\", ch); return 0; } 强制类型转换 大类型赋值给小类型时，又可能发生溢出。 当数值在小类型范围内，赋值成功。 当数值超过小类型的范围，发生溢出。 小类型可以安全的赋值给大类型。 浮点类型赋值给整形，会发生截断。(小数部分丢失) 整型赋值给浮点类型，能够完成。 代码示例#include &lt;stdio.h> int main() { // 定义变量 int a = 50000; short b = 0; int i = 0; float f = 0.2; printf(\"a = %d\\n\", a); // a=50000 printf(\"b = %d\\n\", b); // b=0 printf(\"\\n\"); b = a; printf(\"a = %d\\n\", a); // a=50000 printf(\"b = %d\\n\", b); // b = -15536 printf(\"\\n\"); b = 30000; a = b; printf(\"a = %d\\n\", a); // a = 30000 printf(\"b = %d\\n\", b); // b = 30000 printf(\"\\n\"); printf(\"\\n\"); printf(\"i = %d\\n\", i); // 0 printf(\"f = %f\\n\", f); // 0.200000 printf(\"\\n\"); f = 3.14f; i = f; printf(\"i = %d\\n\", i); // i=3 printf(\"f = %f\\n\", f); // 3.140000 return 0; } 逻辑运算与位运算逻辑运算 逻辑运算的参与者为逻辑值(真或假)。 任何非零值在逻辑运算中都为真。 任何零值在逻辑运算中都为假。 图示： &amp;&amp;运算 从左向右进行，如果一个操作数为假，则表达式为假。 第一个为假的操作数之后的其他操作数不在计算。 ||运算 从左向右进行，如果有一个操作数为真，则整个表达式为真 第一个为真的操作数之后的其他的操作数不在计算。 取非运算(!) 单目运算(只需要一个操作数)，运算结果为逻辑值。 对真值取非的结果为假。 对假值取非的结果为真。 代码示例 #include &lt;stdio.h> int main() { int a = 1; int b = 2; int c = 0; c = a &amp;&amp; b; printf(\"c = %d\\n\", c); c = !(a - b) || (c &lt; b); printf(\"c = %d\\n\", c); c = 10000; c = !!c; printf(\"c = %d\\n\", c); return 0; } 位运算位运算(&amp;, |, ~, ^, &lt;&lt;, &gt;&gt;) 直接对数据的二进制位进行操作。 位运算的基本单位是二进制，所以也是一种0和1的操作。 可以使用括号()改变位运算的运算顺序。 位运算的操作数只能是整型数。(浮点数不能直接进行位运算) 运算符 含义 示例 优先级 ~ 按位求反 01011010 1 &lt;&lt; 左移：高位移出，低位补零 0011 &lt;&lt; 1 ~ 0110 2 &gt;&gt; 右移：低位移出，高位补符号位 0101 &gt;&gt; 2 ~ 0001 2 &amp; 按位与 0111 &amp; 1100 ~ 0100 3 ^ 按位异或：相同为0,不同为1 0111 ^1100 ~ 1011 4 | 按位或 0111 | 1100 - 1111 5 注意： 按位与和逻辑与的计算法相同:两者为1,结果为1,否则为0. 按位或和逻辑或的计算法相同:两者为0,结果为0，否则为1。 代码示例 #include &lt;stdio.h> int main() { printf(\"c = %d\\n\", 5 | 2); // 7 printf(\"c = %d\\n\", 7 ^ 8); // 15 printf(\"c = %d\\n\", 2 ^ 3); // 1 printf(\"c = %d\\n\", (15 >> 2) &amp; 13); // 1 printf(\"c = %d\\n\", 173 ^ 60); // 145 return 0; } 有符号和无符号数据类型的最高位用于标识数据的符号。 最高位为1，表示这个数为负数。 最高位为0，表示这个数为正数。 有符号数的表示法1.在计算机内部用补码表示有符号数。 正数的补码为正数本身。 负数的补码为负数的绝对值各位取反后加1 无符号数表示法2.在计算机内部用原码表示无符号数 - 无符号数默认为正数。 - 无符号数没有符号位。signed和unsigned C语言中变量默认为有符号的类型。 unsigned关键字声明变量为无符号类型。 C语言中只有整数类型才能够声明unsigned变量 代码示例 #include &lt;stdio.h> int main() { // 定义无符号数变量 unsigned int i = 5; // 定义变量 int j = -10; if( (i + j) > 0 ) { printf(\"i + j > 0\\n\"); } else { printf(\"i + j &lt;= 0\\n\"); } return 0; } 注意 当无符号数与有符号数混合计算时候，会将有符号数转换为无符号数再进行计算，结果为无符号数。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}]},{"title":"CPP之继承","slug":"c++/CPP之继承","date":"2019-12-15T13:23:08.000Z","updated":"2020-05-06T10:41:19.919Z","comments":true,"path":"2019/12/15/c/cpp-zhi-ji-cheng/","link":"","permalink":"http://yoursite.com/2019/12/15/c/cpp-zhi-ji-cheng/","excerpt":"","text":"继承和派生的概念继承：在定义一个新的类B时，如果该类与某个已有的类A相似(指的是B拥有A的全部特点)，那么就可以把A作为一个 基类，而把B作为基类的一个 派生类( ( 也称子类) )。 派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。 派生类一经定义后，可以独立使用，不依赖于基类。 继承的作用: 代码的重用性 继承的格式 class CXiaoming : public CPeople 基类，又叫父类 派生类，又叫子类 可以继承很多层 继承对象的声明 ​ 普通对象 ​ 指针对象 ​ 基类也可以自己创建对象 代码实现 #include &lt;iostream> using namespace std; class CPeople //基类 父类 { public: void Study() { cout &lt;&lt; \"Study\" &lt;&lt; endl; } }; class CChild : public CPeople //派生类 子类 { public: void GoToSchool() { Study(); cout &lt;&lt; \"GoToSchool\" &lt;&lt; endl; } }; class CManWoman : public CPeople { public: void GoToWork() { cout &lt;&lt; \"GoToWork\" &lt;&lt; endl; } }; class COldMan : public CPeople { public: void GoToPark() { cout &lt;&lt; \"GoToPark\" &lt;&lt; endl; } }; int main() { CChild child; child.Study(); CChild* child1 = new CChild; child1->Study(); COldMan oldman; oldman.Study(); CPeople cpo; cpo.Study(); return 0; } 继承的限定词 private 父类中的public，protected成员，在子类中为private，降低访问权限 protected 父类中的public成员，在子类中为protected，降低访问权限 public 父类如何子类如何 代码实现： #include &lt;iostream> using namespace std; class CPeople { private: void fun1() { cout &lt;&lt; \"father privete\" &lt;&lt; endl; } protected: void fun2() { cout &lt;&lt; \"father protected\" &lt;&lt; endl; } public: void fun3() { cout &lt;&lt; \"father public\" &lt;&lt; endl; } }; //public 父类怎么样， 子类就怎么 //protected 继承之后， 父类的public 降级成protected 父类中的 protected private 不变 //private 全变 私有 class Cxiaoming : private CPeople { public: int a; void fun4() { //fun1(); } }; class xiaohua : public Cxiaoming { void fun5() { fun3(); } }; int main() { Cxiaoming xm; // xm.fun3(); // xm.fun2(); // xm.fun1(); CPeople po; po.fun3(); return 0; } 构造函数以无参构造函数的执行顺序 先调用父类的，父类还有父类就继续向上 #include &lt;iostream> using namespace std; class CPeople { public: CPeople() { cout &lt;&lt; \"CPople\" &lt;&lt; endl; } }; class Cxiaoming : public CPeople { public: Cxiaoming() { cout &lt;&lt; \"Cxiaoming\" &lt;&lt; endl; } }; class xiaohua : public Cxiaoming { public: xiaohua() { cout &lt;&lt; \"xiaohua\" &lt;&lt; endl; } }; int main() { Cxiaoming xiaoming; //继承构造的调用顺序，先父 再 子类 //xiaohua xh; cin >> a; cout &lt;&lt; a &lt;&lt; endl; return 0; } 代参构造函数的执行顺序 父类有参数的构造，需要通过子类初始化列表来传递参数。只关注自己父类的多个构造函数选择传递。默认是无参的参数列表写谁，调用谁。 #include &lt;iostream> using namespace std; class CgrandFather { public: CgrandFather(int a, int b) { } CgrandFather(int c) { } }; class CFather : public CgrandFather { public: CFather(int a) : CgrandFather(a) { cout &lt;&lt; \"i am fatherclass\\n\"; } void show() { cout &lt;&lt; \"hello\\n\"; } }; class CSon : public CFather { public: int b; CSon(int a) : CFather(a) { } void show() { cout &lt;&lt; \"hello11\\n\"; } }; int main() { CSon son(3); son.CFather::show(); return 0; } 析构函数 调用顺序：由辈分小的到辈分大的。 #include &lt;iostream> using namespace std; class CgrandFather { public: CgrandFather() { cout &lt;&lt; \"CgrandFather\" &lt;&lt; endl; } ~CgrandFather() { cout &lt;&lt; \"CgrandFather\" &lt;&lt; endl; } }; class CFather : public CgrandFather { public: ~CFather() { cout &lt;&lt; \"CFather\" &lt;&lt; endl; } }; class CSon : public CFather { public: CSon() { cout &lt;&lt; \"CSon\" &lt;&lt; endl; } ~CSon() { cout &lt;&lt; \"CSon\" &lt;&lt; endl; } }; int main() { { CSon so; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"CPP之多态与虚函数","slug":"c++/CPP之多态与虚函数","date":"2019-12-15T13:21:02.000Z","updated":"2020-05-06T10:41:46.164Z","comments":true,"path":"2019/12/15/c/cpp-zhi-duo-tai-yu-xu-han-shu/","link":"","permalink":"http://yoursite.com/2019/12/15/c/cpp-zhi-duo-tai-yu-xu-han-shu/","excerpt":"","text":"多态与虚函数的基本概念 多态是一种泛型编程思想，即同样的代码，实现不同的功能。 父类的指针，调用子类的函数 虚函数是实现这个思想的语法基础 特点： 父类指针指向子类空间，CFather* p = new CSon。但是不能调用子类的函数。 形式 virtual void fun() 。 子类的函数 要和这个函数一样。 多个子类，换子类就调用子类的。 多态针对于指针对象，即父类的一个指针，可以有多种执行状态，即多态。 #include &lt;iostream> using namespace std; class CFather { public: // 重写 virtual void Show() { cout &lt;&lt; \"class CFather\" &lt;&lt; endl; } }; class CSon : public CFather { public: int aa; void Show() { cout &lt;&lt; \"class CSon\" &lt;&lt; endl; } }; class CSon1 : public CFather { public: int aa; void Show() { cout &lt;&lt; \"class CSon1\" &lt;&lt; endl; } }; int main() { // 创建对象 CFather* fa = new CSon1; //普通的只能调用属于父类的成员 fa->Show(); return 0; } 虚函数的特点 父类和子类相同，父类是虚函数。叫做重写 虚函数只是针对于函数成员。 子类重写的函数，默认是虚函数，可以显示加virtual，也可以不加。 名字参数相同。 返回值类型相同，重写。 返回值类型不同(只能是当前所在类)，协变。 虚函数不是内联函数。 构造函数不能是虚函数。 #include &lt;iostream> using namespace std; class CFather { public virtual void fun() { cout &lt;&lt; \"hello\" &lt;&lt; endl; } virtual CFather&amp; Show() { cout &lt;&lt; \"class CFather\" &lt;&lt; endl; return (*this); } }; class CSon : public CFather { public: int aa; //虚函数针对于函数成员 virtual CSon&amp; Show() { cout &lt;&lt; \"class CSon\"&lt;&lt; endl; return (*this); } }; int main() { CFather* fa = new CSon; //普通的只能调用属于父类的成员 fa->Show(); return 0; } 虚表 对象空间的最开始四字节内容，就是虚表（虚函数列表）的地址，叫虚指针。 取虚表地址： 取到的是函数地址，想要调用，要转换成对应类型的函数指针 #include &lt;iostream> using namespace std; class CFather { public: virtual void fun() { cout &lt;&lt; \"fun\" &lt;&lt; endl; } virtual void Show(int a) { cout &lt;&lt; \"class CFather\\n\"; } }; class CSon : public CFather { public: virtual void Show(int a) { cout &lt;&lt; \"class CSon\\n\"; } }; int main() { CFather* fa = new CSon; // 申明函数指针 typedef void (*p)(); typedef void (__stdcall *p1)(int); ((p)(*((int*)*(int*)fa + 0)))(); ((p1)(*((int*)*(int*)fa + 1)))(12); int* pp = (int*)*((int*)*(int*)fa + 2); return 0; } 虚析构 delete哪个类型的指针，就调用谁的析构函数。多态中，如果释放父类指针，只会调用父类的析构函数，所以加了虚析构，就会子类父类都调用了。 #include &lt;iostream> using namespace std; class CFather { public: ~CFather() { cout &lt;&lt; \"CFather\" &lt;&lt; endl; } }; class CSon : public CFather { public: ~CSon() { cout &lt;&lt; \"CSon\" &lt;&lt; endl; } }; class CXiaoMing { public: ~CXiaoMing() { cout &lt;&lt; \"CXiaoMing\" &lt;&lt; endl; } }; int main() { CFather* fa = new CSon; delete (CXiaoMing*)fa; system(\"pause\"); return 0; } 纯虚函数纯虚函数形式: &gt; virtual void fun() = 0；特点 可以没有函数实现 继承这个基类的子类必须实现它，才能定义对象 抽象类 有纯虚函数的就是抽象类. 接口类 全是纯虚函数的，叫接口类. 可以有构造函数，和成员什么的 #include &lt;iostream> using namespace std; class CFather { public: int a; CFather(){}; virtual void fun() = 0; //有纯虚函数的类，必须用子类重写该纯虚函数，才能实例化对象， //有纯虚函数的类 不能够创建对象 virtual void guu() = 0; virtual ~CFather() = 0; }; class CSon : public CFather { public: void fun() { cout &lt;&lt; \"CSOn\" &lt;&lt; endl; } }; int main() { //CSon pf; return 0; } 虚继承 虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。 父类叫做虚基类。 解决多继承中访问不明确的问题。 不建议用，结构复杂，内存开销比较大。 代码实现： #include &lt;iostream> using namespace std; class CA { public: int a; }; class CB : virtual public CA { public: }; class CC : virtual pubc CA { public: }; class CD : public CB, public CC { public: }; int main() { CD d; d.a; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"C语言变量属性","slug":"C语言/C语言之变量属性","date":"2019-05-12T03:06:02.000Z","updated":"2020-05-12T03:21:59.640Z","comments":true,"path":"2019/05/12/c-yu-yan/c-yu-yan-zhi-bian-liang-shu-xing/","link":"","permalink":"http://yoursite.com/2019/05/12/c-yu-yan/c-yu-yan-zhi-bian-liang-shu-xing/","excerpt":"","text":"变量属性C语言中的变量可以有自己的属性，在定义变量的时候可以加上“属性“关键字。 属性关键字指明变量的特殊意义。 auto关键字 auto是C语言中局部变量的默认属性。 auto表明将被修饰的变量存储于栈上。 编译器默认所有的局部变量都是auto的。 代码示例 void f() { int i; // 局部变量默认属性为auto auto int j; // 显示声明auto属性 } register关键字 register关键字指明将局部变量存储于寄存器中。 register只是请求寄存器变量，但是不一定请求成功。 register变量必须是CPU寄存器可以接受的值。 不能用&amp;运算符获取register变量的地址。 代码示例 #include &lt;stdio.h> register int g_v; // error int main() { register char var; print(\"8x%88x\", &amp;var) // error return 0； } static关键字1、static关键字指明变量的静态属性。 static修饰的局部变量存储在程序静态区。 2、static关键字同时具有作用域限定符的意义。 static修饰的全局变量作用域只是声明的文件中。 static修饰的函数作用域只是声明的文件中。 代码示例 #include &lt;stdio.h> int g_v; // 全局变量，程序的任意地方均能访问 static int g_vs; // 静态全局变量，只有当前文件中可以访问。 int main() { int var; // 局部变量，在栈上分配空间。 static int var; // 静态局部变量，在静态数据区分配空间。 return 0; } 实例分析#include &lt;stdio.h> // 定义f1函数 int f1() { int r = 0; r++; return r; } // 定义f2函数 int f2() { static int r = 0; r++; return r; } int main() { auto int i = 0; // 显示声明 auto 属性，i 为栈变量 static int k = 0; // 局部变量 k 的存储区位于静态区，作用域位于 main 中 register int j = 0; // 向编译器申请将 j 存储于寄存器中 printf(\"%p\\n\", &amp;i); printf(\"%p\\n\", &amp;k); printf(\"%p\\n\", &amp;j); // error for(i=0; i&lt;5; i++) { printf(\"%d\\n\", f1()); } for(i=0; i&lt;5; i++) { printf(\"%d\\n\", f2()); } return 0; } 图示： extern关键字extern用于声明“外部”定义的变量和函数。 extern变量在文件的其他地方分配空间。 extern函数在文件的其他地方定义。 代码示例 #include &lt;stdio.h> extern int getI(); int main() { printf(\"%d\\n\", getI()); return 0; } static int g_i; int getI() { return g_i; } const关键字const只读变量 const修饰变量是只读的，本质上还是变量。 const修饰的局部变量在栈上分配空间。 const修饰的全局变量在全局数据区分配空间。 const只是在编译期有用,在运行其无效果。 注意： const修饰的变量不是真正的常量，他只是告诉编译器该变量不能出现在赋值符号的左边。 const全局变量的分歧1、在现代C语言编译器中，修改const全局变量将导致程序崩溃。 2、标准C语言编译器不会将const修饰的全局变量存储于只读存储区中，而是存储于可修改的全局数据区，其值依然可以改变。 代码示例 #include &lt;stdio.h> // 定义全局变量 const int g_cc = 2; int main() { const int cc = 1; printf(\"cc = %d\\n\", cc); // 通过指针修改内存空间的地址 int* p = (int*)&amp;cc; *p = 3; printf(\"cc = %d\\n\", cc); p = (int*)&amp;g_cc; printf(\"g_cc = %d\\n\", g_cc); // 修改内存空间 *p = 4; printf(\"g_cc = %d\\n\", g_cc); return 0; } const的本质 C语言中的const使得变量具有只读属性。 现代C编译器中的const将具有全局生命周期的变量存储于只读存储区。 const不能定义真正意义上的常量。 代码示例 #include &lt;stdio.h> // 定义一个const类型的全局数组 const int g_array[5] = {0}; // 定义modify函数 void modify(int* p, int v) { *p = v; } int main() { int const i = 0; const static int j = 0; int const array[5] = {0}; modify((int*)&amp;i, 1); // ok modify((int*)&amp;j, 2); // error modify((int*)&amp;array[0], 3); // ok modify((int*)&amp;g_array[0], 4); // error printf(\"i = %d\\n\", i); printf(\"j = %d\\n\", j); printf(\"array[0] = %d\\n\", array[0]); printf(\"g_array[0] = %d\\n\", g_array[0]); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"}]},{"title":"CSS基础","slug":"CSS/CSS基础","date":"2018-12-23T13:59:49.000Z","updated":"2019-12-24T03:20:32.802Z","comments":true,"path":"2018/12/23/css/css-ji-chu/","link":"","permalink":"http://yoursite.com/2018/12/23/css/css-ji-chu/","excerpt":"","text":"CSS样式规则css规则由两部分构成: 选择器 声明 图片说明 CSS引用写在head标签内： &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css样式&lt;/title> &lt;style type=\"text/css\"> CSS样式… &lt;/style> &lt;/head> CSS注释CSS注释：/*注释语句*/ CSS样式行内样式（内联样式） 在开始标签内添加style样式属性 &lt;h1 style=\"color:red;font-size:20px;\">css使用方法&lt;/h1> 内部样式表（嵌入样式） 内部样式（嵌入样式），把css样式代码写在: &lt;style type=\"text/css\"> 样式… &lt;/style> 说明：&lt;style>要放在&lt;head>标签之间 代码实现： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css使用方法&lt;/title> &lt;style type=\"text/css\"> p{color:blue;} h2{color:red;} &lt;/style> &lt;/head> &lt;body> &lt;!-- 行内样式 --> &lt;h1 style=\"color:red;font-size:20px;\">css使用方法&lt;/h1> &lt;!--嵌入样式--> &lt;h2>css使用方法&lt;/h2> &lt;p>行内样式&lt;/p> &lt;p>嵌入样式&lt;/p> &lt;p>外部样式&lt;/p> &lt;p>导入样式&lt;/p> &lt;/body> &lt;/html> 外部样式表（Link链入） 外部样式表，把CSS样式代码写在独立的一个文件中 扩展名： CSS文件名.CSS 引入外部文件：&lt;link href=“XX.css” rel=”stylesheet” type=”text/css” /&gt; 说明：link要放在head标签之间 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css使用方法&lt;/title> &lt;link href=\"css.css\" rel=\"stylesheet\" type=\"text/css\"/> &lt;/head> &lt;body> &lt;!-- 行内样式 --> &lt;h1 style=\"color:red;font-size:20px;\">css使用方法&lt;/h1> &lt;h2>css使用方法&lt;/h2> &lt;p>行内样式&lt;/p> &lt;p>嵌入样式&lt;/p> &lt;p>外部样式&lt;/p> &lt;p>导入样式&lt;/p> &lt;/body> &lt;/html> 外部文件 p{color:blue; font-size: 30px;} h2{color:red;} 导入式 @import “外部CSS样式” 说明：@import写在style标签内最开始 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css使用方法&lt;/title> &lt;style type=\"text/css\"> &lt;!-- 导入式 --> @import url(css.css); &lt;/style> &lt;/head> &lt;body> &lt;!-- 行内样式 --> &lt;h1 style=\"color:red;font-size:20px;\">css使用方法&lt;/h1> &lt;h2>css使用方法&lt;/h2> &lt;p>行内样式&lt;/p> &lt;p>嵌入样式&lt;/p> &lt;p>外部样式&lt;/p> &lt;p>导入样式&lt;/p> &lt;/body> &lt;/html> 外部文件 p{color:blue; font-size: 30px;} h2{color:red;} CSS使用方法区别 类别 引入方法 位置 加载 行内样式 开始标签内style html文件内 同时加载 内部样式 head中style内 html文件内 同时加载 外部样式 head中link内 CSS样式文件与html文件分离 页面加载时，同时加载CSS样式 导入式(@import) 在样式代码最开始处 CSS样式文件与html文件分离 在读取完html文件之后加载 使用外部样式的好处 CSS与Html分离 多个文件可以使用同一个样式文件 多文件引用同一个css文件，CSS只是需要下载一次。 CSS选择器1-标签选择器以HTML标签作为选择器 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css选择器&lt;/title> &lt;style type=\"text/css\"> /*标签选择器*/ p{ color: red; } &lt;/style> &lt;/head> &lt;body> &lt;p>&lt;em>CSS&lt;/em>层叠样式&lt;/p> &lt;p>&lt;em>CSS&lt;/em>样式由选择器和声明组成&lt;/p> &lt;/body> &lt;/html> 2-类选择器 为HTML标签添加class属性 h1 class=\"red\">内容1&lt;/h1> &lt;p>内容2&lt;/p> &lt;p class=\"red\">内容3&lt;/p> 通过类选择器来为具有此class属性的元素设置CSS样式 .red{color:red;} 通过对不同元素的同一名称的类选择器设置不同的样式规则 p.red{font-size:50px;} h1.red{font-size:20px;} 同一个元素可以设置多个类，之间有空格隔开 &lt;h1 class=\"red\">内容1&lt;/h1> &lt;p class=\"red fsize\">内容2&lt;/p> &lt;p class=\"red\">内容3&lt;/p> 代码实现 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css选择器&lt;/title> &lt;style type=\"text/css\"> /*标签选择器*/ p{ color: red; } /*类选择器*/ .special{ color: blue; } p.special{ font-size: 50px; } .one{ text-decoration: underline; } &lt;/style> &lt;/head> &lt;body> &lt;h1 class=\"special\">CSS是什么&lt;/h1> &lt;p>&lt;em>CSS&lt;/em>层叠样式&lt;/p> &lt;p class=\"special one\">用于定义HTML内容在浏览器中的显示样式&lt;/p> &lt;p>&lt;em>CSS&lt;/em>样式由选择器和声明组成&lt;/p> &lt;div> &lt;h1>css&lt;/em>使用方法&lt;/h1> &lt;ul> &lt;li>行内样式&lt;/li> &lt;li>内部样式&lt;/li> &lt;li>外部样式&lt;/li> &lt;li>导入式&lt;/li> &lt;/ul> &lt;h1>&lt;em>css&lt;/em>选择器&lt;/h1> &lt;ul> &lt;li>标签选择器&lt;/li> &lt;li>ID选择器&lt;/li> &lt;li>类选择器&lt;/li> &lt;li>后代选择器&lt;/li> &lt;/ul> &lt;/div> &lt;/body> &lt;/html> 3-ID选择器 为HTML标签添加ID属性 &lt;h1>内容1&lt;/h1> &lt;p id=\"p1\">内容2&lt;/p> &lt;p id=\"p2\">内容3&lt;/p> 通过ID选择器来为具有此ID的元素设置CSS规则 #p1{color:red;} #p2{color:blue;} 代码实现 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css选择器&lt;/title> &lt;style type=\"text/css\"> /*ID选择器*/ #two{ color: green; } &lt;/style> &lt;/head> &lt;body> &lt;div> &lt;h1 id=\"two\">css&lt;/em>使用方法&lt;/h1> &lt;/div> &lt;/body> &lt;/html> 4-全局选择器 所有标签设置样式 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css选择器&lt;/title> &lt;style type=\"text/css\"> /*全局选择器*/ *{font-size:50px; color:blue;} &lt;/style> &lt;/head> &lt;body> &lt;h1 class=\"special\">&lt;em>CSS&lt;/em>是什么&lt;/h1> &lt;p>&lt;em>CSS&lt;/em>层叠样式&lt;/p> &lt;p class=\"special one\">用于定义HTML内容在浏览器中的显示样式&lt;/p> &lt;p>&lt;em>CSS&lt;/em>样式由选择器和声明组成&lt;/p> &lt;/body> &lt;/html> 5-群组选择器 集体统一设置样式 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css选择器&lt;/title> &lt;style type=\"text/css\"> /*群组选择器*/ p.special,#three,h1{font-size:50px;} p{color:red;} .special{color:blue;} .one{text-decoration: underline;} #two{color:green;} &lt;/style> &lt;/head> &lt;body> &lt;h1 class=\"special\">&lt;em>CSS&lt;/em>是什么&lt;/h1> &lt;p>&lt;em>CSS&lt;/em>层叠样式&lt;/p> &lt;p class=\"special one\">用于定义HTML内容在浏览器中的显示样式&lt;/p> &lt;p>&lt;em>CSS&lt;/em>样式由选择器和声明组成&lt;/p> &lt;div> &lt;h1 id=\"two\">&lt;em class=\"classred\">css&lt;/em>使用方法&lt;/h1> &lt;ul id=\"three\"> &lt;li>行内样式&lt;/li> &lt;li>内部样式&lt;/li> &lt;li>外部样式&lt;/li> &lt;li>导入式&lt;/li> &lt;/ul> &lt;h1>&lt;em>css&lt;/em>选择器&lt;/h1> &lt;ul> &lt;li>标签选择器&lt;/li> &lt;li>ID选择器&lt;/li> &lt;li>类选择器&lt;/li> &lt;li>后代选择器&lt;/li> &lt;/ul> &lt;/div> &lt;/body> &lt;/html> 6-后代选择器 使用后代选择器设置，之间用空格隔开 p em{font-size:40px} /*p标签中a标签中的em*/ p a em{.....} /*id为p1的标签中的em*/ #p1 em{....} /*class为red的p标签中的a标签中的em*/ p.red a em{.....} 代码实现： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css选择器&lt;/title> &lt;style type=\"text/css\"> &lt;!--后代选择器--> .classred{color:red;} p em{color:blue;} h1.special em{color:orange;} em{color:red;} &lt;/style> &lt;/head> &lt;body> &lt;h1 class=\"special\">&lt;em>CSS&lt;/em>是什么&lt;/h1> &lt;p>&lt;em>CSS&lt;/em>层叠样式&lt;/p> &lt;p class=\"special\">用于定义HTML内容在浏览器中的显示样式&lt;/p> &lt;p>&lt;em>CSS&lt;/em>样式由选择器和声明组成&lt;/p> &lt;div> &lt;h1>&lt;em class=\"classred\">css&lt;/em>使用方法&lt;/h1> &lt;ul> &lt;li>行内样式&lt;/li> &lt;li>内部样式&lt;/li> &lt;li>外部样式&lt;/li> &lt;li>导入式&lt;/li> &lt;/ul> &lt;h1>&lt;em>css&lt;/em>选择器&lt;/h1> &lt;ul> &lt;li>标签选择器&lt;/li> &lt;li>ID选择器&lt;/li> &lt;li>类选择器&lt;/li> &lt;li>后代选择器&lt;/li> &lt;/ul> &lt;/div> &lt;/body> &lt;/html> 伪类选择器链接的4中状态 激活状态，已访问状态，未访问状态，和鼠标悬停状态。 伪类 说明 :link 未访问的链接 :visited 已访问的链接 :hover 鼠标悬停状态 :active 激活的链接 伪类:hover和:active :hover用于访问的鼠标经过某个元素时 :active用于一个元素被激活时（即按下鼠标之后放开鼠标之前的时间） 链接伪类的顺序 ：Link &gt; :Visited &gt; :Hover &gt; :Active 注意： a:hover 必须置于 a:link 和 a:visited 之后，才有效。 a:active 必须置于 a:hover 之后，才有效。 伪类名称对大小写不敏感。 代码实现&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>css选择器&lt;/title> &lt;style type=\"text/css\"> p a:link{color:blue;} p a:visited{color:green;} p a:hover{color:red;} p a:active{color:gray;} div a:link{color:green;} div a:visited{color:blue;} div a:hover{color:gray;} div a:active{color:red;} &lt;/style> &lt;/head> &lt;body> &lt;p>&lt;a href=\"http://www.baidu.com\" target=\"_blank\">css使用方法&lt;/a>&lt;/p> &lt;br/> &lt;div>&lt;a href=\"http://www.zhihu.com\" target=\"_blank\">css选择器&lt;/a>&lt;/div> &lt;p>度娘&lt;/p> &lt;/body> &lt;/html> CSS继承和层叠 从父元素那继承部分CSS属性。 继承的好处 父元素设置样式，子元素可以继承部分属性。 减少CSS代码 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>CSS继承和层叠&lt;/title> &lt;style type=\"text/css\"> p{color:red;} &lt;/style> &lt;/head> &lt;body> &lt;div> &lt;p>CSS&lt;span>继承&lt;/span>&lt;/p> &lt;div>CSS层叠&lt;/div> &lt;/div> &lt;p>CSS继承和层叠&lt;/p> &lt;h1>CSS继承和层叠&lt;/h1> &lt;/body> &lt;/html> CSS层叠 可以定义多个样式 不冲突时，多个样式可层叠为一个 冲突时，按不同样式规则优先级来应用样式 代码实现： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>CSS继承和层叠&lt;/title> &lt;style type=\"text/css\"> h1{color:red;} h1{color: blue} &lt;/style> &lt;/head> &lt;body> &lt;h1>CSS继承和层叠&lt;/h1> &lt;/body> &lt;/html> CSS优先级总结!important声明高 可调整样式规则的优先级 添加在样式规则之后，中间用空格隔开 div{color:red !important} CSS使用方法的优先级行内样式&gt;内部样式&gt;外部样式注意: 链入外部样式表与内部样式表之间的优先级取决于所处位置的先后 最后定义的优先级最高（就近原则）。 样式表中优先级选择器权值 标签选择器：权值为1 类选择器和伪类：权值为10 ID选择器：权值为100 通配符选择器：权值为0 行内样式：权值为1000 同一样式表中权值相同： 就近原则（离被设置元素越近优先级越高)。 权值不同： 根据权值来判断CSS样式，哪种CSS样式权值高，就使用哪种样式。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}]},{"title":"CSS定位","slug":"CSS/CSS定位","date":"2018-12-23T13:48:50.000Z","updated":"2019-12-23T13:54:10.706Z","comments":true,"path":"2018/12/23/css/css-ding-wei/","link":"","permalink":"http://yoursite.com/2018/12/23/css/css-ding-wei/","excerpt":"","text":"定位模型position之static 静态定位 /常规定位/自然定位 ——定位中的一股清流-回归本真 特点 作用 使元素定位与 常规/自然流中（块、行垂直排列下去、行内水平从左到右） 特点 (1)忽略top,bottom,left,right或者z-index声明(2)两个相邻的元素如果都设置了外边距，那么最终外边距=两者外边距中最大的(3)具有固定width和height值的元素，如果把左右外边距设置为auto，则左右外边距会自动扩大占满剩余宽度。造成的效果就是这个块水平居中。 代码实现/*简单reset.css*/ html, body { background: #f5f5f5; } html, body, div,p,img { margin: 0; padding: 0; box-sizing: border-box; } .flex-container { background: purple; /*padding:10px;*/ } .flex-item { color:purple; text-align: center; } .red { background: red; } .blue { background: lightblue; } .orange { background: darkorange; } .green { background: darkslategray; } &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>change-to-flex&lt;/title> &lt;link rel=\"stylesheet\" href=\"./reset.css\"> &lt;style> .block { position: static; top: 10px; width: 50px; height: 50px; line-height: 50px; text-align: center; border: 2px solid blue; box-sizing: border-box; } .block:nth-child(1) { border: 2px solid green; margin-left: auto; margin-right: auto; /*margin: 30px;*/ } .block:nth-child(2) { /*position: static;*/ /*border-color: red;*/ /*margin: 20px;*/ border: 2px solid red; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"block\"> A &lt;/div> &lt;div class=\"block\"> B &lt;/div> &lt;div class=\"block\"> C &lt;/div> &lt;div class=\"block\"> D &lt;/div> &lt;/body> &lt;/html> position之relative 相对定位 特点 作用 使元素称为containing-block-官话是可定位的祖先元素 特点 (1)可以使用top/right/bottom/left/z-index进行相对定位——？相对的是谁(2)相对定位的元素不会离开常规流——心念家乡(3)任何元素都可以设置为relative，它的绝对定位的后代都可以相对于它进行绝对定位——超好用(4)可以使用浮动元素发生偏移，并控制它们的堆叠顺序。 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>position-relative&lt;/title> &lt;link rel=\"stylesheet\" href=\"./reset.css\"> &lt;style> .block { position: relative; top: 0; left: 0; width: 80px; height: 80px; line-height: 80px; border: 2px solid black; text-align: center; float: left; z-index: 9; } .block:nth-child(2) { position: relative; top: 0; left: -80px; border-color: red; z-index: 1; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"block\">A&lt;/div> &lt;div class=\"block\">B&lt;/div> &lt;/body> &lt;/html> position之absolute 绝对定位 特点 作用 使元素脱离常规流 特点 (1)脱离常规流(2)lrtb如果为0 它将对齐到最近定位祖先元素的各边——衍生出(3)lrtb如果设置为auto 它将被打回原形。(4)如果没有最近定位祖先元素 会认做父元素（通俗的说）如果元素没有已定位（除static 定位以外）的祖先元素，那么它的位置相对于最初的包含块。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}]},{"title":"float浮动","slug":"CSS/float浮动","date":"2018-12-23T13:48:24.000Z","updated":"2019-12-23T13:54:31.256Z","comments":true,"path":"2018/12/23/css/float-fu-dong/","link":"","permalink":"http://yoursite.com/2018/12/23/css/float-fu-dong/","excerpt":"","text":"css定位机制普通流(标准流) 块元素：元素从上往下的排列 行内元素:元素自动从左往右排列。 块元素 独占一行 可以设置宽、高 如果不设置宽度，宽度默认为容器的100% 主要有div、p、h1~h6、ul、ol、li、dl、dt、dd 行内元素 与其它元素同行显示 不可以设置宽、高 宽高就是文字或图片的宽高 主要有span、a、b、i、u、em…… 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>block、inline&lt;/title> &lt;style type=\"text/css\"> div{ width:300px; height:200px; background:blue; } span{ width:300px; height:200px; background:red; } &lt;/style> &lt;/head> &lt;body> &lt;div>这个是块级元素1&lt;/div> &lt;div>这个是块级元素2&lt;/div> &lt;span>这个是行内元素1&lt;/span> &lt;span>这个是行内元素2&lt;/span> &lt;/body> &lt;/html> Float（浮动） 会使元素向左或向右移动，只能左右，不能上下。 浮动元素碰到包含框或另一个浮动框，浮动停止。 浮动元素之后的元素将围绕它，之前的不受影响。 浮动元素会脱离标准流。 浮动的基本语法 float:left 靠左浮动 float:right 靠右浮动 float:none 不使用浮动 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>text_around&lt;/title> &lt;style type=\"text/css\"> .container{ width:800px; height:600px; border:2px solid #333; } .container img{ float:left; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"container\"> &lt;img src=\"./img/1.jpg\"> &lt;p>前言 目前Mock技术已经比较成熟，在日常的工作中Mock也可以给我们带来很大的遍历，本篇文章将会使用 Moco框架，一步一步搭建一套Mock Server，使得接口的自动化测试更加的提前，也能够使得前后端分离。 共识与痛点 目前，在软件行业内，大家已经达成的共识就是，测试的工作应该从需求阶段就开始，但在实际 工作落地的时候，我们也仅仅能够根据需求写一些测试用例。 &lt;/p> &lt;/div> &lt;/body> &lt;/html> 使用浮动后产生的问题 元素使用浮动后会脱离普通流，出现“高度塌陷” 浮动溢出 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>float&lt;/title> &lt;style type=\"text/css\"> .container{ width:500px; height:500px; border:2px solid #333; float: left; } .box01{ width:100px; height:100px; background:blue; color:#fff; float: left; } .box02{ width:100px; height:100px; background:red; color:#fff; float: left; } .box03{ width:100px; height:100px; background:orange; color:#fff; float: left; } .box04{ width:500px; height:200px; background:green; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"container\"> &lt;div class=\"box01\">11111&lt;/div> &lt;div class=\"box02\">22222&lt;/div> &lt;div class=\"box03\">33333&lt;/div> &lt;/div> &lt;div class=\"box04\">44444&lt;/div> &lt;/body> &lt;/html> 清除浮动语法：clear : none | left | right | both; 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>float清除浮动语法&lt;/title> &lt;style type=\"text/css\"> .container{ width:500px; height:500px; border:2px solid #333; float: left; clear: both; } .box01{ width:100px; height:100px; background:blue; color:#fff; float: left; clear: both; } .box02{ width:100px; height:100px; background:red; color:#fff; float: left; clear: both; } .box03{ width:100px; height:100px; background:orange; color:#fff; float: left; clear: both; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"container\"> &lt;div class=\"box01\">11111&lt;/div> &lt;div class=\"box02\">22222&lt;/div> &lt;div class=\"box03\">33333&lt;/div> &lt;/div> &lt;/body> &lt;/html> 清除浮动常用方法方法一：在浮动元素后使用一个空元素。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>float清除浮动方法一&lt;/title> &lt;style type=\"text/css\"> .container{ width:500px; height:500px; border:2px solid #333; float: left; clear: both; } .box01{ width:100px; height:100px; background:blue; color:#fff; float: left; clear: both; } .box02{ width:100px; height:100px; background:red; color:#fff; float: left; clear: both; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"container\"> &lt;div class=\"box01\">11111&lt;/div> &lt;div class=\"box02\">22222&lt;/div> &lt;div class=\"clear\">&lt;/div> &lt;/body> &lt;/html> 方法二：给浮动元素的容器添加 overflow:hidden; &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>float&lt;/title> &lt;style type=\"text/css\"> .container{ width:500px; border:2px solid #333; overflow: hidden; } .box01{ width:100px; height:100px; background:blue; color:#fff; float: left; } .box02{ width:100px; height:100px; background:red; color:#fff; float: left; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"container\"> &lt;div class=\"box01\">11111&lt;/div> &lt;div class=\"box02\">22222&lt;/div> &lt;/div> &lt;/body> &lt;/html> 方案三:&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>float&lt;/title> &lt;style type=\"text/css\"> .container{ width:500px; border:2px solid #333; } .clearfix:after{ content:\".\"; display: block; height:0; visibility: hidden; clear:both; } .clearfix{ zoom: 1; } .box01{ width:100px; height:100px; background:blue; color:#fff; float: left; } .box02{ width:100px; height:100px; background:red; color:#fff; float: left; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"container clearfix\"> &lt;div class=\"box01\">11111&lt;/div> &lt;div class=\"box02\">22222&lt;/div> &lt;/div> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}]},{"title":"CSS背景和列表","slug":"CSS/CSS背景和列表","date":"2018-12-23T13:48:00.000Z","updated":"2019-12-23T13:53:58.421Z","comments":true,"path":"2018/12/23/css/css-bei-jing-he-lie-biao/","link":"","permalink":"http://yoursite.com/2018/12/23/css/css-bei-jing-he-lie-biao/","excerpt":"","text":"背景背景颜色(background-color) 设置元素的背景的颜色，background-color: 颜色｜ transparent 注意 transparent是全透明黑色(black)的速记法，类似rgba(0,0,0,0)这样的值。 颜色值（颜色名｜RGB｜十六进制｜)。 背景区包括内容、内边距（padding）和边框、不包含外边距（margin）。 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> div{ width: 300px; height: 300px; background-color: rgb(255,0,0); /*padding: 10px;*/ /*margin: 10px;*/ border: 20px dashed; } &lt;/style> &lt;/head> &lt;body> &lt;div>background-color&lt;/div> &lt;/body> &lt;/html> 背景图片(background-image)设置元素的背景图片 background-image : URL｜ none 注意： url地址可以是相对地址也可以是绝对地址 元素的背景占据了元素的全部尺寸，包括内边距和边框，但不包括外边距。 默认地，背景图像位于元素的左上角，并在水平和垂直方向上重复。 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> div{ width: 300px; height: 300px; background-color: #ff0000; background-image: url(img/bg-little.png); /*padding: 20px;*/ /*margin: 20px;*/ /*border: 20px dashed; */ } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;/body> &lt;/html> 背景图片重复background-repeat repeat ：默认值，背景图片水平方向和垂直方向重复。 repeat-x：背景图片水平方向重复。 repeat-y : 背景图片垂直方向重复。 no-repeat : 背景图片不重复。 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> div{ width: 300px; height: 300px; background-image: url(img/bg-little.png); background-repeat: no-repeat; /*background-repeat:repeat;*/ /*background-repeat:repeat-x;*/ /*background-repeat:repeat-y;*/ border: 1px solid #ff0000; } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;/body> &lt;/html> 图片显示方式设置元素的背景图片的显示方式 background-attachment: scroll ｜fixed 注意： scroll ：默认值，背景图片随滚动条滚动 fixed ：当页面的其余部分滚动时，背景图片不会移动 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> div{ width: 300px; height: 1500px; background-image: url(img/bg-little.png); background-repeat: no-repeat; border: 1px solid #ff0000; /*background-attachment: fixed;*/ background-attachment: scroll; } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;/body> &lt;/html> 图片定位设置元素的背景图片的起始位置 background-position : 百分比 ｜值 top ｜right ｜ bottom ｜ left ｜ center 值 说明 注意 长度值（x y） 第一个值水平位置，第二个值垂直位置左上角0 0 只写一个参数的话，第二个默认为居中 百分比（x% y%） 第一个值水平位置的百分比，第二个值垂直位置的百分比左上角0% 0%，有下角100% 100%，如果仅规定了一个值，另一个值将是 50%。 只写一个参数的话，第二个默认为居中 top 顶部显示，相当于垂直方向0 只写一个参数的话，第二个默认为居中 right 右边显示，相当于水平方向100% 只写一个参数的话，第二个默认为居中 left 左边显示，相当于水平方向0 只写一个参数的话，第二个默认为居中 bottom 底部显示，相当于垂直方向100% 只写一个参数的话，第二个默认为居中 center 居中显示，相当于水平方向50%垂直方向50% 水平、垂直方向都居中 背景图片定位 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> div{ width: 300px; height: 1500px; background-image: url(img/bg-little.png); background-repeat: no-repeat; border: 1px solid #ff0000; background-position: bottom left; } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;/body> &lt;/html> 背景缩写background：- [background-color] - [background-image] - [background-repeat] - [background-attachment] - [background-position] [] 注意 各值之间用空格分割 ，不分先后顺序。 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> div{ width: 100%; height: 1500px; border: 1px solid #ff0000; background: #000000 url(img/bg-little.png) no-repeat right fixed; } &lt;/style> &lt;/head> &lt;body> &lt;div>&lt;/div> &lt;/body> &lt;/html> 列表列表项标记样式设置列表项的标记样式类型 list-style-type : 关键字 ｜none 无序列表 值 说明 none 无标记 disc 实心的圆点 circle 空心的圆点 square 实心的方法 有序列表 值 说明 none 无标记 decimal 从1开始的整数 lower-roman 小写罗马数字 upper-roman 大写罗马数字 lower-alpha 小写英文字母 upper-alpha 大写英文字母 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> ul li { /*无序列表*/ /*list-style-type: circle;*/ /*list-style-type: square;*/ /*有序列表*/ /*list-style-type: decimal;*/ /*list-style-type: upper-roman;*/ list-style-type: upper-alpha; } &lt;/style> &lt;/head> &lt;body> &lt;ul> &lt;li>家用电器&lt;/li> &lt;li>电脑&lt;/li> &lt;li>手机&lt;/li> &lt;/ul> &lt;/body> &lt;/html> 图片列表项的标记 list-style-image : URL ｜none 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> ul li { list-style-image: url(img/remind.png); } &lt;/style> &lt;/head> &lt;body> &lt;ul> &lt;li>家用电器&lt;/li> &lt;li>电脑&lt;/li> &lt;li>手机&lt;/li> &lt;/ul> &lt;/body> &lt;/html> 列表项标记的位置设置列表项标记的位置list-style-position : inside ｜outside inside :列表项目标记放置在文本以内，且环绕文本根据标记对齐 outside :默认值，列表项目标记放置在文本以外，且环绕文本不根据标记对齐 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> ul li { list-style-image: url(img/remind.png); list-style-position: inside; } &lt;/style> &lt;/head> &lt;body> &lt;ul> &lt;li>家用电器家用电器家用电器家用电器家用电器家用电器 家用电器家用电器家用电器家用电器家用电器家用电器 &lt;/li> &lt;li>电脑&lt;/li> &lt;li>手机&lt;/li> &lt;/ul> &lt;/body> &lt;/html> 列表样式缩写list-style : list-style-type list-style-position list-style-image 注意: 值之间用空格分隔割 顺序不固定 list-style-image 会覆盖 list-style-type的设置 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;style> ul li { list-style: url(img/remind.png) inside square ; } &lt;/style> &lt;/head> &lt;body> &lt;ul> &lt;li>家用电器家用电器家用电器家用电器家用电器 家用电器家用电器家用电器家用电器家用电器家用电器家&lt;/li> &lt;li>电脑&lt;/li> &lt;li>手机&lt;/li> &lt;/ul> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}]},{"title":"盒子模型","slug":"CSS/盒子模型","date":"2018-12-23T13:47:28.000Z","updated":"2019-12-23T13:51:44.395Z","comments":true,"path":"2018/12/23/css/he-zi-mo-xing/","link":"","permalink":"http://yoursite.com/2018/12/23/css/he-zi-mo-xing/","excerpt":"","text":"盒子模型概述任何一个网页元素包含由这些属性组成：内容(content)、内边距(padding)、边框(border)、外边距(margin)， 这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模型。 内容（content）就是盒子里装的东西 内边距(padding)就是怕盒子里装的东西（贵重的）损坏而添加的泡沫或者其它抗震的辅料； 边框(border)就是盒子本身了； 外边界(margin)则说明盒子摆放的时候的不能全部堆在一起，要留一定空隙保持通风，同时也为了方便取出。 盒子模型的属性两种盒子模型： 标准盒子模型content-box：宽和高会被内边距，边框撑大。设置的是内容的宽和高 怪异盒子模型border-box：设置了固定的宽和高，设置内边距和边框，网页元素会被挤压。 如何计算盒子的尺寸 在盒子模型中，最重要的还是如何理解元素的实际尺寸。 盒子模型分为两种，分别是：标准盒模型 和 怪异盒模型。绝大多数元素的尺寸默认是按照标准盒模型计算的 标准盒子模型 怪异盒子模型 计算方式标准盒子： 实际宽度=内容宽度+内边距+边框宽度 实际高度=内容高度+内边距+边框高度 怪异盒子： 实际宽度=宽度 实际高度=高度 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>盒子模型&lt;/title> &lt;style> .test1 { width: 200px; height: 200px; /*粗细 线型 颜色*/ border: 15px solid #eee; padding: 10px; /*标准盒子模型，以内容为准，默认*/ box-sizing: content-box; } .test2 { width: 200px; height: 200px; /*粗细 线型 颜色*/ border: 15px solid #eee; padding: 10px; /*怪异盒子，以边框为准 */ box-sizing:border-box; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"test1\"> &lt;/div> &lt;br/> &lt;div class=\"test2\"> &lt;/div> &lt;/body> &lt;/html> 宽度属性宽度 width：长度值 | 百分比 | auto 最大宽度 max-width：长度值 | 百分比 | auto 最小宽度 min-width：长度值 | 百分比 | auto 高度属性高度 height：长度值 | 百分比 | auto 最大高度 max- height ：长度值 | 百分比 | auto 最小高度 min- height ：长度值 | 百分比 | auto 可设置高和宽属性 块级元素 &lt;p>、&lt;div> 、 &lt;h1> ~ &lt;h6> 、&lt;ul> 、&lt;li> 、&lt;ol> &lt;dl> 、&lt;dt> 、&lt;dd>等 替换元素 &lt;img>、&lt;input>、&lt;textarea>等 标签分类 块级标签：占据一行，换行。 &lt;div>、&lt;ul>、&lt;ol>、&lt;li>、&lt;dl>、&lt;dt>、&lt;dd> &lt;h1>~&lt;h6>、&lt;p>、&lt;form>、&lt;hr>..... 行内标签：在一行，不换行。 非替换元素：&lt;b>、&lt;em>、&lt;a>、&lt;span>..... 替换元素：&lt;img>、&lt;input>、&lt;textarea>..... 代码实现:&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>高宽属性&lt;/title> &lt;style type=\"text/css\"> .one{min-width:500px;max-width: 300px;} .three{max-height:200px;min-height: 100px;background-color: #acacac;} p{background-color: #ececec;height:auto;width:200px;} span{ background-color: #acacac;width:200px;height:100px; } img{width:200px;height: 100px;} &lt;/style> &lt;/head> &lt;body> &lt;div> &lt;p>盒子模型高度height宽度width&lt;/p> &lt;span>盒子模型高度height宽度width&lt;/span> &lt;!-- 高宽属性适用块元素和替换元素 --> &lt;img src=\"img/html.jpg\" width=\"200px\"/>&lt;img src=\"img/css.jpg\" height=\"100px\"/> &lt;!-- 高度属性height --> &lt;p class=\"one\">盒子模型最大小高度度min-height和max-height;&lt;/p> &lt;!--宽度属性--> &lt;p class=\"three\">盒子模型最大小宽度min-width和max-width;&lt;/p> &lt;/div> &lt;/body> &lt;/html> 边框属性(border) 设置元素边框宽度 border-width : thin | medium | thick | 长度值 设置元素边框颜色 border-color ： 颜色 | transparent 设置元素边框样式 border-style : 值 | none | hidden 边框属性不同方向表示border-top : [宽度] | [样式] | [颜色] border-left : [宽度] | [样式] | [颜色] border-right : [宽度] | [样式] | [颜色] border-bottom ：[宽度] | [样式] | [颜色] 代码实现：&lt;!DOCTYPE HTML> &lt;html> &lt;head> &lt;title>边框属性&lt;/title> &lt;meta charset=\"utf-8\"/> &lt;/head> &lt;style type=\"text/css\"> p{width: 150px;height:100px;background-color: #ececec;line-height: 100px;} .one{border:10px #0099ee solid;} .two{border-top:5px red solid; border-left:10px blue dotted; border-right:10px blue dotted; border-bottom:5px red solid;} &lt;/style> &lt;body> &lt;!-- border属性不同方向设置 --> &lt;p class=\"one\">边框属性border&lt;/p> &lt;p class=\"two\">边框属性border&lt;/p> &lt;/body> &lt;/html> 内边距属性(padding) 设置元素的内容与边框之间的距离（内边距或填充）,分4个方向(上、右、下、左)。 – padding-top : 长度值 | 百分比 – padding-right :长度值 | 百分比 – padding-bottom :长度值 | 百分比 – padding-left :长度值 | 百分比 注意：说明：值不能为负值 内边距属性缩写padding : 值1； //4个方向都为值1 padding : 值1 值2 ; // 上下=值1，左右=值2 padding : 值1 值2 值3；// 上=值1，左右=值2，下=值3 padding : 值1 值2 值3 值4； // 上=值1，右=值2，下=值3,左=值2 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>padding属性相关设置&lt;/title> &lt;/head> &lt;style type=\"text/css\"> .one{width:300px;height:300px;background-color: #acacac; padding:20px 10px 5px 8px;} .content{width:100%;height:100%;background-color: #ececec;padding-top: 10px; padding-left: 5px;} &lt;/style> &lt;body> &lt;div class=\"one\">&lt;div class=\"content\">padding属性&lt;/div>&lt;/div> &lt;/body> &lt;/html> 结果显示 外边距属性 设置元素与元素之间的距离（外边距）, 4个方向（上、右、下、左） – margin-top : 长度值 | 百分比 | auto – margin-right : 长度值 | 百分比 | auto – margin-bottom : 长度值 | 百分比 | auto – margin-left : 长度值 | 百分比 | auto 注意：值可为负值 外边距属性缩写 设置元素与元素之间的距离（外边距）, 4个方向（上、右、下、左） margin : 值1； //4个方向都为值1 margin : 值1 值2 ; // 上下=值1，左右=值2 margin : 值1 值2 值3；// 上=值1，左右=值2，下=值3 margin : 值1 值2 值3 值4； // 上=值1，右=值2，下=值3,左=值2 块级元素 默认情况下，相应HTML块级元素存在外边距body、h1~h6、p….. 声明margin属性，覆盖默认样式 body,h1~h6,p{margin:0;} 水平居中 margin值为auto , 实现水平方向居中显示效果。 由浏览器计算外边距 外边距合并 垂直方向，两个相邻元素都设置外边距，外边距会发生合并 合并后外边距高度=两个发生合并外边距的高度中最大值 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>margin外边距&lt;/title> &lt;/head> &lt;style type=\"text/css\"> body,p{margin:0;} .content{width:100px;height:100px;background-color: #ececec;margin:auto;} .one{width:300px;height:300px;background-color: #acacac;margin-bottom: 20px;} .two{width:300px;height:300px;background-color: #acacac;margin-top:30px;} &lt;/style> &lt;body> &lt;div class=\"one\">&lt;div class=\"content\">margin属性&lt;/div>&lt;/div> &lt;div class=\"two\">&lt;div class=\"content\">margin属性&lt;/div>&lt;/div> &lt;/body> &lt;/html> display属性inline 元素将显示为内联元素，元素前后没有换行符。 block 元素将显示为块级元素 , 元素前后会带有换行符。 inline-block 行内块元素，元素呈现为inline，具有block相应特性。 none 此元素不会被显示。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>display属性&lt;/title> &lt;style type=\"text/css\"> div,span{background-color: #00aaee; border:1px #666 solid;} .one{font-size: 0px;} div{display:inline-block; font-size:16px; width:100px; height:30px; padding:5px; margin:10px;} span{display:none;} a:hover span{display:inline;} &lt;/style> &lt;/head> &lt;body> &lt;!--块级元素--> &lt;div>display属性-div&lt;/div> &lt;div>display属性-div&lt;/div> &lt;div>display属性-div&lt;/div> &lt;div>display属性-div&lt;/div> &lt;div>display属性-div&lt;/div> &lt;div>display属性-div&lt;/div> &lt;hr/> &lt;!--内联元素--> &lt;span>display属性-sapn&lt;/span>&lt;span>display属性-sapn&lt;/span>&lt;span>display属性-sapn&lt;/span> &lt;hr/> &lt;a href=\"#\">点我...&lt;span>和你玩游戏&lt;/span>&lt;/a> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}]},{"title":"CSS字体和文本样式","slug":"CSS/CSS字体和文本样式","date":"2018-12-23T13:46:51.000Z","updated":"2019-12-23T13:51:00.472Z","comments":true,"path":"2018/12/23/css/css-zi-ti-he-wen-ben-yang-shi/","link":"","permalink":"http://yoursite.com/2018/12/23/css/css-zi-ti-he-wen-ben-yang-shi/","excerpt":"","text":"字体属性 定义元素内文字以什么字体来显示。 语法：font-family:[字体1][,字体2][,…] 注意: 含空格字体名和中文，用英文引号(‘ ‘)括起。 多个字体，用英文逗号“，”隔开。 引号嵌套，外使用双引号，内使用单引号。 代码示例:&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>文字样式&lt;/title> &lt;style type=\"text/css\"> h1{font-family:\"Times New Roman\";} p{font-family:\"微软雅黑\",\"宋体\",\"黑体\",sans-serif;} &lt;/style> &lt;/head> &lt;body> &lt;h1 style=\"font-family:'宋体';\">CSS层叠样式表（Cascading Style Sheets）&lt;/h1> &lt;p>CSS目前最新版本为CSS3，是能够真正做到网页表现与内容分离的一种样式设计语言。&lt;/p> &lt;/body> &lt;/html> 字体大小属性font-size: 绝对单位|相对单位 px 像素 em/% 属性值 CCS2缩放系数1.2 xx-small 9px x-small 11px small 13px medium 16px large 19px x-large 23px xx-large 28px 代码示例&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>字体样式&lt;/title> &lt;style type=\"text/css\"> .larger{font-size:larger;} .smaller{font-size:smaller;} #fontSize{font-size: 20px;} .percent{font-size: 150%;} &lt;/style> &lt;/head> &lt;body> &lt;!-- 相对单位 --> &lt;p>文字大小px,受显示器分辨率影响&lt;/p> &lt;p>文字大小&lt;span class=\"larger\">相对父元素的文字大小变大&lt;/span>&lt;/p> &lt;p>文字大小&lt;span class=\"smaller\">相对父元素的文字大小变小&lt;/span>&lt;/p> &lt;div id=\"fontSize\"> &lt;p>文字大小&lt;span class=\"em\">相对值em&lt;/span>&lt;/p> &lt;p class=\"percent\">文字大小&lt;span class=\"percent\">相对值%&lt;/span>&lt;/p> &lt;/div> &lt;/body> &lt;/html> 文字颜色 定义元素内文字颜色 语法：color: 颜色名|十六进制|RGB 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>文字样式&lt;/title> &lt;style type=\"text/css\"> h1{color:red;}/*具体颜色名称*/ p{color:rgb(0%,100%,0%);}/*数字：0~255；百分比：0%~100%*/ div{color:#00880a;}/*十六进制：#开头，六位，0~F*/ &lt;/style> &lt;/head> &lt;body> &lt;h1>CSS层叠样式表（Cascading Style Sheets）&lt;/h1> &lt;p>CSS能够根据不同使用者的理解能力，简化或者优化写法，针对各类人群，有较强的易读性。&lt;/p> &lt;div>CSS目前最新版本为CSS3，是能够真正做到网页表现与内容分离的一种样式设计语言。&lt;/div> &lt;/body> &lt;/html> 文字粗细语法：font-weight: normal | bold | bolder | lighter | 100~900 注意: 默认值：normal。 400 等同于 normal，而 700 等同于 bold。 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>文字样式&lt;/title> &lt;style type=\"text/css\"> p{font-family: \"黑体\";} .normal{font-weight:normal;} .bold{font-weight:bold;} .bolder{font-weight:bolder;} .lighter{font-weight:lighter;} .f100{font-weight:100;} .f200{font-weight:200;} &lt;/style> &lt;/head> &lt;body> &lt;!-- HTML中加粗 --> &lt;p>字体粗细&lt;b>font-weight&lt;/b>&lt;/p> &lt;p>字体粗细&lt;strong>font-weight&lt;/strong>&lt;/p> &lt;!-- CSS样式加粗 --> &lt;p class=\"normal\">字体粗细font-weight：normal&lt;/p> &lt;p class=\"bolder\">字体粗细font-weight：bolder&lt;/p> &lt;p class=\"bold\">字体粗细font-weight：bold&lt;/p> &lt;p class=\"lighter\">字体粗细font-weight：lighter&lt;/p> &lt;!-- 数值 --> &lt;p class=\"f100\">字体粗细font-weight：100&lt;/p> &lt;p class=\"f200\">字体粗细font-weight：200&lt;/p> &lt;/body> &lt;/html> 文字样式 为元素内文字设置样式 语法:font-style: normal|italic|oblique 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>文字样式&lt;/title> &lt;style type=\"text/css\"> .normal{font-style:normal;} .italic{font-style:italic;} .oblique{font-style:oblique;} &lt;/style> &lt;/head> &lt;body> &lt;!-- HTMl中斜体 --> &lt;p>正常的字体&lt;/p> &lt;p>&lt;em>斜体&lt;/em>&lt;/p> &lt;p>&lt;i>斜体&lt;/i>&lt;/p> &lt;!-- CSS样式中斜体 --> &lt;p class=\"normal\">正常的字体&lt;/p> &lt;p class=\"italic\">斜体&lt;/p> &lt;p class=\"oblique\">倾斜&lt;/p> &lt;/body> &lt;/html> 字体变形 设置元素中文本为小型大写字母。 语法：font-variant: normal | small-caps 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>文字样式&lt;/title> &lt;style type=\"text/css\"> .fontVariant{font-variant:small-caps;} &lt;/style> &lt;/head> &lt;body> &lt;p>CSS层叠样式表（Cascading Style Sheets）&lt;/p> &lt;p class=\"fontVariant\">CSS层叠样式表（Cascading Style Sheets）&lt;/p> &lt;/body> &lt;/html> font属性(简写)语法：font : font-style font-variant font-weight font-size/line-height font-family 注意: 值之间空格隔开 注意书写顺序 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>文字样式&lt;/title> &lt;style type=\"text/css\"> P{ /*font-size:20px; font-family:\"黑体\",\"宋体\"; font-style:italic; font-weight:bold; font-variant: small-caps;*/ font:italic bold small-caps 50px/1.5em \"黑体\",\"宋体\"; } &lt;/style> &lt;/head> &lt;body> &lt;p>CSS层叠样式表（Cascading Style Sheets）&lt;/p> &lt;/body> &lt;/html> text-align 设置元素内文本的水平对齐方式。 语法：text-align: left | right | center | justify 代码实现注意：该属性对块级元素设置有效，如不是块级元素，可用块级元素对其进行封装。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> &lt;title>文本属性&lt;/title> &lt;style type=\"text/css\"> .text1{text-align:left;} .text2{text-align:center;} .text3{text-align:right;} .text4{text-align:justify;} .textAlign{text-align:center;} .textAlign p{width:50%;margin:0 auto;} &lt;/style> &lt;/head> &lt;body> &lt;div class=\"textAlign\"> &lt;P>指定宽度HTML 指的是超文本标记语言 (Hyper Text Markup Language), HTML 不是一种编程语言，而是一种标记语言 (markup language)。&lt;/P> &lt;/div> &lt;P class=\"text1\">文本左对齐：HTML 指的是超文本标记语言 (Hyper Text Markup Language), HTML 不是一种编程语言，而是一种标记语言 (markup language)。 &lt;/P> &lt;P class=\"text2\">文本居中对齐：HTML 指的是超文本标记语言 (Hyper Text Markup Language), HTML 不是一种编程语言，而是一种标记语言 (markup language),标记语言是一套标记标签。 &lt;/P> &lt;P class=\"text3\">文本右对齐：HTML 指的是超文本标记语言 (Hyper Text Markup Language), HTML 不是一种编程语言，而是一种标记语言 (markup language),标记语言是一套标记标签。 &lt;/P> &lt;P class=\"text4\">文本两端对齐：HTML 指的是超文本标记语言 (Hyper Text Markup Language), HTML 不是一种编程语言，而是一种标记语言 (markup language),标记语言是一套标记标签 。 &lt;/P> &lt;/body> &lt;/html> line-height属性 设置元素中文本行高。 语法：line-height: 长度值 | 百分比 注意： 一行文字的高度。 行高指文本行的基线间的距离。 代码实现：&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> &lt;title>文本属性&lt;/title> &lt;style type=\"text/css\"> .text1{background-color:#ececec;font-size:16px;} .text4{font-size:30px;line-height:35px;} .text4 span{line-height:50px;} h1{height:50px;background-color:#ececec;line-height:50px;} &lt;/style> &lt;/head> &lt;body> &lt;h1>HTML\\CSS\\JS关系&lt;/h1> &lt;div class=\"content\"> &lt;p class=\"text1\">网页必备技术，&lt;span style=\"line-height:20px;\">结构:HTML&lt;/span> ,&lt;span style=\"line-height:40px;\">样式:CSS ,&lt;span style=\"line-height:50px;\">动作:JavaScript。 &lt;/span>&lt;/p> &lt;p class=\"text2\">HTML（Hyper Text Markup Language）“超级文本标记语言”， 是Internet上用于设计网页的主要语言。使用标签将内容展示在网页中。 &lt;/p> &lt;p class=\"text3\">CSS（Cascading Style Sheets）译为“层叠样式表”，简称样式表。顾名思义就是设 计网页样式的。“样式”就是网页的文字、颜色、图片位置等格式；“层叠”的意思是当HTML中引用了多个样 式时，当样式文件中的样式发生冲突时，浏览器将依据层叠顺序处理。 &lt;/p> &lt;p class=\"text4\"> JavaScript在一定程度上弥补了HTML和CSS的缺陷，HTML和CSS的配合使用，提供给用户的只是一种静太 页面，缺少交互性。 &lt;/p> &lt;/div> &lt;/body> &lt;/html> vertical-align属性 设置元素内容的垂直方式。 语法:vertical-align: baseline | sub | super | top | text-top|middle | bottom | text-bottom 长度 | 百分比 文字基线 vertical-align垂直对齐 文本样式属性 字体属性 说明 word-spacing 设置元素内单词之间间距 letter-spacing 设置元素内字母之间间距 text-transform 设置元素内文本的大小写 text-decoration 设置元素内文本的装饰 text-transform capitalize |uppercase | lowercase | none text-decoration underline | overline | line-through | blink | none 代码实现&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>文本样式&lt;/title> &lt;style type=\"text/css\"> .one{word-spacing: 1em;} .two{letter-spacing: -0.5em;} .one2{text-transform: capitalize;} .one3{text-transform: uppercase;} .one4{text-transform: lowercase;} .one5{text-transform: none;} &lt;/style> &lt;/head> &lt;body> &lt;p>CSS层叠样式表（Cascading Style Sheets）&lt;/p> &lt;p class=\"one\">CSS层叠样式表（Cascading Style Sheets）&lt;/p> &lt;p class=\"two\">CSS层叠样式表（Cascading Style Sheets）&lt;/p> &lt;!--文本大小写问题--> &lt;p class=\"one2\">CSS层叠样式表（Cascading style sheets）,text-align&lt;/p> &lt;p class=\"one3\">CSS层叠样式表（Cascading style sheets）&lt;/p> &lt;p class=\"one4\">CSS层叠样式表（Cascading style sheets）&lt;/p> &lt;p class=\"one5\">CSS层叠样式表（Cascading style sheets）&lt;/p> &lt;/body> &lt;/body> &lt;/html> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}]}]}